syntax = "proto2";

import "trade_core.proto";
import "flux_options.proto";

package strat_executor;

message Residual{
  required Security security = 1 [(FluxFldHelp) = "security of leg with > residual_qty*last_px"];
  required float residual_notional = 2 [(FluxFldDisplayType) = "int", (FluxFldHelp) = "absolute of ((residual_qty*last_px) - (other_leg_residual_qty * other_leg_last_px) only if the value remains non 0 post residual_mark_seconds interval else 0 (in non 0 case mark the remaining non zero as residual and pull that qty form the market)"];
}

enum StratState{
  //set this state for strats just created by user
  StratState_UNSPECIFIED = 0;
  // set this state post required constraint validation of strat - such as system checked all required strat params are
  // present and are as expected, do this for:
  // 1. new strats before moving them to ready state upon user explicit save request
  // 2. existing strats when loading them from store (if validation fails - raise alert and put them in ERROR state)
  StratState_READY = 1;
  // set StratStatus.ACTIVE state upon explicit user request, check:
  // 1. all required strats and portfolio level limit checks are passing else reject user's request
  // 2. strat is in StratStatus.READY state (user triggers a strat)
  // 3. strat is in StratStatus.PAUSED state (resume paused strat)
  StratState_ACTIVE = 2;
  // set StratStatus.PAUSED state upon explicit user request, check strat is currently in StratStatus.READY state
  StratState_PAUSED = 3;
  // this is set in any exception scenario - dev/support/business involvement is needed to find the gap and bridge
  // for future handling of similar scenario, day-1 block strat (only engine restart can allow strat to be restarted)
  StratState_ERROR = 4;
  // set StratStatus.PAUSED state when strat has completed its set target
  StratState_DONE = 5;
  // set StratState_SNOOZED state when strat is unloaded from collection
  StratState_SNOOZED = 6;
}

message MarketTradeVolumeParticipation{
    required float max_participation_rate = 1 [(FluxFldNumberFormat) = "%", (FluxFldValMax) = "30", (FluxFldHelp) = "max % participation size allowed of rolling trade volume within applicable_period_seconds"];
    optional int32 applicable_period_seconds = 2 [(FluxFldHelp) = "sliding window interval of above rate enforcement, unset value implies seconds from SOD till time of checking"];
}

message OpenInterestParticipation{
  required float participation_rate = 1 [(FluxFldValMax) = "100", (FluxFldHelp) = 'max % participation size allowed within side specific volume of Top (depth_levels) of BBBO'];
  required int32 depth_levels = 2 [(FluxFldValMax) = "20", (FluxFldHelp) = "allowed depth levels participating in allowed size computation - not to be confused with tick levels which may be missing depending on liquidity at specific tick level"];
}

message CancelRate{
  required int32 max_cancel_rate = 1 [(FluxFldNumberFormat) = "%", (FluxFldValMax) = "20", (FluxFldHelp) = "% of total size sent to market [BUY+SELL] - ignoring what happened to the qty on exchange (e.g. reject / cancelled are also counted)"];
  optional int32 applicable_period_seconds = 2 [(FluxFldHelp) = "sliding window interval of above rate enforcement, not setting this value implies SOD is window-start & checking-time as window-end"];
  optional int32 waived_min_orders = 3 [(FluxFldHelp) = "enforce check only after waived_min_orders have been sent to market irrespective of the participant order outcome -ack, reject, cancelled, lapsed"];
}

message ResidualRestriction{
  required float max_residual = 1 [(FluxFldValMax) = "500000", (FluxFldHelp) = "allowed max residual: pauses strat if this breaches"];
  required int32 residual_mark_seconds = 2 [(FluxFldHelp) = "residual is only marked if this period expires but residual does not go to 0; currently restricted to minimum of 2X app refresh interval"];
}

