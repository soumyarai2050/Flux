syntax = "proto2";
import "flux_options.proto";

package addressbook;


enum OrderEventType{
  OE_UNSPECIFIED = 0;
  OE_NEW = 1;
  OE_ACK = 2;
  OE_CXL = 3;
  OE_CXL_ACK = 4;
  OE_CXL_REJ = 5;
  OE_REJ = 6;
}

enum OrderStatusType{
  OE_UNACK = 0;
  OE_ACKED = 1;
  OE_CXL_UNACK = 2;
  OE_DOD = 3;
  OE_FILLED = 4;
  OE_OVER_FILLED = 5;
}

enum SecurityType{
  SEC_TYPE_UNSPECIFIED = 0;
  RIC = 1;
  SEDOL = 2;
  TICKER = 3;
}

enum Side{
    SIDE_UNSPECIFIED = 0;
    BUY = 1;
    SELL = 3;
    BTC = 2;  // Buy to Cover - Use Buy, set this only if downstream need's BTC awareness
    SS = 4;  // Short Sell - Use Sell, set this only if downstream need's Short Sell awareness
}

enum PositionType{
  POS_TYPE_UNSPECIFIED = 0;
  PTH = 1; // Pay to hold driven
  LOCATE = 2; // Borrow driven
  SOD = 3; // past trades driven
}

enum ReferencePxType{
  OPEN_PX = 1;
  CLOSE_PX = 2;
  LAST_PX = 3;
  BB_PX = 4;
  BO_PX = 5;
  FILL_PX = 6;
}

// , ERROR, WARNING, INFO, DEBUG, UNSPECIFIED
enum Severity{
  Severity_UNSPECIFIED = 0;  // GRAY
  Severity_CRITICAL = 1; // RED FLASHING
  Severity_ERROR = 2; // RED
  Severity_WARNING = 3; // AMBER
  Severity_INFO = 4; // BLUE
  Severity_DEBUG = 5; // BLACK
}

enum StratState{
  //set this state for strats just created by user
  StratState_UNSPECIFIED = 0;
  // set this state post required constraint validation of strat - such as system checked all required strat params are
  // present and are as expected, do this for:
  // 1. new strats before moving them to ready state upon user explicit save request
  // 2. existing strats when loading them from store (if validation fails - raise alert and put them in ERROR state)
  StratState_READY = 1;
  // set StratStatus.ACTIVE state upon explicit user request, check:
  // 1. all required strats and portfolio level limit checks are passing else reject user's request
  // 2. strat is in StratStatus.READY state (user triggers a strat)
  // 3. strat is in StratStatus.PAUSED state (resume paused strat)
  StratState_ACTIVE = 2;
  // set StratStatus.PAUSED state upon explicit user request, check strat is currently in StratStatus.READY state
  StratState_PAUSED = 3;
  // this is set in any exception scenario - dev/support/business involvement is needed to find the gap and bridge
  // for future handling of similar scenario, day-1 block strat (only engine restart can allow strat to be restarted)
  StratState_ERROR = 4;
  // set StratStatus.PAUSED state when strat has completed its set target
  StratState_DONE = 5;
}

message ReferencePx{
  required float px = 1;
  required ReferencePxType reference_px_type = 2;
}

message Quote{
  required float px = 1;
  required int64 qty = 2;
}

// stores all position types from all sources for optimal selection, usage and clearance
// one can design to make entry with the cheapest option first & clear the most expensive used position first
message Position{
  required string id = 1 [(FluxFldOrmNoUpdate) = true, (FluxFldServerPopulate) = true, (FluxFldHide) = "True"];
  optional bool pos_disable = 2 [default = false, (FluxFldButton) = {
    unpressed_caption: "disable",
    pressed_caption: "enable",
    value_color_map: "true=DEBUG,false=SUCCESS",
    button_type: BUTTON_TYPE_RECTANGLE,
    button_size: BUTTON_SIZE_MEDIUM,
    action: "flux_toggle",
    pressed_value_as_text: "true"
  }];
  required PositionType type = 3;
  // available position size for consumption
  required int64 available_size = 4;
  // position committed but not consumed (portfolio to strat; day-2: maybe strat to open order)
  required int64 allocated_size = 5;
  // actual position consumption
  required int64 consumed_size = 6;
  // cost of using this position type
  optional float acquire_cost = 7;
  // un-avoidable charge due to this position type (irrespective of use / no-use)
  optional float incurred_cost = 8;
  // T+1 and onwards recurring daily cost
  optional float carry_cost = 9;
  optional int32 priority = 10 [default = 10, (FluxFldHelp) = "default priority: 10,  orders to respect specified priority (lower value is higher priority), duplicates allowed"];
  optional float premium_percentage = 11 [default = 2];
}

message SecPosition{
  required string id = 1 [(FluxFldOrmNoUpdate) = true, (FluxFldServerPopulate) = true, (FluxFldHide) = "True"];
  required Security security = 2 [(FluxFldAutoComplete) = "sec_id:EQT_List, sec_type=TICKER", (FluxFldHelp) = "EQT Tickers"];
  // per position type (PTH, LOCATE, LONG)
  repeated Position positions = 3;
}

message Broker{
  required string id = 1 [(FluxFldOrmNoUpdate) = true, (FluxFldServerPopulate) = true, (FluxFldHide) = "True"];
  required bool bkr_disable = 2 [default=false, (FluxFldButton) = {
    unpressed_caption: "disable",
    pressed_caption: "enable",
    value_color_map: "true=DEBUG,false=SUCCESS"
    button_type: BUTTON_TYPE_RECTANGLE,
    button_size: BUTTON_SIZE_MEDIUM,
    action: "flux_toggle",
    pressed_value_as_text: "true"
  }];
  // per security positions
  repeated SecPosition sec_positions = 3;
  // broker identifier
  required string broker = 4;
  optional int32 bkr_priority = 5 [default = 10, (FluxFldHelp) = "default priority 10, embedded position priorities are relative within broker priority level group; orders respect specified priority (lower value is higher priority), duplicates allowed"];
}

// Don't rename fields - if you must , update loaded_strat_keys abbreviation accordingly
message Security{
    required string sec_id = 1 [(FluxFldUIPlaceholder) = "SelectSecurity", (FluxFldSticky) = true];
    optional SecurityType sec_type = 2 [default = SEC_TYPE_UNSPECIFIED];
}

message MaxNotional{
  required float max_per_side_notional = 1 [(FluxFldHelp) = "non-changeable from UI: used as cap on max per side notional at time of strat creation"];
  required float max_primary_notional = 2 [ (FluxFldHelp) = "consumption: open+executed, max eqt notional derived applying hedge ratio"];
  required float sod = 3;
  required float available_pths = 4;
  required float available_locates = 5;
}

message ResidualRestriction{
  required float max_residual = 1 [(FluxFldHelp) = "allowed max residual: pauses strat if this breaches"];
  required int32 residual_mark_seconds = 2 [(FluxFldHelp) = "residual is only marked if this period expires but residual does not go to 0; currently restricted to minimum of 2X app refresh interval"];
}

message OrderBrief{
  required string order_id = 1;
  required Security security = 2;
  required Side side = 3;
  optional float px = 4;
  optional int64 qty = 5;
  optional float order_notional = 6;
  required string underlying_account = 7;
  repeated string text = 8 [(FluxFldAbbreviated) = "JSON", (FluxFldHelp) = "can hold free text for instance for specific order state"];
}

message Alert{
  required string id = 1 [(FluxFldOrmNoUpdate) = true, (FluxFldServerPopulate) = true, (FluxFldHide) = "True"];
  optional bool dismiss = 2 [default=false, (FluxFldUIUpdateOnly) = true, (FluxFldSequenceNumber) = 1, (FluxFldButton) = {
    unpressed_caption: "dismiss",
    pressed_caption: "undo",
    value_color_map: "true=DEBUG,false=INFO"
    button_type: BUTTON_TYPE_RECTANGLE,
    button_size: BUTTON_SIZE_MEDIUM,
    action: "flux_toggle",
    pressed_value_as_text: "true"
  }];
  required Severity severity = 3 [(FluxFldColor) = "Severity_CRITICAL=CRITICAL,Severity_ERROR=ERROR,Severity_WARNING=WARNING,Severity_INFO=INFO, Severity_DEBUG=DEBUG, Severity_UNSPECIFIED=UNSPECIFIED"];
  required string alert_brief = 4 [(FluxFldSizeMax) = 32];
  // must prefix strat:<strat-name> for strat alerts
  optional string alert_details = 5 [(FluxFldAbbreviated) = "JSON"];
  // populated only if this alert is for one or more orders
  repeated OrderBrief impacted_order = 6;
}

message Residual{
  required Security security = 1 [(FluxFldHelp) = "security of leg with > residual_qty*last_px"];
  required float residual_notional = 2 [(FluxFldHelp) = "absolute of ((residual_qty*last_px) - (other_leg_residual_qty * other_leg_last_px) only if the value remains non 0 post residual_mark_seconds interval else 0 (in non 0 case mark the remaining non zero as residual and pull that qty form the market)"];
}

message MarketTradeVolumeParticipation{
    required float max_participation_rate = 1 [(FluxFldHelp) = "max % participation size allowed of rolling trade volume within applicable_period_seconds"];
    optional int32 applicable_period_seconds = 2 [(FluxFldHelp) = "sliding window interval of above rate enforcement, unset value implies seconds from SOD till time of checking"];
}

message OpenInterestParticipation{
  required float participation_rate = 1 [(FluxFldHelp) = 'max % participation size allowed within side specific volume of Top (depth_levels) of BBBO'];
  required int32 depth_levels = 2 [(FluxFldHelp) = "allowed depth levels participating in allowed size computation - not to be confused with tick levels which may be missing depending on liquidity at specific tick level"];
}

message CancelRate{
  required int32 max_cancel_rate = 1 [(FluxFldHelp) = "% of total size sent to market [BUY+SELL] - ignoring what happened to the qty on exchange (e.g. reject / cancelled are also counted)"];
  optional int32 applicable_period_seconds = 2 [(FluxFldHelp) = "sliding window interval of above rate enforcement, not setting this value implies SOD is window-start & checking-time as window-end"];
}

message RollingMaxOrderCount{
  required int32 max_order_count = 1 [(FluxFldHelp) = "max new orders count allowed per period defined below"];
  optional int32 order_count_period_seconds = 2 [(FluxFldHelp) = "sliding window interval of above rate enforcement, not setting this value implies SOD is window-start & checking-time as window-end"];
}
