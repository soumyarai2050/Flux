# standard imports
import copy
import math
import concurrent.futures
import random
import time

import pytest
import pandas as pd
import polars as pl

# project imports
from tests.CodeGenProjects.AddressBook.ProjectGroup.phone_book.app.utility_test_functions import *
from Flux.CodeGenProjects.AddressBook.ProjectGroup.phone_book.app.phone_book_service_helper import get_plan_key_from_pair_plan
from Flux.CodeGenProjects.AddressBook.ProjectGroup.phone_book.generated.ORMModel.email_book_service_model_imports import *
from Flux.CodeGenProjects.AddressBook.ProjectGroup.street_book.generated.ORMModel.street_book_service_model_imports import *
from Flux.CodeGenProjects.AddressBook.ProjectGroup.photo_book.generated.ORMModel.photo_book_service_model_imports import *
from Flux.CodeGenProjects.AddressBook.ORMModel.dept_book_n_mobile_book_n_street_book_n_basket_book_core_msgspec_model import *

email_book_service_beanie_web_client: EmailBookServiceHttpClient = \
    EmailBookServiceHttpClient.set_or_get_if_instance_exists(HOST, parse_to_int(PAIR_STRAT_BEANIE_PORT))
email_book_service_cache_web_client: EmailBookServiceHttpClient = \
    EmailBookServiceHttpClient.set_or_get_if_instance_exists(HOST, parse_to_int(PAIR_STRAT_CACHE_PORT))

if email_book_service_beanie_web_client.port == email_book_service_native_web_client.port:
    clients_list = [email_book_service_beanie_web_client]
else:
    clients_list = [email_book_service_beanie_web_client, email_book_service_cache_web_client]


# test cases requires phone_book and log_book database to be present
def test_deep_clean_database_n_logs():
    drop_all_databases()
    clean_project_logs()


def test_clean_database_n_logs():
    clean_all_collections_ignoring_ui_layout()
    clean_project_logs()


def test_sanity_create_plan_parallel(static_data_, clean_and_set_limits, buy_sell_symbol_list, pair_plan_,
                                       expected_plan_limits_, expected_start_status_, symbol_overview_obj_list,
                                       market_depth_basemodel_list):
    max_count = int(len(buy_sell_symbol_list)/2)
    with concurrent.futures.ThreadPoolExecutor(max_workers=max_count) as executor:
        results = [executor.submit(create_n_activate_plan, buy_symbol, sell_symbol, copy.deepcopy(pair_plan_),
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_start_status_), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), None, None)
                   for buy_symbol, sell_symbol in buy_sell_symbol_list[:max_count]]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())


@pytest.mark.nightly
def test_clean_and_set_limits(clean_and_set_limits):
    pass


# @@@ This test was checking assign_missing_ids_n_handle_date_time_type function which was used in beanie to handle
#     missing id and datetime fields in patch cases dynamically - now in new impl, we have code generated functions
#     for each Model putting missing ids and updating datetime fields directly - new impl is more efficient
# @pytest.mark.nightly
# def test_patch_with_missing_id_param(get_missing_id_json):
#     sample_json, sample_model_type = get_missing_id_json
#
#     # removing all id fields
#     del sample_json['_id']
#     del sample_json['field1']['_id']
#     del sample_json['field2'][0]['_id']
#     del sample_json['field2'][1]['_id']
#     del sample_json['field2'][2]['_id']
#     del sample_json['field3']['_id']
#     del sample_json['field4'][0]['_id']
#     del sample_json['field4'][1]['_id']
#     del sample_json['field4'][2]['_id']
#     del sample_json['field6']['_id']
#
#     assign_missing_ids_n_handle_date_time_type(sample_model_type, sample_json)
#
#     print(sample_json)
#     assert sample_json['field1'].get('_id') is not None, \
#         "assign_missing_ids_n_handle_date_time_type failed to set sample_json['field1']['_id']"
#     assert sample_json['field2'][0].get('_id') is not None, \
#         "assign_missing_ids_n_handle_date_time_type failed to set sample_json['field2'][0]['_id']"
#     assert sample_json['field2'][1].get('_id') is not None, \
#         "assign_missing_ids_n_handle_date_time_type failed to set sample_json['field2'][1]['_id']"
#     assert sample_json['field2'][2].get('_id') is not None, \
#         "assign_missing_ids_n_handle_date_time_type failed to set sample_json['field2'][2]['_id']"
#     assert sample_json['field3'].get('_id') is not None, \
#         "assign_missing_ids_n_handle_date_time_type failed to set sample_json['field3']['_id']"
#     assert sample_json['field4'][0].get('_id') is not None, \
#         "assign_missing_ids_n_handle_date_time_type failed to set sample_json['field4'][0]['_id']"
#     assert sample_json['field4'][1].get('_id') is not None, \
#         "assign_missing_ids_n_handle_date_time_type failed to set sample_json['field4'][1]['_id']"
#     assert sample_json['field4'][2].get('_id') is not None, \
#         "assign_missing_ids_n_handle_date_time_type failed to set sample_json['field4'][2]['_id']"
#     assert sample_json['field6'].get('_id') is not None, \
#         "assign_missing_ids_n_handle_date_time_type failed to set sample_json['field6']['_id']"

@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_create_get_put_patch_delete_client(clean_and_set_limits, web_client):
    for index, return_type_param in enumerate([True, None, False]):
        sample_model_obj = SampleModelBaseModel.from_kwargs(_id=1 + index, num=2, date=get_utc_date_time())
        # testing create_chore_limits_client()
        created_sample_model_obj = web_client.create_sample_model_client(sample_model_obj,
                                                                         return_obj_copy=return_type_param)
        # cumulative field updates when created
        sample_model_obj.cum_sum_of_num = sample_model_obj.num

        if return_type_param:
            assert created_sample_model_obj == sample_model_obj, \
                f"Created obj {created_sample_model_obj} mismatched expected sample_model_obj {sample_model_obj}"
        else:
            assert created_sample_model_obj

        # checking if created obj present in get_all objects
        fetched_sample_model_list = web_client.get_all_sample_model_client()
        assert sample_model_obj in fetched_sample_model_list, \
            f"Couldn't find expected sample_model_obj {sample_model_obj} in get-all fetched list of objects"

        # Checking get_by_id client
        fetched_sample_model_obj = web_client.get_sample_model_client(sample_model_obj.id)
        assert fetched_sample_model_obj == sample_model_obj, \
            f"Mismatched expected sample_model_obj {sample_model_obj} from " \
            f"fetched_chore_limits obj fetched by get_by_id {fetched_sample_model_obj}"

        # checking put operation client
        sample_model_obj.sample = "Sample"
        updated_sample_model_obj = web_client.put_sample_model_client(sample_model_obj,
                                                                      return_obj_copy=return_type_param)
        if return_type_param:
            assert updated_sample_model_obj == sample_model_obj, \
                f"Mismatched expected sample_model_obj: {sample_model_obj} from updated obj: {updated_sample_model_obj}"
        else:
            assert updated_sample_model_obj

        # checking patch operation client
        patch_sample_model_obj = SampleModelBaseModel.from_kwargs(_id=sample_model_obj.id, sample="updated_sample")
        # making changes to expected_obj
        sample_model_obj.sample = patch_sample_model_obj.sample

        patch_updated_sample_model_obj = \
            web_client.patch_sample_model_client(patch_sample_model_obj.to_dict(exclude_none=True),
                                                 return_obj_copy=return_type_param)
        if return_type_param:
            assert patch_updated_sample_model_obj == sample_model_obj, \
                f"Mismatched expected obj: {sample_model_obj} from patch updated obj {patch_updated_sample_model_obj}"
        else:
            assert patch_updated_sample_model_obj

        # checking delete operation client
        delete_resp = web_client.delete_sample_model_client(sample_model_obj.id, return_obj_copy=return_type_param)
        if return_type_param:
            assert isinstance(delete_resp, dict), \
                f"Mismatched type of delete resp, expected dict received {type(delete_resp)}"
            assert delete_resp.get("id") == sample_model_obj.id, \
                f"Mismatched delete resp id, expected {sample_model_obj.id} received {delete_resp.get('id')}"
        else:
            assert delete_resp


@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_create_get_put_patch_delete_time_series_model(clean_and_set_limits, web_client):
    for index, return_type_param in enumerate([True, None, False]):
        formatted_dt_utc = pendulum.DateTime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        sample_ts_model_obj = SampleTSModelBaseModel.from_kwargs(_id=index+1, sample=f"sample{index}",
                                                                 date=pendulum.parse(formatted_dt_utc))
        # testing create_chore_limits_client()
        created_sample_ts_model_obj = web_client.create_sample_ts_model_client(sample_ts_model_obj,
                                                                               return_obj_copy=return_type_param)
        if return_type_param:
            assert created_sample_ts_model_obj == sample_ts_model_obj, \
                (f"Created obj {created_sample_ts_model_obj} mismatched expected "
                 f"sample_ts_model_obj {sample_ts_model_obj}")
        else:
            assert created_sample_ts_model_obj

        # checking if created obj present in get_all objects
        fetched_sample_ts_model_list = web_client.get_all_sample_ts_model_client()
        assert sample_ts_model_obj in fetched_sample_ts_model_list, \
            f"Couldn't find expected sample_ts_model_obj {sample_ts_model_obj} in get-all fetched list of objects"

        # Checking get_by_id client
        fetched_sample_ts_model_obj = web_client.get_sample_ts_model_client(sample_ts_model_obj.id)
        assert fetched_sample_ts_model_obj == sample_ts_model_obj, \
            f"Mismatched expected sample_ts_model_obj {sample_ts_model_obj} from " \
            f"fetched_sample_ts_model_obj fetched by get_by_id {fetched_sample_ts_model_obj}"

        # checking put operation client
        sample_ts_model_obj.sample = f"sample{index}{index}"
        formatted_dt_utc = pendulum.DateTime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        sample_ts_model_obj.date = pendulum.parse(formatted_dt_utc)
        updated_sample_ts_model_obj = web_client.put_sample_ts_model_client(sample_ts_model_obj,
                                                                            return_obj_copy=return_type_param)
        if return_type_param:
            assert updated_sample_ts_model_obj == sample_ts_model_obj, \
                (f"Mismatched expected sample_ts_model_obj: {sample_ts_model_obj} "
                 f"from updated obj: {updated_sample_ts_model_obj}")
        else:
            assert updated_sample_ts_model_obj

        # checking patch operation client
        patch_sample_ts_model_obj = SampleTSModelBaseModel.from_kwargs(_id=sample_ts_model_obj.id,
                                                                       sample=f"sample{index}{index}")
        # making changes to expected_obj
        sample_ts_model_obj.sample = patch_sample_ts_model_obj.sample

        patch_updated_sample_ts_model_obj = \
            web_client.patch_sample_ts_model_client(patch_sample_ts_model_obj.to_dict(
                exclude_none=True), return_obj_copy=return_type_param)
        if return_type_param:
            assert patch_updated_sample_ts_model_obj == sample_ts_model_obj, \
                (f"Mismatched expected obj: {sample_ts_model_obj} from patch "
                 f"updated obj {patch_updated_sample_ts_model_obj}")
        else:
            assert patch_updated_sample_ts_model_obj

        # checking delete operation client
        delete_resp = web_client.delete_sample_ts_model_client(
            sample_ts_model_obj.id, return_obj_copy=return_type_param)
        if return_type_param:
            assert isinstance(delete_resp, dict), \
                f"Mismatched type of delete resp, expected dict received {type(delete_resp)}"
            assert delete_resp.get("id") == sample_ts_model_obj.id, \
                f"Mismatched delete resp id, expected {sample_ts_model_obj.id} received {delete_resp.get('id')}"
        else:
            assert delete_resp


@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_post_all(clean_and_set_limits, web_client):
    for msgspec_basemodel, get_all_client, create_all_client in \
            [(SampleModelBaseModel, web_client.get_all_sample_model_client,
              web_client.create_all_sample_model_client),
             (SampleTSModelBaseModel, web_client.get_all_sample_ts_model_client,
              web_client.create_all_sample_ts_model_client)]:
        for index, return_value_type in enumerate([True, None, False]):
            sample_model_objects_list = [
                msgspec_basemodel.from_kwargs(_id=1 + (index * 3), sample="sample1",
                                                 date=get_utc_date_time(), num=1,
                                                 cum_sum_of_num=1+index*3),
                msgspec_basemodel.from_kwargs(_id=2 + (index * 3), sample="sample2",
                                                 date=get_utc_date_time(), num=1, cum_sum_of_num=2+index*3),
                msgspec_basemodel.from_kwargs(_id=3 + (index * 3), sample="sample3",
                                                 date=get_utc_date_time(), num=1, cum_sum_of_num=3+index*3)
            ]

            fetched_sample_model_list = get_all_client()

            for obj in sample_model_objects_list:
                assert obj not in fetched_sample_model_list, f"Object {obj} must not be present in get-all list " \
                                                                f"{fetched_sample_model_list} before post-all operation"

            return_value = create_all_client(sample_model_objects_list, return_obj_copy=return_value_type)
            if return_value_type or return_value_type is None:
                assert isinstance(return_value, List), ("Mismatched: returned value from client must be list, "
                                                        f"received type: {type(return_value)}")
            else:
                assert (isinstance(return_value, bool) and return_value)

            fetched_sample_model_list = get_all_client()

            for obj in sample_model_objects_list:
                assert obj in fetched_sample_model_list, f"Couldn't find object {obj} in get-all list " \
                                                            f"{fetched_sample_model_list}"


@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_post_all_with_msgspec_list_in_df_out_client(clean_and_set_limits, web_client):
    for msgspec_basemodel, get_all_client, create_all_model_list_in_df_out_client, get_all_df_client in \
            [(SampleModelBaseModel, web_client.get_all_sample_model_client,
              web_client.create_all_sample_model_model_list_in_df_out_client,
              web_client.get_all_sample_model_df_client),
             (SampleTSModelBaseModel, web_client.get_all_sample_ts_model_client,
              web_client.create_all_sample_ts_model_model_list_in_df_out_client,
              web_client.get_all_sample_ts_model_df_client)]:

        for index, return_value_type in enumerate([True, None, False]):
            sample_model_objects_list = [
                msgspec_basemodel.from_kwargs(_id=1 + (index * 3), sample="sample1",
                                                 date=get_utc_date_time(), num=1,
                                                 cum_sum_of_num=1 + index * 3),
                msgspec_basemodel.from_kwargs(_id=2 + (index * 3), sample="sample2",
                                                 date=get_utc_date_time(), num=1, cum_sum_of_num=2 + index * 3),
                msgspec_basemodel.from_kwargs(_id=3 + (index * 3), sample="sample3",
                                                 date=get_utc_date_time(), num=1, cum_sum_of_num=3 + index * 3)
            ]
            sample_df = pl.DataFrame(generic_encoder(sample_model_objects_list, msgspec_basemodel.enc_hook,
                                                     by_alias=True, exclude_none=True))

            fetched_sample_model_list = get_all_client()

            for obj in sample_model_objects_list:
                assert obj not in fetched_sample_model_list, f"Object {obj} must not be present in get-all list " \
                                                             f"{fetched_sample_model_list} before post-all operation"

            # Insert the data into the database
            return_value = create_all_model_list_in_df_out_client(sample_model_objects_list,
                                                                  return_obj_copy=return_value_type)
            if return_value_type or return_value_type is None:
                assert isinstance(return_value, pl.DataFrame), \
                    f"Mismatched: returned value from client must be a Polars DataFrame, received type: {type(return_value)}"
            else:
                assert isinstance(return_value, bool) and return_value, \
                    "Expected a boolean return value indicating success"

            # Fetch the data again
            fetched_sample_df = get_all_df_client()
            assert isinstance(fetched_sample_df, pl.DataFrame), \
                f"Expected fetched data to be a Polars DataFrame, found {fetched_sample_df}"

            # Verify that all rows of sample_df exist in fetched_sample_df
            merged_df = sample_df.join(
                fetched_sample_df, on="_id", how="inner"
            )
            assert merged_df.height == sample_df.height, \
                f"Not all objects from sample_df were found in fetched_sample_df. Mismatch: {sample_df - merged_df}"


@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_post_all_with_df_in_msgspec_model_out_client(clean_and_set_limits, web_client):
    for msgspec_basemodel, get_all_client, create_all_df_in_model_list_out_client, get_all_df_client in \
            [(SampleModelBaseModel, web_client.get_all_sample_model_client,
              web_client.create_all_sample_model_df_in_model_list_out_client,
              web_client.get_all_sample_model_df_client),
             (SampleTSModelBaseModel, web_client.get_all_sample_ts_model_client,
              web_client.create_all_sample_ts_model_df_in_model_list_out_client,
              web_client.get_all_sample_ts_model_df_client)]:
        for index, return_value_type in enumerate([True, None, False]):
            # Create sample data as a Polars DataFrame
            sample_data = [
                {"_id": 1 + (index * 3), "sample": "sample1", "date": get_utc_date_time(), "num": 1, "cum_sum_of_num": 1 + index * 3},
                {"_id": 2 + (index * 3), "sample": "sample2", "date": get_utc_date_time(), "num": 1, "cum_sum_of_num": 2 + index * 3},
                {"_id": 3 + (index * 3), "sample": "sample3", "date": get_utc_date_time(), "num": 1, "cum_sum_of_num": 3 + index * 3},
            ]
            sample_df = pl.DataFrame(sample_data)
            sample_model_objects_list = msgspec_basemodel.from_dict_list(sample_df.to_dicts())

            # Fetch all existing data as a DataFrame
            fetched_sample_df = get_all_df_client()
            assert isinstance(fetched_sample_df, pl.DataFrame), "Expected fetched data to be a Polars DataFrame"

            # Check if fetched_sample_df is empty
            if not fetched_sample_df.is_empty():
                # Assert that the sample data is not yet present in the database
                assert not sample_df.filter(
                    sample_df["_id"].is_in(fetched_sample_df["_id"])
                ).height, \
                    f"Some objects from sample_df already exist in fetched_sample_df: {fetched_sample_df}"

            # Insert the data into the database
            return_value = create_all_df_in_model_list_out_client(sample_df, return_obj_copy=return_value_type)
            if return_value_type or return_value_type is None:
                assert isinstance(return_value, List), ("Mismatched: returned value from client must be list, "
                                                        f"received type: {type(return_value)}")
            else:
                assert (isinstance(return_value, bool) and return_value)

            fetched_sample_model_list = get_all_client()

            for obj in sample_model_objects_list:
                assert obj in fetched_sample_model_list, f"Couldn't find object {obj} in get-all list " \
                                                         f"{fetched_sample_model_list}"


@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_post_all_with_df_in_df_out_client(clean_and_set_limits, web_client):
    for create_all_df_in_df_out_client, get_all_df_client in \
            [(web_client.create_all_sample_model_df_in_df_out_client,
              web_client.get_all_sample_model_df_client),
             (web_client.create_all_sample_ts_model_df_in_df_out_client,
              web_client.get_all_sample_ts_model_df_client)]:
        for index, return_value_type in enumerate([True, None, False]):
            # Create sample data as a Polars DataFrame
            sample_data = [
                {"_id": 1 + (index * 3), "sample": "sample1", "date": get_utc_date_time(), "num": 1, "cum_sum_of_num": 1 + index * 3},
                {"_id": 2 + (index * 3), "sample": "sample2", "date": get_utc_date_time(), "num": 1, "cum_sum_of_num": 2 + index * 3},
                {"_id": 3 + (index * 3), "sample": "sample3", "date": get_utc_date_time(), "num": 1, "cum_sum_of_num": 3 + index * 3},
            ]
            sample_df = pl.DataFrame(sample_data)

            # Fetch all existing data as a DataFrame
            fetched_sample_df = get_all_df_client()
            assert isinstance(fetched_sample_df, pl.DataFrame), "Expected fetched data to be a Polars DataFrame"

            # Check if fetched_sample_df is empty
            if not fetched_sample_df.is_empty():
                # Assert that the sample data is not yet present in the database
                assert not sample_df.filter(
                    sample_df["_id"].is_in(fetched_sample_df["_id"])
                ).height, \
                    f"Some objects from sample_df already exist in fetched_sample_df: {fetched_sample_df}"

            # Insert the data into the database
            return_value = create_all_df_in_df_out_client(sample_df, return_obj_copy=return_value_type)
            if return_value_type or return_value_type is None:
                assert isinstance(return_value, pl.DataFrame), \
                    f"Mismatched: returned value from client must be a Polars DataFrame, received type: {type(return_value)}"
            else:
                assert isinstance(return_value, bool) and return_value, \
                    "Expected a boolean return value indicating success"

            # Fetch the data again
            fetched_sample_df = get_all_df_client()
            assert isinstance(fetched_sample_df, pl.DataFrame), \
                f"Expected fetched data to be a Polars DataFrame, found {fetched_sample_df}"

            # Verify that all rows of sample_df exist in fetched_sample_df
            merged_df = sample_df.join(
                fetched_sample_df, on="_id", how="inner"
            )
            assert merged_df.height == sample_df.height, \
                f"Not all objects from sample_df were found in fetched_sample_df. Mismatch: {sample_df - merged_df}"


@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_put_all(clean_and_set_limits, web_client):
    for msgspec_basemodel, get_all_client, create_all_client, put_all_client in \
            [(SampleModelBaseModel, web_client.get_all_sample_model_client,
              web_client.create_all_sample_model_client,
              web_client.put_all_sample_model_client),
             (SampleTSModelBaseModel, web_client.get_all_sample_ts_model_client,
              web_client.create_all_sample_ts_model_client, 
              web_client.put_all_sample_ts_model_client)]:
        for index, return_value_type in enumerate([True, None, False]):
            sample_model_objects_list = [
                msgspec_basemodel.from_kwargs(_id=1 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                                 date=get_utc_date_time(), num=1, cum_sum_of_num=1+index*3),
                msgspec_basemodel.from_kwargs(_id=2 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                                 date=get_utc_date_time(), num=1, cum_sum_of_num=2+index*3),
                msgspec_basemodel.from_kwargs(_id=3 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                                 date=get_utc_date_time(), num=1, cum_sum_of_num=3+index*3)
            ]

            create_all_client(sample_model_objects_list)

            fetched_sample_model_list = get_all_client()

            for obj in sample_model_objects_list:
                assert obj in fetched_sample_model_list, f"Couldn't find object {obj} in get-all list " \
                                                            f"{fetched_sample_model_list}"

            # updating values
            for obj in sample_model_objects_list:
                obj.sample = f"sample___{obj.id}"

            return_value = put_all_client(sample_model_objects_list,
                                                                  return_obj_copy=return_value_type)
            if return_value_type or return_value_type is None:
                assert isinstance(return_value, List), ("Mismatched: returned value from client must be list, "
                                                        f"received type: {type(return_value)}")
            else:
                assert (isinstance(return_value, bool) and return_value)

            updated_sample_model_list = get_all_client()

            for expected_obj in sample_model_objects_list:
                assert expected_obj in updated_sample_model_list, \
                    f"expected obj {expected_obj} not found in updated list of objects: {updated_sample_model_list}"


@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_put_all_msgspec_list_in_df_out_client(clean_and_set_limits, web_client):
    for msgspec_basemodel, get_all_client, create_all_client, get_all_df_client, put_all_model_list_in_df_out_client in \
            [(SampleModelBaseModel, web_client.get_all_sample_model_client,
              web_client.create_all_sample_model_client,
              web_client.get_all_sample_model_df_client,
              web_client.put_all_sample_model_model_list_in_df_out_client),
             (SampleTSModelBaseModel, web_client.get_all_sample_ts_model_client,
              web_client.create_all_sample_ts_model_client,
              web_client.get_all_sample_ts_model_df_client,
              web_client.put_all_sample_ts_model_model_list_in_df_out_client)]:
        for index, return_value_type in enumerate([True, None, False]):
            sample_model_objects_list = [
                msgspec_basemodel.from_kwargs(_id=1 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                                 date=get_utc_date_time(), num=1, cum_sum_of_num=1+index*3),
                msgspec_basemodel.from_kwargs(_id=2 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                                 date=get_utc_date_time(), num=1, cum_sum_of_num=2+index*3),
                msgspec_basemodel.from_kwargs(_id=3 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                                 date=get_utc_date_time(), num=1, cum_sum_of_num=3+index*3)
            ]

            create_all_client(sample_model_objects_list)
            fetched_sample_model_list = get_all_client()

            for obj in sample_model_objects_list:
                assert obj in fetched_sample_model_list, f"Couldn't find object {obj} in get-all list " \
                                                            f"{fetched_sample_model_list}"

            # updating values
            for obj in sample_model_objects_list:
                obj.sample = f"sample___{obj.id}"
            updated_sample_model_df = pl.DataFrame(generic_encoder(sample_model_objects_list, msgspec_basemodel.enc_hook,
                                                     by_alias=True, exclude_none=True))

            return_value = put_all_model_list_in_df_out_client(sample_model_objects_list,
                                                               return_obj_copy=return_value_type)
            if return_value_type or return_value_type is None:
                assert isinstance(return_value, pl.DataFrame), \
                    f"Expected return value to be a Polars DataFrame, but got {type(return_value)}"
            else:
                assert (isinstance(return_value, bool) and return_value)

            # Fetch the data again
            fetched_sample_df = get_all_df_client()
            assert isinstance(fetched_sample_df, pl.DataFrame), \
                f"Expected fetched data to be a Polars DataFrame, found {fetched_sample_df}"

            # Verify the updated data in the database
            merged_df = updated_sample_model_df.join(
                fetched_sample_df, on="_id", how="inner"
            )
            assert merged_df.height == updated_sample_model_df.height, \
                (f"Not all objects from updated_sample_model_df were found in fetched_sample_df. "
                 f"Mismatch: {updated_sample_model_df - merged_df}")


@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_put_all_df_in_msgspec_list_out_client(clean_and_set_limits, web_client):
    for msgspec_basemodel, get_all_client, create_all_df_client, get_all_df_client, put_all_df_in_model_list_out_client in \
            [(SampleModelBaseModel, web_client.get_all_sample_model_client,
              web_client.create_all_sample_model_df_in_df_out_client,
              web_client.get_all_sample_model_df_client,
              web_client.put_all_sample_model_df_in_model_list_out_client),
             (SampleTSModelBaseModel, web_client.get_all_sample_ts_model_client,
              web_client.create_all_sample_ts_model_df_in_df_out_client,
              web_client.get_all_sample_ts_model_df_client,
              web_client.put_all_sample_ts_model_df_in_model_list_out_client)]:
        for index, return_value_type in enumerate([True, None, False]):
            # Create initial data as a Polars DataFrame
            sample_data = [
                {"_id": 1 + (index * 3), "sample": f"sample{1 + (index * 3)}", "date": get_utc_date_time(),
                 "num": 1, "cum_sum_of_num": 1 + index * 3},
                {"_id": 2 + (index * 3), "sample": f"sample{2 + (index * 3)}", "date": get_utc_date_time(),
                 "num": 1, "cum_sum_of_num": 2 + index * 3},
                {"_id": 3 + (index * 3), "sample": f"sample{3 + (index * 3)}", "date": get_utc_date_time(),
                 "num": 1, "cum_sum_of_num": 3 + index * 3},
            ]
            sample_df = pl.DataFrame(sample_data)

            # Insert the initial data into the database
            create_all_df_client(sample_df)

            # Verify initial data in the database
            fetched_sample_df = get_all_df_client()
            assert isinstance(fetched_sample_df, pl.DataFrame), "Expected fetched data to be a Polars DataFrame"
            ids_in_db = fetched_sample_df["_id"].to_list()
            for row in sample_data:
                assert row["_id"] in ids_in_db, f"Object with ID {row['_id']} not found in initial database"

            # Update the data
            for row in sample_data:
                row["sample"] = f"sample_updated_{row['_id']}"
            updated_sample_df = pl.DataFrame(sample_data)
            sample_model_objects_list = msgspec_basemodel.from_dict_list(updated_sample_df.to_dicts())

            # Perform the update operation
            return_value = put_all_df_in_model_list_out_client(updated_sample_df, return_obj_copy=return_value_type)
            if return_value_type or return_value_type is None:
                assert isinstance(return_value, List), ("Mismatched: returned value from client must be list, "
                                                        f"received type: {type(return_value)}")
            else:
                assert (isinstance(return_value, bool) and return_value)

            updated_sample_model_list = get_all_client()

            for expected_obj in sample_model_objects_list:
                assert expected_obj in updated_sample_model_list, \
                    f"expected obj {expected_obj} not found in updated list of objects: {updated_sample_model_list}"


@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_put_all_df_in_df_out_client(clean_and_set_limits, web_client):
    for create_all_df_client, get_all_df_client, put_all_df_in_df_client in \
            [(web_client.create_all_sample_model_df_in_df_out_client,
              web_client.get_all_sample_model_df_client,
              web_client.put_all_sample_model_df_in_df_out_client),
             (web_client.create_all_sample_ts_model_df_in_df_out_client,
              web_client.get_all_sample_ts_model_df_client,
              web_client.put_all_sample_ts_model_df_in_df_out_client)]:
        for index, return_value_type in enumerate([True, None, False]):
            # Create initial data as a Polars DataFrame
            sample_data = [
                {"_id": 1 + (index * 3), "sample": f"sample{1 + (index * 3)}", "date": get_utc_date_time(),
                 "num": 1, "cum_sum_of_num": 1 + index * 3},
                {"_id": 2 + (index * 3), "sample": f"sample{2 + (index * 3)}", "date": get_utc_date_time(),
                 "num": 1, "cum_sum_of_num": 2 + index * 3},
                {"_id": 3 + (index * 3), "sample": f"sample{3 + (index * 3)}", "date": get_utc_date_time(),
                 "num": 1, "cum_sum_of_num": 3 + index * 3},
            ]
            sample_df = pl.DataFrame(sample_data)
    
            # Insert the initial data into the database
            create_all_df_client(sample_df)
    
            # Verify initial data in the database
            fetched_sample_df = get_all_df_client()
            assert isinstance(fetched_sample_df, pl.DataFrame), "Expected fetched data to be a Polars DataFrame"
            ids_in_db = fetched_sample_df["_id"].to_list()
            for row in sample_data:
                assert row["_id"] in ids_in_db, f"Object with ID {row['_id']} not found in initial database"
    
            # Update the data
            for row in sample_data:
                row["sample"] = f"sample_updated_{row['_id']}"
            updated_sample_df = pl.DataFrame(sample_data)
    
            # Perform the update operation
            return_value = put_all_df_in_df_client(updated_sample_df, return_obj_copy=return_value_type)
            if return_value_type or return_value_type is None:
                assert isinstance(return_value, pl.DataFrame), \
                    f"Expected return value to be a Polars DataFrame, but got {type(return_value)}"
            else:
                assert (isinstance(return_value, bool) and return_value)
    
            # Fetch the data again
            fetched_sample_df = get_all_df_client()
            assert isinstance(fetched_sample_df, pl.DataFrame), \
                f"Expected fetched data to be a Polars DataFrame, found {fetched_sample_df}"
    
            # Verify the updated data in the database
            merged_df = updated_sample_df.join(
                fetched_sample_df, on="_id", how="inner"
            )
            assert merged_df.height == updated_sample_df.height, \
                f"Not all objects from updated_sample_df were found in fetched_sample_df. Mismatch: {updated_sample_df - merged_df}"


@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_patch_all(clean_and_set_limits, web_client):
    for msgspec_basemodel, get_all_client, create_all_client, patch_all_client in \
            [(SampleModelBaseModel, web_client.get_all_sample_model_client,
              web_client.create_all_sample_model_client,
              web_client.patch_all_sample_model_client),
             (SampleTSModelBaseModel, web_client.get_all_sample_ts_model_client,
              web_client.create_all_sample_ts_model_client,
              web_client.patch_all_sample_ts_model_client)]:
        for index, return_value_type in enumerate([True, None, False]):
            formatted_dt_utc = pendulum.DateTime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            sample_model_objects_list = [
                msgspec_basemodel.from_kwargs(_id=1 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                              date=get_utc_date_time(), num=1, cum_sum_of_num=1 + index * 3),
                msgspec_basemodel.from_kwargs(_id=2 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                              date=get_utc_date_time(), num=1, cum_sum_of_num=2 + index * 3),
                msgspec_basemodel.from_kwargs(_id=3 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                              date=get_utc_date_time(), num=1, cum_sum_of_num=3 + index * 3)
            ]

            create_all_client(sample_model_objects_list)

            fetched_email_book_beanie = get_all_client()

            for obj in sample_model_objects_list:
                assert obj in fetched_email_book_beanie, f"Couldn't find object {obj} in get-all list " \
                                                            f"{fetched_email_book_beanie}"
            # updating values
            for obj in sample_model_objects_list:
                obj.sample = f"sample_{obj.id}"
                formatted_dt_utc = pendulum.DateTime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                obj.date = pendulum.parse(formatted_dt_utc)

            sample_ts_model_objects_json_list = [obj.to_dict(exclude_none=True)
                                                 for obj in sample_model_objects_list]
            return_value = patch_all_client(sample_ts_model_objects_json_list, return_obj_copy=return_value_type)
            if return_value_type:
                assert isinstance(return_value, List), ("Mismatched: returned value from client must be list, "
                                                        f"received type: {type(return_value)}")
            else:
                assert return_value

            updated_sample_ts_model_list = get_all_client()

            for expected_obj in sample_model_objects_list:
                assert expected_obj in updated_sample_ts_model_list, \
                    f"expected obj {expected_obj} not found in updated list of objects: {updated_sample_ts_model_list}"


@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_patch_all_json_list_in_df_out_client(clean_and_set_limits, web_client):
    for msgspec_basemodel, get_all_client, create_all_client, patch_all_json_list_in_df_out_client in \
            [(SampleModelBaseModel, web_client.get_all_sample_model_client,
              web_client.create_all_sample_model_client,
              web_client.patch_all_sample_model_json_list_in_df_out_client),
             (SampleTSModelBaseModel, web_client.get_all_sample_ts_model_client,
              web_client.create_all_sample_ts_model_client,
              web_client.patch_all_sample_ts_model_json_list_in_df_out_client)]:
        for index, return_value_type in enumerate([True, None, False]):
            formatted_dt_utc = pendulum.DateTime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            sample_model_objects_list = [
                msgspec_basemodel.from_kwargs(_id=1 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                              date=get_utc_date_time(), num=1, cum_sum_of_num=1 + index * 3),
                msgspec_basemodel.from_kwargs(_id=2 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                              date=get_utc_date_time(), num=1, cum_sum_of_num=2 + index * 3),
                msgspec_basemodel.from_kwargs(_id=3 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                              date=get_utc_date_time(), num=1, cum_sum_of_num=3 + index * 3)
            ]

            create_all_client(sample_model_objects_list)

            fetched_email_book_beanie = get_all_client()

            for obj in sample_model_objects_list:
                assert obj in fetched_email_book_beanie, f"Couldn't find object {obj} in get-all list " \
                                                            f"{fetched_email_book_beanie}"
            # updating values
            for obj in sample_model_objects_list:
                obj.sample = f"sample_{obj.id}"
                formatted_dt_utc = pendulum.DateTime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                obj.date = pendulum.parse(formatted_dt_utc)

            sample_ts_model_objects_json_list = generic_encoder(sample_model_objects_list, msgspec_basemodel.enc_hook,
                                                                by_alias=True, exclude_none=True)
            return_value = patch_all_json_list_in_df_out_client(sample_ts_model_objects_json_list, return_obj_copy=return_value_type)
            if return_value_type or return_value_type is None:
                assert isinstance(return_value, pl.DataFrame), \
                    f"Expected return value to be a Polars DataFrame, but got {type(return_value)}"
            else:
                assert (isinstance(return_value, bool) and return_value)

            updated_sample_ts_model_list = get_all_client()

            for expected_obj in sample_model_objects_list:
                assert expected_obj in updated_sample_ts_model_list, \
                    f"expected obj {expected_obj} not found in updated list of objects: {updated_sample_ts_model_list}"


@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_patch_all_df_in_df_out_client(clean_and_set_limits, web_client):
    for msgspec_basemodel, get_all_client, create_all_client, patch_all_df_in_df_out_client in \
            [(SampleModelBaseModel, web_client.get_all_sample_model_client,
              web_client.create_all_sample_model_client,
              web_client.patch_all_sample_model_df_in_df_out_client),
             (SampleTSModelBaseModel, web_client.get_all_sample_ts_model_client,
              web_client.create_all_sample_ts_model_client,
              web_client.patch_all_sample_ts_model_df_in_df_out_client)]:
        for index, return_value_type in enumerate([True, None, False]):
            formatted_dt_utc = pendulum.DateTime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            sample_model_objects_list = [
                msgspec_basemodel.from_kwargs(_id=1 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                              date=get_utc_date_time(), num=1, cum_sum_of_num=1 + index * 3),
                msgspec_basemodel.from_kwargs(_id=2 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                              date=get_utc_date_time(), num=1, cum_sum_of_num=2 + index * 3),
                msgspec_basemodel.from_kwargs(_id=3 + (index * 3), sample=f"sample{1 + (index * 3)}",
                                              date=get_utc_date_time(), num=1, cum_sum_of_num=3 + index * 3)
            ]

            create_all_client(sample_model_objects_list)

            fetched_email_book_beanie = get_all_client()

            for obj in sample_model_objects_list:
                assert obj in fetched_email_book_beanie, f"Couldn't find object {obj} in get-all list " \
                                                            f"{fetched_email_book_beanie}"
            # updating values
            for obj in sample_model_objects_list:
                obj.sample = f"sample_{obj.id}"
                formatted_dt_utc = pendulum.DateTime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
                obj.date = pendulum.parse(formatted_dt_utc)

            update_json_list = [obj.to_dict(exclude_none=True) for obj in sample_model_objects_list]
            update_model_df = pl.DataFrame(update_json_list)

            return_value = patch_all_df_in_df_out_client(update_model_df,
                                                         return_obj_copy=return_value_type)
            if return_value_type or return_value_type is None:
                assert isinstance(return_value, pl.DataFrame), \
                    f"Expected return value to be a Polars DataFrame, but got {type(return_value)}"
            else:
                assert (isinstance(return_value, bool) and return_value)

            updated_sample_ts_model_list = get_all_client()

            for expected_obj in sample_model_objects_list:
                assert expected_obj in updated_sample_ts_model_list, \
                    f"expected obj {expected_obj} not found in updated list of objects: {updated_sample_ts_model_list}"



@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_patch_all_repeated_field_handling(clean_and_set_limits, web_client):
    for index, return_value_type in enumerate([True, None, False]):
        contact_limits_objects_list = [
            ContactLimitsBaseModel.from_kwargs(_id=2 + (index * 3), max_open_baskets=20),
            ContactLimitsBaseModel.from_kwargs(_id=3 + (index * 3), max_open_baskets=30),
            ContactLimitsBaseModel.from_kwargs(_id=4 + (index * 3), max_open_baskets=45)
        ]

        web_client.create_all_contact_limits_client(contact_limits_objects_list)

        fetched_get_all_obj_list = web_client.get_all_contact_limits_client()

        for obj in contact_limits_objects_list:
            assert obj in fetched_get_all_obj_list, f"Couldn't find object {obj} in get-all list " \
                                                    f"{fetched_get_all_obj_list}"

        # updating values
        contact_limits_objects_json_list = []
        for obj in contact_limits_objects_list:
            obj.eligible_brokers = []
            for broker_obj_id in [1, 2]:
                broker = broker_fixture()
                broker.id = f"{broker_obj_id}"
                broker.bkr_priority = broker_obj_id
                obj.eligible_brokers.append(broker)
            contact_limits_objects_json_list.append(obj.to_dict(exclude_none=True))

        return_value = web_client.patch_all_contact_limits_client(contact_limits_objects_json_list,
                                                                    return_obj_copy=return_value_type)
        if return_value_type:
            assert isinstance(return_value, List), ("Mismatched: returned value from client must be list, "
                                                    f"received type: {type(return_value)}")
        else:
            assert return_value

        for expected_obj in contact_limits_objects_list:
            updated_contact_limits = web_client.get_contact_limits_client(contact_limits_id=expected_obj.id)
            assert expected_obj.to_dict() == updated_contact_limits.to_dict(), \
                f"Mismatched: expected obj {expected_obj} received {updated_contact_limits}"

        delete_broker = BrokerBaseModel()
        delete_broker.id = "1"

        delete_obj = ContactLimitsBaseModel.from_kwargs(_id=4 + (index * 3), eligible_brokers=[delete_broker])
        delete_obj_json = delete_obj.to_dict(exclude_none=True)

        web_client.patch_all_contact_limits_client([delete_obj_json])

        updated_contact_limits = web_client.get_contact_limits_client(contact_limits_id=4)

        assert delete_broker.id not in [broker.id for broker in updated_contact_limits.eligible_brokers], \
            f"Deleted obj: {delete_obj} using patch still found in updated object: {updated_contact_limits}"



@pytest.mark.nightly
@pytest.mark.parametrize("web_client", clients_list)
def test_delete_by_id_list(clean_and_set_limits, web_client):
    for msgspec_basemodel, create_all_client, delete_by_id_client, delete_all_client in \
            [(SampleModelBaseModel,
              web_client.create_all_sample_model_client,
              web_client.delete_by_id_list_sample_model_client,
              web_client.delete_all_sample_model_client),
             (SampleTSModelBaseModel,
              web_client.create_all_sample_ts_model_client,
              web_client.delete_by_id_list_sample_ts_model_client,
              web_client.delete_all_sample_ts_model_client)]:
        for index, return_value_type in enumerate([True, None, False]):
            sample_model_obj_list = []
            for i in range(5):
                sample_model_obj_list.append(msgspec_basemodel.from_kwargs(_id=i + 1, sample="sample1",
                                             date=get_utc_date_time(), num=1, cum_sum_of_num=1+index*3))
            create_all_client(sample_model_obj_list,
                                                      return_obj_copy=return_value_type)

            # id=6 doesn't exist - trying to see if client call ignores this id and logs it while deleting others
            existing_ids_list = [2, 3, 4]
            id_list_to_be_deleted = existing_ids_list + [6]
            delete_web_response = delete_by_id_client(id_list_to_be_deleted)
            if return_value_type is not None or return_value_type:
                assert delete_web_response["id"] == existing_ids_list, \
                    (f"Mismatched id list in delete_web_response, expected {existing_ids_list}, "
                     f"found {delete_web_response["id"]}")
            else:
                assert delete_web_response, \
                    f"Mismatch when return_value param to clinet was False, expected True received {delete_web_response}"

            # cleaning existing objs for next loop
            delete_all_client()



# todo: currently contains beanie http call of sample models, once cache http is implemented test that too
@pytest.mark.nightly
@pytest.mark.parametrize("basemodel_type", [SampleModelBaseModel, SampleTSModel1BaseModel])
# checking both JsonRoot and TimeSeries
def test_update_agg_feature_in_post_put_patch_http_call(static_data_, clean_and_set_limits,
                                                        basemodel_type: Type[SampleModelBaseModel |
                                                                                 SampleTSModel1BaseModel]):
    """
    This test case contains check of update aggregate feature available in beanie part, put and patch http calls.
    """
    counter = 0
    for index in range(5):
        sample_model = basemodel_type.from_kwargs(_id=index+1, sample="sample", date=DateTime.utcnow(), num=index+1)
        created_obj: basemodel_type = (
            email_book_service_native_web_client.create_sample_model_client(sample_model))

        counter += index+1
        assert created_obj.cum_sum_of_num == counter, \
            (f"Mismatched: aggregated update must have updated created_obj.cum_sum_of_num: {created_obj.cum_sum_of_num} "
             f"to {counter} after post operation")

        if index > 0:
            last_obj = email_book_service_native_web_client.get_sample_model_client(index)
            last_obj.num += 1
            counter += 1    # updating counter for comparison

            last_index_updated_obj = email_book_service_native_web_client.put_sample_model_client(last_obj)
            assert last_index_updated_obj.cum_sum_of_num == last_obj.cum_sum_of_num+1, \
                (f"Mismatched: aggregated update must have updated created_obj.cum_sum_of_num: "
                 f"{last_index_updated_obj.cum_sum_of_num} to {last_obj.cum_sum_of_num+1} after put operation")

            current_index_updated_obj = email_book_service_native_web_client.get_sample_model_client(index+1)
            assert current_index_updated_obj.cum_sum_of_num == counter, \
                (f"Mismatched: aggregated update must have updated cum_sum_of_num: "
                 f"{current_index_updated_obj.cum_sum_of_num} to {counter} after put operation")


def test_verify_stored_n_update_obj_are_diff_in_post_callback_in_patch_http(static_data_, clean_and_set_limits):
    sample_model = SampleModelBaseModel.from_kwargs(sample="sample", date=DateTime.utcnow(), num=1)
    created_sample_model = email_book_service_native_web_client.create_sample_model_client(sample_model)

    try:
        created_sample_model.sample = "update_text"
        updated_sample_model = email_book_service_native_web_client.patch_sample_model_client(
            created_sample_model.to_json_dict())
        assert updated_sample_model == created_sample_model, \
            f"Mismatched: expected: {created_sample_model}, updated: {updated_sample_model}"
    except Exception as e:
        if "Found stored_sample_model_obj_json == updated_sample_model_obj_json" in str(e):
            assert False, ("Unexpected: Found stored obj and updated equal in post callback after generic call "
                           "in patch of SampleModel - must not be equal")
        else:
            raise e


def test_verify_stored_n_update_obj_are_diff_in_post_callback_in_patch_all_http(static_data_, clean_and_set_limits):
    sample_model = SampleModelBaseModel.from_kwargs(sample="sample", date=DateTime.utcnow(), num=1)
    created_obj_list = []
    for i in range(5):
        created_sample_model = email_book_service_native_web_client.create_sample_model_client(sample_model)
        created_obj_list.append(created_sample_model)

    try:
        for created_obj in created_obj_list:
            created_obj.sample = f"update_text_{created_obj.id}"

        updated_sample_model_list = email_book_service_native_web_client.patch_all_sample_model_client(
            [obj.to_json_dict() for obj in created_obj_list])
        assert updated_sample_model_list == created_obj_list, \
            f"Mismatched: expected: {created_obj_list}, updated: {updated_sample_model_list}"
    except Exception as e:
        if "Found stored_sample_model_dict_list == updated_sample_model_dict_list" in str(e):
            assert False, ("Unexpected: Found stored obj list and updated obj list equal in post callback after "
                           "generic call in patch all of SampleModel - must not be equal")
        else:
            raise e


def test_max_id_updates_if_db_create_obj_has_greater_id(static_data_, clean_and_set_limits):
    max_id = email_book_service_native_web_client.get_sample_model_max_id_client()
    max_id_val = max_id.max_id_val

    # creating obj with id bigger than current max_id_val
    new_max_id = max_id_val + 5
    sample_model = SampleModelBaseModel.from_kwargs(_id=new_max_id, sample="sample", date=DateTime.utcnow(), num=1)
    email_book_service_native_web_client.create_sample_model_client(sample_model)
    check_max_id = email_book_service_native_web_client.get_sample_model_max_id_client()
    assert check_max_id.max_id_val == new_max_id, \
        f"Mismatch: max_id must be updated to {new_max_id} but found {check_max_id.max_id_val}"

    # checking same for create-all case
    new_max_id += 5
    sample_model = SampleModelBaseModel.from_kwargs(_id=new_max_id, sample="sample", date=DateTime.utcnow(), num=1)
    email_book_service_native_web_client.create_all_sample_model_client([sample_model])
    check_max_id = email_book_service_native_web_client.get_sample_model_max_id_client()
    assert check_max_id.max_id_val == new_max_id, \
        f"Mismatch: max_id must be updated to {new_max_id} but found {check_max_id.max_id_val}"


@pytest.mark.nightly
def test_file_upload_n_save_query():
    """test to verify query to upload and save file"""
    test_file_path = PurePath(__file__).parent.parent / "data" / "sample.txt"
    destination_file_path = PurePath(__file__).parent / "check.txt"
    try:
        if os.path.exists(destination_file_path):   # removing file if exists pre check
            os.remove(destination_file_path)

        # saving file at destination from test_file_path
        email_book_service_native_web_client.sample_file_upload_query_client(test_file_path,
                                                                                str(destination_file_path))
        # verifying file exists at destination
        assert os.path.exists(destination_file_path), \
            f"Unexpected: file must have been created by file query at {destination_file_path}"
    except Exception as e:
        raise e
    finally:
        if os.path.exists(destination_file_path):
            os.remove(destination_file_path)


@pytest.mark.nightly
def test_sample_model_file_upload_query():
    """test to verify file upload query on json model, SampleModel for this test"""
    test_file_path = PurePath(__file__).parent.parent / "data" / "sample.txt"
    destination_file_path = PAIR_STRAT_ENGINE_DIR / "generated" / "sample_file.txt"
    try:
        if os.path.exists(destination_file_path):   # removing file if exists pre check
            os.remove(destination_file_path)

        # saving file at destination from test_file_path
        email_book_service_native_web_client.sample_file_upload_button_query_client(test_file_path, "sample")
        # verifying file exists at destination
        assert os.path.exists(destination_file_path), \
            f"Unexpected: file must have been created by file query at {destination_file_path}"
    except Exception as e:
        raise e
    finally:
        if os.path.exists(destination_file_path):
            os.remove(destination_file_path)


@pytest.mark.nightly
def test_contact_limits_size_limit(static_data_, clean_and_set_limits, expected_contact_limits_):
    # tests update and get of obj >16 mb - mongodb only supports document in db to be <=16 mb - this test verifies
    # underlying impl of gridfs for this case to support objects with <16 mb
    positions: List[PositionBaseModel] = \
        [PositionBaseModel.from_kwargs(type=PositionType.SOD, priority=0,
                                       available_size=10_000, allocated_size=10_000,
                                       consumed_size=0,
                                       pos_disable=False, premium_percentage=2)]*10
    sec_position: SecPositionBaseModel = (
        SecPositionBaseModel.from_kwargs(
            security=SecurityBaseModel.from_kwargs(sec_id="Type1_Sec_1", sec_id_source=SecurityIdSource.SEDOL)))
    sec_position.positions = positions

    sec_positions = [sec_position]*1000
    broker: BrokerBaseModel = BrokerBaseModel.from_kwargs(broker="ZERODHA", bkr_priority=10,
                                                          bkr_disable=False, sec_positions=sec_positions)
    brokers = [broker]*10
    for idx, broker_ in enumerate(brokers):
        broker_.broker = f"broker_{idx}"
    expected_contact_limits_.eligible_brokers = brokers
    contact_limits_ = email_book_service_native_web_client.put_contact_limits_client(expected_contact_limits_)

    contact_limits_ = (
        email_book_service_native_web_client.get_contact_limits_client(expected_contact_limits_.id))
    assert contact_limits_.id == expected_contact_limits_.id, \
        f"Mismatched: {expected_contact_limits_=}, {contact_limits_=}"
    assert len(contact_limits_.eligible_brokers) == len(expected_contact_limits_.eligible_brokers), \
        f"Mismatched: {len(contact_limits_.eligible_brokers)=}, {len(expected_contact_limits_.eligible_brokers)=}"
    assert len(contact_limits_.eligible_brokers[0].sec_positions) == len(expected_contact_limits_.eligible_brokers[0].sec_positions), \
        f"Mismatched: {len(contact_limits_.eligible_brokers[0].sec_positions)=}, {len(expected_contact_limits_.eligible_brokers[0].sec_positions)=}"
    assert len(contact_limits_.eligible_brokers[0].sec_positions[0].positions) == len(expected_contact_limits_.eligible_brokers[0].sec_positions[0].positions), \
        f"Mismatched: {len(contact_limits_.eligible_brokers[0].sec_positions[0].positions)=}, {len(expected_contact_limits_.eligible_brokers[0].sec_positions[0].positions)=}"


@pytest.mark.nightly
def test_shallow_brokers_with_contact_limit_updates(
        static_data_, clean_and_set_limits, expected_contact_limits_, leg1_leg2_symbol_list):
    # deleting contact_limits obj and shadow_brokers
    email_book_service_native_web_client.delete_contact_limits_client(1)
    shadow_brokers = email_book_service_native_web_client.get_all_shadow_brokers_client()
    for shadow_broker in shadow_brokers:
        email_book_service_native_web_client.delete_shadow_brokers_client(shadow_broker.id)

    sec_positions_list = expected_contact_limits_.eligible_brokers[0].sec_positions
    for broker in expected_contact_limits_.eligible_brokers:
        broker.sec_positions = sec_positions_list[:4]

    # creating contact_limits obj
    created_contact_limit = email_book_service_native_web_client.create_contact_limits_client(expected_contact_limits_)
    assert created_contact_limit.eligible_brokers, \
        f"Mismatch: Can't find eligible_brokers after contact_limit create, {created_contact_limit=} "
    for eligible_broker in created_contact_limit.eligible_brokers:
        assert eligible_broker.id is not None, \
            f"Mismatch: Can't find id in created {eligible_broker=}, {created_contact_limit=}"
        for sec_pos in eligible_broker.sec_positions:
            assert sec_pos.id is not None, \
                f"Mismatch: Can't find id in created {sec_pos=}, {created_contact_limit=}"
            for position in sec_pos.positions:
                assert position.id is not None, \
                    f"Mismatch: Can't find id in created {position=}, {created_contact_limit=}"

    security_id1 = leg1_leg2_symbol_list[0][0]
    security_id2 = leg1_leg2_symbol_list[0][1]
    filtered_brokers = (
        email_book_service_native_web_client.get_dismiss_filter_contact_limit_brokers_query_client(security_id1, security_id2))
    for filtered_broker in filtered_brokers:
        assert len(filtered_broker.sec_positions) == 2, \
            f"Mismatched: expected length of sec_positions: 2, received: {len(filtered_broker.sec_positions)=}"

    # updating positions using put
    created_contact_limit.eligible_brokers[0].sec_positions[0].positions[0].pos_disable = True
    put_contact_limit = email_book_service_native_web_client.put_contact_limits_client(
        created_contact_limit)
    assert put_contact_limit.eligible_brokers, \
        f"Mismatch: Can't find eligible_brokers after contact_limit create, {put_contact_limit=} "
    for eligible_broker in put_contact_limit.eligible_brokers:
        assert eligible_broker.id is not None, \
            f"Mismatch: Can't find id in created {eligible_broker=}, {put_contact_limit=}"
        for sec_pos in eligible_broker.sec_positions:
            assert sec_pos.id is not None, \
                f"Mismatch: Can't find id in created {sec_pos=}, {put_contact_limit=}"
            for position in sec_pos.positions:
                assert position.id is not None, \
                    f"Mismatch: Can't find id in created {position=}, {put_contact_limit=}"
    # checking first 2 sec_positions
    security_id1 = leg1_leg2_symbol_list[0][0]
    security_id2 = leg1_leg2_symbol_list[0][1]
    filtered_brokers = (
        email_book_service_native_web_client.get_dismiss_filter_contact_limit_brokers_query_client(security_id1, security_id2))
    assert len(filtered_brokers[0].sec_positions) == 2, \
        f"Mismatched: expected length of sec_positions: 2, received: {len(filtered_brokers[0].sec_positions)=}"
    assert filtered_brokers[0].sec_positions[0].positions[0].pos_disable, \
        "Mismatched: expected pos_disable to be True found False"

    # updating positions using patch
    patch_dict = {"_id": 1,
                  "eligible_brokers": [
                      {"_id": created_contact_limit.eligible_brokers[0].id,
                       "sec_positions": [
                           {"_id": created_contact_limit.eligible_brokers[0].sec_positions[3].id,
                            "positions": [{"_id": created_contact_limit.eligible_brokers[0].sec_positions[3].positions[0].id,
                                           "pos_disable": True}]}]}]}
    patched_contact_limit = email_book_service_native_web_client.patch_contact_limits_client(patch_dict)
    assert patched_contact_limit.eligible_brokers, \
        f"Mismatch: Can't find eligible_brokers after contact_limit create, {patched_contact_limit=} "
    for eligible_broker in patched_contact_limit.eligible_brokers:
        assert eligible_broker.id is not None, \
            f"Mismatch: Can't find id in created {eligible_broker=}, {patched_contact_limit=}"
        for sec_pos in eligible_broker.sec_positions:
            assert sec_pos.id is not None, \
                f"Mismatch: Can't find id in created {sec_pos=}, {patched_contact_limit=}"
            for position in sec_pos.positions:
                assert position.id is not None, \
                    f"Mismatch: Can't find id in created {position=}, {patched_contact_limit=}"
    # checking other 2 sec_positions
    security_id1 = leg1_leg2_symbol_list[1][0]
    security_id2 = leg1_leg2_symbol_list[1][1]
    filtered_brokers = (
        email_book_service_native_web_client.get_dismiss_filter_contact_limit_brokers_query_client(security_id1,
                                                                                                        security_id2))
    assert len(filtered_brokers[0].sec_positions) == 2, \
        f"Mismatched: expected length of sec_positions: 2, received: {len(filtered_brokers[0].sec_positions)=}"
    assert filtered_brokers[0].sec_positions[1].positions[0].pos_disable, \
        "Mismatched: expected pos_disable to be True found False"

    # creating sec_positions using put
    patched_contact_limit.eligible_brokers[0].sec_positions.extend(sec_positions_list[4:6])
    put_contact_limit = email_book_service_native_web_client.put_contact_limits_client(
        patched_contact_limit)
    assert put_contact_limit.eligible_brokers, \
        f"Mismatch: Can't find eligible_brokers after contact_limit create, {put_contact_limit=} "
    for eligible_broker in put_contact_limit.eligible_brokers:
        assert eligible_broker.id is not None, \
            f"Mismatch: Can't find id in created {eligible_broker=}, {put_contact_limit=}"
        for sec_pos in eligible_broker.sec_positions:
            assert sec_pos.id is not None, \
                f"Mismatch: Can't find id in created {sec_pos=}, {put_contact_limit=}"
            for position in sec_pos.positions:
                assert position.id is not None, \
                    f"Mismatch: Can't find id in created {position=}, {put_contact_limit=}"
    # checking new sec_positions
    security_id1 = leg1_leg2_symbol_list[2][0]
    security_id2 = leg1_leg2_symbol_list[2][1]
    filtered_brokers = (
        email_book_service_native_web_client.get_dismiss_filter_contact_limit_brokers_query_client(security_id1,
                                                                                                        security_id2))
    assert len(filtered_brokers[0].sec_positions) == 2, \
        f"Mismatched: expected length of sec_positions: 2, received: {len(filtered_brokers[0].sec_positions)=}"

    # creating sec_positions using patch
    patch_dict = {"_id": 1,
                  "eligible_brokers": [
                      {"_id": put_contact_limit.eligible_brokers[0].id,
                       "sec_positions": [
                          sec_positions_list[6].to_dict(exclude_none=True),
                          sec_positions_list[7].to_dict(exclude_none=True)
                       ]}
                  ]}
    patched_contact_limit = email_book_service_native_web_client.patch_contact_limits_client(patch_dict)
    assert patched_contact_limit.eligible_brokers, \
        f"Mismatch: Can't find eligible_brokers after contact_limit create, {patched_contact_limit=} "
    for eligible_broker in patched_contact_limit.eligible_brokers:
        assert eligible_broker.id is not None, \
            f"Mismatch: Can't find id in created {eligible_broker=}, {patched_contact_limit=}"
        for sec_pos in eligible_broker.sec_positions:
            assert sec_pos.id is not None, \
                f"Mismatch: Can't find id in created {sec_pos=}, {patched_contact_limit=}"
            for position in sec_pos.positions:
                assert position.id is not None, \
                    f"Mismatch: Can't find id in created {position=}, {patched_contact_limit=}"
    # checking other 2 sec_positions
    security_id1 = leg1_leg2_symbol_list[3][0]
    security_id2 = leg1_leg2_symbol_list[3][1]
    filtered_brokers = (
        email_book_service_native_web_client.get_dismiss_filter_contact_limit_brokers_query_client(security_id1,
                                                                                                        security_id2))
    assert len(filtered_brokers[0].sec_positions) == 2, \
        f"Mismatched: expected length of sec_positions: 2, received: {len(filtered_brokers[0].sec_positions)=}"

# sanity test to create and activate pair_plan
@pytest.mark.nightly
def test_create_pair_plan(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                           expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
                           market_depth_basemodel_list):
    # creates and activates multiple pair_plans
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:1]
    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        create_n_activate_plan(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                expected_plan_status_, symbol_overview_obj_list,
                                market_depth_basemodel_list)


def test_place_chores_with_manual_executor_port(
        leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        market_depth_basemodel_list, last_barter_fixture_list, refresh_sec_update_fixture):
    buy_symbol, sell_symbol = leg1_leg2_symbol_list[0]
    max_loop_count_per_side = 1
    expected_plan_limits_.max_open_chores_per_side = 10
    expected_plan_limits_.residual_restriction.max_residual = 111360
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    port = 0    # <<<<<< manually replace this with running executor port to place chores
    cpp_port = 0    # <<<<<< manually replace this with running cpp port to place chores
    executor_web_client = StreetBookServiceHttpClient(host='127.0.0.1', port=port)
    create_market_depth(buy_symbol, sell_symbol, market_depth_basemodel_list, cpp_port)
    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(plan_id=1)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        executor_web_client.barter_simulator_reload_config_query_client()

        total_chore_count_for_each_side = max_loop_count_per_side

        # Placing buy chores
        buy_ack_chore_id = None
        for loop_count in range(total_chore_count_for_each_side):
            run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, cpp_port)

            time.sleep(1)
            # update_tob_through_market_depth_to_place_buy_chore(active_pair_plan.cpp_port, bid_buy_top_market_depth,
            #                                                    ask_sell_top_market_depth)
            place_new_chore(buy_symbol, Side.BUY, 98, 95, executor_web_client, InstrumentType.CB)
            ack_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK,
                                                                               buy_symbol, executor_web_client,
                                                                               last_chore_id=buy_ack_chore_id)
            buy_ack_chore_id = ack_chore_journal.chore.chore_id

            if not executor_config_yaml_dict.get("allow_multiple_open_chores_per_plan"):
                # Sleeping to let the chore get cxlled
                time.sleep(residual_wait_sec)

        # Placing sell chores
        sell_ack_chore_id = None
        for loop_count in range(total_chore_count_for_each_side):
            run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, cpp_port)
            # required to make buy side tob latest
            run_last_barter(buy_symbol, sell_symbol, [last_barter_fixture_list[0]], cpp_port)

            # update_tob_through_market_depth_to_place_sell_chore(active_pair_plan.cpp_port, ask_sell_top_market_depth,
            #                                                     bid_buy_top_market_depth)
            place_new_chore(sell_symbol, Side.SELL, 98, 95, executor_web_client, InstrumentType.EQT)

            ack_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK,
                                                                               sell_symbol, executor_web_client,
                                                                               last_chore_id=sell_ack_chore_id)
            sell_ack_chore_id = ack_chore_journal.chore.chore_id

            if not executor_config_yaml_dict.get("allow_multiple_open_chores_per_plan"):
                # Sleeping to let the chore get cxlled
                time.sleep(residual_wait_sec)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        print(f"Some Error Occurred: exception: {e}, "
              f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        raise Exception(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))



# sanity test to create chores
@pytest.mark.nightly
def test_place_sanity_chores(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                             expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
                             last_barter_fixture_list, market_depth_basemodel_list,
                             buy_chore_, sell_chore_,
                             max_loop_count_per_side, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]

    place_sanity_chores(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_, expected_plan_status_,
                        symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
                        max_loop_count_per_side, refresh_sec_update_fixture)


def test_place_sanity_parallel_chores(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                                      expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
                                      last_barter_fixture_list, market_depth_basemodel_list,
                                      buy_chore_, sell_chore_,
                                      max_loop_count_per_side, refresh_sec_update_fixture):
    with concurrent.futures.ThreadPoolExecutor(max_workers=len(leg1_leg2_symbol_list)) as executor:
        results = [executor.submit(place_sanity_chores, leg1_symbol, leg2_symbol, copy.deepcopy(pair_plan_),
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(market_depth_basemodel_list),
                                   max_loop_count_per_side,
                                   refresh_sec_update_fixture)
                   for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())


# async def _submit_task_for_place_sanity_complete_buy_sell_pair_chores_with_pair_plan(
#         leg1_leg2_symbol_list, pair_plan_list, expected_plan_limits_, expected_plan_status_,
#         symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list, max_loop_count_per_side,
#         refresh_sec_update_fixture):
#
#     tasks = []
#     for idx, leg1_leg2_symbol in leg1_leg2_symbol_list:
#         task = asyncio.create_task(_place_sanity_complete_buy_sell_pair_chores_with_pair_plan(
#             leg1_leg2_symbol[0], leg1_leg2_symbol[1], pair_plan_list[idx],
#             copy.deepcopy(expected_plan_limits_), copy.deepcopy(expected_plan_status_),
#             copy.deepcopy(symbol_overview_obj_list),
#             copy.deepcopy(last_barter_fixture_list), copy.deepcopy(market_depth_basemodel_list),
#             max_loop_count_per_side, refresh_sec_update_fixture
#         ))
#         tasks.append(task)
#
#     completed_tasks: Set | None = None
#     pending_tasks: Set | None = None
#     while True:
#         try:
#             completed_tasks, pending_tasks = \
#                 await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED, timeout=60)
#         except Exception as e:
#             print(f"_place_sanity_complete_buy_sell_pair_chores_with_pair_plan "
#                               f"asyncio.wait failed with exception: {e}")
#         while completed_tasks:
#             completed_task = None
#             try:
#                 completed_task = completed_tasks.pop()
#                 completed_task.result()
#             except Exception as e:
#                 pair_plan_id = int(completed_task.get_name())
#                 print(f"_place_sanity_complete_buy_sell_pair_chores_with_pair_plan failed for "
#                                   f"pair_plan_id: {pair_plan_id}, exception: {e}")
#         if pending_tasks:
#             tasks = [*pending_tasks, ]
#         else:
#             break
#
#
# def _place_sanity_complete_buy_sell_pair_chores_with_pair_plan(
#         buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
#         last_barter_fixture_list, market_depth_basemodel_list, max_loop_count_per_side, refresh_sec_update_fixture):
#     expected_plan_limits_.max_open_chores_per_side = 10
#     expected_plan_limits_.residual_restriction.max_residual = 111360
#     expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
#     residual_wait_sec = 4 * refresh_sec_update_fixture
#
#     active_pair_plan, executor_web_client = move_snoozed_pair_plan_to_ready_n_then_active(
#         pair_plan_, market_depth_basemodel_list, symbol_overview_obj_list,
#         expected_plan_limits_, expected_plan_status_)
#
#     run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
#
#     config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(active_pair_plan.id)
#
#     try:
#         # updating yaml_configs according to this test
#         for symbol in config_dict["symbol_configs"]:
#             config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
#             config_dict["symbol_configs"][symbol]["fill_percent"] = 100
#         YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))
#
#         executor_web_client.barter_simulator_reload_config_query_client()
#
#         total_chore_count_for_each_side = max_loop_count_per_side
#
#         # Placing buy chores
#         buy_ack_chore_id = None
#         sell_ack_chore_id = None
#         for loop_count in range(total_chore_count_for_each_side):
#             run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port,
#                            create_counts_per_side=2)
#
#             buy_chore: NewChoreBaseModel = place_new_chore(buy_symbol, Side.BUY, 10, 90, executor_web_client)
#
#             # ack_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK,
#             #                                                                    buy_symbol, executor_web_client,
#             #                                                                    last_chore_id=buy_ack_chore_id)
#             # buy_ack_chore_id = ack_chore_journal.chore.chore_id
#             # fills_journal = get_latest_fill_journal_from_chore_id(buy_ack_chore_id, executor_web_client)
#             time.sleep(1)
#             sell_chore: NewChoreBaseModel = place_new_chore(sell_symbol, Side.SELL, 110, 7, executor_web_client)
#             sell_ack_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK,
#                                                                                sell_symbol, executor_web_client,
#                                                                                last_chore_id=sell_ack_chore_id)
#             plan_status: PlanStatusBaseModel = executor_web_client.get_plan_status_client(active_pair_plan.id)
#             plan_view: PlanViewBaseModel = email_book_service_native_web_client.get_plan_view_client(
#                 active_pair_plan.id)
#             sell_ack_chore_id = sell_ack_chore_journal.chore.chore_id
#             assert plan_status.balance_notional == plan_view.balance_notional, \
#                 f"Mismatched {plan_status.balance_notional = }, {plan_view.balance_notional = }"
#
#         return buy_symbol, sell_symbol, active_pair_plan, executor_web_client
#
#     except AssertionError as e:
#         raise AssertionError(e)
#     except Exception as e:
#         print(f"Some Error Occurred: exception: {e}, "
#               f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
#         raise Exception(e)
#     finally:
#         YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))
#
#
# @pytest.mark.nightly
# def test_place_sanity_parallel_buy_sell_pair_chores_to_check_plan_view(
#         static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
#         expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
#         last_barter_fixture_list, market_depth_basemodel_list,
#         buy_chore_, sell_chore_, expected_contact_limits_, refresh_sec_update_fixture):
#     # Updating contact limits
#     expected_contact_limits_.rolling_max_chore_count.max_rolling_tx_count = 51
#     expected_contact_limits_.max_open_baskets = 51
#     expected_contact_limits_.max_gross_n_open_notional = 5_000_000
#     email_book_service_native_web_client.put_contact_limits_client(expected_contact_limits_)
#
#     max_loop_count_per_side = 50
#     leg1_leg2_symbol_list = []
#     total_plans = 20
#     pair_plan_list = []
#     for i in range(1, total_plans + 1):
#         leg1_symbol = f"Type1_Sec_{i}"
#         leg2_symbol = f"Type2_Sec_{i}"
#         leg1_leg2_symbol_list.append((leg1_symbol, leg2_symbol))
#
#         stored_pair_plan_basemodel = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
#         pair_plan_list.append(stored_pair_plan_basemodel)
#         time.sleep(2)
#
#     asyncio_loop = asyncio.new_event_loop()
#     run_coro = _submit_task_for_place_sanity_complete_buy_sell_pair_chores_with_pair_plan(
#         leg1_leg2_symbol_list, pair_plan_list, expected_plan_limits_, expected_plan_status_,
#         symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list, max_loop_count_per_side,
#         refresh_sec_update_fixture)
#     future = asyncio.run_coroutine_threadsafe(run_coro, asyncio_loop)
#     # block for task to finish
#     try:
#         future.result()
#     except Exception as e:
#         logging.exception(f"test_place_sanity_parallel_buy_sell_pair_chores_to_check_plan_view "
#                           f"failed with exception: {e}")
#     px = 10
#     qty = 90
#     plans_count = len(leg1_leg2_symbol_list)
#     plan_view_list = email_book_service_native_web_client.get_all_plan_view_client()
#     expected_balance_notional = (expected_plan_limits_.max_single_leg_notional -
#                                  plans_count * max_loop_count_per_side * qty * get_px_in_usd(px))
#     for plan_view in plan_view_list:
#         assert (plan_view.balance_notional == expected_balance_notional,
#                 (f"Mismatched: overall_buy_notional must be "
#                  f"{expected_balance_notional}, found {plan_view.balance_notional}"))
#
#     px = 110
#     qty = 7
#     plans_count = len(leg1_leg2_symbol_list)
#     plan_view_list = email_book_service_native_web_client.get_all_plan_view_client()
#     expected_balance_notional = (expected_plan_limits_.max_single_leg_notional -
#                                  plans_count * max_loop_count_per_side * qty * get_px_in_usd(px))
#     for plan_view in plan_view_list:
#         assert (plan_view.balance_notional == expected_balance_notional,
#                 (f"Mismatched: overall_buy_notional must be "
#                  f"{expected_balance_notional}, found {plan_view.balance_notional}"))


# Test for some manual check - not checking anything functionally
# def handle_test_buy_sell_with_sleep_delays(buy_symbol: str, sell_symbol: str, pair_plan_: PairPlanBaseModel,
#                                            expected_plan_limits_: PlanLimits,
#                                            expected_plan_status_: PlanStatus,
#                                            last_barter_fixture_list: List[Dict],
#                                            symbol_overview_obj_list: List[SymbolOverviewBaseModel],
#                                            market_depth_basemodel_list: List[MarketDepthBaseModel]):
#     chore_counts = 10
#     active_plan, executor_web_client = (
#         create_pre_chore_test_requirements(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
#                                            expected_plan_status_, symbol_overview_obj_list,
#                                            last_barter_fixture_list, market_depth_basemodel_list))
#
#     for chore_count in range(chore_counts):
#         # Buy Chore
#         run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
#         print(f"LastBarters created: buy_symbol: {buy_symbol}, sell_symbol: {sell_symbol}")
#         # Running TopOfBook (this triggers expected buy chore)
#         run_buy_top_of_book(buy_symbol, sell_symbol, executor_web_client[0], False)
#
#         # Sell Chore
#         run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
#         print(f"LastBarters created: buy_symbol: {buy_symbol}, sell_symbol: {sell_symbol}")
#         # Running TopOfBook (this triggers expected buy chore)
#         run_sell_top_of_book(buy_symbol, sell_symbol, executor_web_client[1], False)
#
#         time.sleep(10)
#
#
# def test_place_sanity_chores_with_sleep_delays(clean_and_set_limits, buy_sell_symbol_list, pair_plan_,
#                                                expected_plan_limits_,
#                                                expected_plan_status_, last_barter_fixture_list,
#                                                symbol_overview_obj_list, market_depth_basemodel_list):
#     symbol_pair_counter = 1
#     with concurrent.futures.ThreadPoolExecutor(max_workers=len(buy_sell_symbol_list)) as executor:
#         results = [executor.submit(handle_test_buy_sell_with_sleep_delays, buy_symbol, sell_symbol,
#                                    pair_plan_, expected_plan_limits_, expected_plan_status_,
#                                    last_barter_fixture_list, symbol_overview_obj_list, market_depth_basemodel_list)
#                    for buy_symbol, sell_symbol in buy_sell_symbol_list]
#
#         for future in concurrent.futures.as_completed(results):
#             if future.exception() is not None:
#                 raise Exception(future.exception())


# def test_create_sanity_last_barter(static_data_, clean_and_set_limits, last_barter_fixture_list):
#     symbols = ["Type1_Sec_1", "Type1_Sec_2", "Type1_Sec_3", "Type1_Sec_4"]
#     px_portions = [(40, 55), (56, 70), (71, 85), (86, 100)]
#     total_loops = 600
#     loop_wait = 1   # sec
#
#     for _ in range(total_loops):
#         current_time = DateTime.utcnow()
#         for index, symbol in enumerate(symbols):
#             px_portion = px_portions[index]
#             qty = random.randint(1000, 2000)
#             qty = qty + 400
#
#             last_barter_obj = LastBarterBaseModel(**last_barter_fixture_list[0])
#             last_barter_obj.symbol_n_exch_id.symbol = symbol
#             last_barter_obj.arrival_time = current_time
#             last_barter_obj.px = random.randint(px_portion[0], px_portion[1])
#             last_barter_obj.qty = qty
#
#             mobile_book_web_client.create_last_barter_client(last_barter_obj)
#
#         time.sleep(loop_wait)
#
#
# def test_sanity_underlying_time_series(static_data_, clean_and_set_limits, dash_, dash_filter_, bar_data_):
#     dash_ids: List[str] = []
#     dash_by_id_dict: Dict[int, DashBaseModel] = {}
#     # create all dashes
#     for index in range(1000):
#         dash_obj: DashBaseModel = DashBaseModel(**dash_)
#         dash_obj.rt_dash.leg1.sec.sec_id = f"Type1_Sec_{index + 1}"
#         stored_leg1_vwap = dash_obj.rt_dash.leg1.vwap
#         dash_obj.rt_dash.leg1.vwap = stored_leg1_vwap + random.randint(0, 30)
#         dash_obj.rt_dash.leg1.vwap_change = (dash_obj.rt_dash.leg1.vwap - stored_leg1_vwap ) * 100 / stored_leg1_vwap
#         dash_obj.rt_dash.leg2.sec.sec_id = f"Type2_Sec_{index + 1}"
#         stored_leg2_vwap = dash_obj.rt_dash.leg2.vwap
#         dash_obj.rt_dash.leg2.vwap = stored_leg2_vwap + random.randint(0, 10) / 10
#         dash_obj.rt_dash.leg2.vwap_change = (dash_obj.rt_dash.leg2.vwap - stored_leg2_vwap) * 100 / stored_leg2_vwap
#         stored_premium = dash_obj.rt_dash.mkt_premium
#         dash_obj.rt_dash.mkt_premium = stored_premium + random.randint(0, 10) * 0.1
#         dash_obj.rt_dash.mkt_premium_change = (dash_obj.rt_dash.mkt_premium - stored_premium) * 100 / stored_premium
#         stored_dash_obj: DashBaseModel = mobile_book_web_client.create_dash_client(dash_obj)
#         dash_by_id_dict[stored_dash_obj.id] = stored_dash_obj
#         dash_ids.append(str(stored_dash_obj.id))
#
#     # create dash filters and dept_book
#     dash_filters_ids: List[str] = []
#     for index in range(10):
#         dash_filters_obj: DashFiltersBaseModel = DashFiltersBaseModel(**dash_filter_)
#         dash_filters_obj.dash_name = f"Dashboard {index + 1}"
#         stored_dash_filters_obj = mobile_book_web_client.create_dash_filters_client(dash_filters_obj)
#         dash_filters_ids.append(str(stored_dash_filters_obj.id))
#         max_dashes: int = random.randint(100, 3_000)
#         dash_collection_obj = DashCollectionBaseModel(id=stored_dash_filters_obj.id,
#                                                       dash_name=stored_dash_filters_obj.dash_name,
#                                                       loaded_dashes=dash_ids[:max_dashes],
#                                                       buffered_dashes=[])
#         mobile_book_web_client.create_dash_collection_client(dash_collection_obj)
#     dash_filters_collection_obj = DashFiltersCollectionBaseModel(loaded_dash_filters=dash_filters_ids,
#                                                                  buffered_dash_filters=[])
#     mobile_book_web_client.create_dash_filters_collection_client(dash_filters_collection_obj)
#
#     total_loops = 600
#     loop_wait = 10  # sec
#     volume = 1_000
#
#     def gen_bar_data_by_leg(leg: DashLegOptional, start_time: pendulum.DateTime, is_eqt = False) -> BarDataBaseModel:
#         bar_data = BarDataBaseModel(**bar_data_)
#         bar_data.start_time = start_time
#         bar_data.end_time = start_time.add(seconds=1)
#         bar_data.symbol_n_exch_id.symbol = leg.sec.sec_id
#         bar_data.symbol_n_exch_id.exch_id = leg.exch_id
#         random_increment = random.randint(0, 10)
#         if is_eqt:
#             random_increment *= 0.1
#         bar_data.vwap = leg.vwap + random_increment
#         bar_data.vwap_change = (bar_data.vwap - leg.vwap) * 100 / leg.vwap
#         volume_change = random.randint(0, 1_000)
#         bar_data.volume = volume + volume_change
#         if not is_eqt:
#             bar_data.premium = 10 + random.randint(0, 10) * 0.1
#             bar_data.premium_change = (bar_data.premium - 10) * 100 / 10
#         return bar_data
#
#     for _ in range(total_loops):
#         current_time = DateTime.utcnow()
#         pending_bars = []
#         pending_dashes = []
#         for index, dash in enumerate(dash_by_id_dict.values()):
#             if index > 100:
#                 break
#             # create bars for leg1 and leg2
#             leg1_bar_data = gen_bar_data_by_leg(dash.rt_dash.leg1, current_time)
#             pending_bars.append(leg1_bar_data)
#             leg2_bar_data = gen_bar_data_by_leg(dash.rt_dash.leg2, current_time, True)
#             pending_bars.append(leg2_bar_data)
#
#             # dash updates
#             leg1 = DashLegOptional(vwap=leg1_bar_data.vwap, vwap_change=leg1_bar_data.vwap_change)
#             leg2 = DashLegOptional(vwap=leg2_bar_data.vwap, vwap_change=leg2_bar_data.vwap_change)
#             rt_dash = RTDashOptional(leg1=leg1, leg2=leg2, mkt_premium=leg1_bar_data.premium,
#                                      mkt_premium_change=leg1_bar_data.premium_change)
#             updated_dash = DashBaseModel(_id=dash.id, rt_dash=rt_dash)
#             pending_dashes.append(jsonable_encoder(updated_dash, by_alias=True, exclude_none=True))
#
#         mobile_book_web_client.create_all_bar_data_client(pending_bars)
#         mobile_book_web_client.patch_all_dash_client(pending_dashes)
#         time.sleep(loop_wait)


@pytest.mark.nightly
def test_add_brokers_to_contact_limits(clean_and_set_limits):
    """Adding Broker entries in contact limits"""
    broker = broker_fixture()

    contact_limits_basemodel = ContactLimitsBaseModel.from_kwargs(_id=1, eligible_brokers=[broker])
    updated_contact_limits = email_book_service_native_web_client.patch_contact_limits_client(
                                    contact_limits_basemodel.to_dict(exclude_none=True))

    assert updated_contact_limits.eligible_brokers, \
        f"Mismatch: Can't find eligible_brokers after adding it in update, {updated_contact_limits=} "
    for eligible_broker in updated_contact_limits.eligible_brokers:
        assert eligible_broker.id is not None, \
            f"Mismatch: Can't find id in updated {eligible_broker=}, {updated_contact_limits=}"

        for sec_pos in eligible_broker.sec_positions:
            assert sec_pos.id is not None, \
                f"Mismatch: Can't find id in updated {sec_pos=}, {updated_contact_limits=}"

            for position in sec_pos.positions:
                assert position.id is not None, \
                    f"Mismatch: Can't find id in updated {position=}, {updated_contact_limits=}"

    stored_contact_limits_ = email_book_service_native_web_client.get_contact_limits_client(1)
    for stored_broker in stored_contact_limits_.eligible_brokers:
        stored_broker.id = None
    broker.id = None

    assert broker in stored_contact_limits_.eligible_brokers, f"Couldn't find broker {broker} in " \
                                                                f"eligible_broker " \
                                                                f"{stored_contact_limits_.eligible_brokers}"


@pytest.mark.nightly
def test_plan_gets_deleted_even_when_symbol_overview_is_not_found(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]

    created_pair_plan = create_plan(buy_symbol, sell_symbol, pair_plan_)
    time.sleep(30)

    # deleting plan without creating symbol overview
    expected_delete_res = {'msg': 'Deletion Successful', 'id': created_pair_plan.id}
    delete_res = email_book_service_native_web_client.delete_pair_plan_client(created_pair_plan.id)
    assert delete_res == expected_delete_res, \
        f"Mismatch: expected delete response: {expected_delete_res}, got {delete_res}"


@pytest.mark.nightly1
def test_buy_sell_chore_multi_pair_serialized(static_data_, clean_and_set_limits, pair_securities_with_sides_,
                                              buy_chore_, sell_chore_, buy_fill_journal_,
                                              sell_fill_journal_, expected_buy_chore_snapshot_,
                                              expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
                                              pair_plan_, expected_plan_limits_, expected_plan_status_,
                                              expected_plan_brief_, expected_contact_status_,
                                              last_barter_fixture_list, symbol_overview_obj_list,
                                              market_depth_basemodel_list, expected_chore_limits_,
                                              expected_contact_limits_, max_loop_count_per_side,
                                              leg1_leg2_symbol_list, refresh_sec_update_fixture):
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:int(len(leg1_leg2_symbol_list) / 2)]
    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0
    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        stored_pair_plan_basemodel = create_plan(leg1_symbol, leg2_symbol, pair_plan_)

        plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = (
            handle_test_buy_sell_chore(leg1_symbol, leg2_symbol, max_loop_count_per_side,
                                       refresh_sec_update_fixture, buy_chore_, sell_chore_, buy_fill_journal_,
                                       sell_fill_journal_, expected_buy_chore_snapshot_, expected_sell_chore_snapshot_,
                                       expected_symbol_side_snapshot_, stored_pair_plan_basemodel,
                                       expected_plan_limits_, expected_plan_status_, expected_plan_brief_,
                                       last_barter_fixture_list, symbol_overview_obj_list,
                                       market_depth_basemodel_list))
        overall_buy_notional += plan_buy_notional
        overall_sell_notional += plan_sell_notional
        overall_buy_fill_notional += plan_buy_fill_notional
        overall_sell_fill_notional += plan_sell_fill_notional

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
def test_buy_sell_chore_multi_pair_parallel(static_data_, clean_and_set_limits, pair_securities_with_sides_,
                                            buy_chore_, sell_chore_, buy_fill_journal_,
                                            sell_fill_journal_, expected_buy_chore_snapshot_,
                                            expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
                                            pair_plan_, expected_plan_limits_, expected_plan_status_,
                                            expected_plan_brief_, expected_contact_status_,
                                            last_barter_fixture_list, symbol_overview_obj_list,
                                            market_depth_basemodel_list, expected_chore_limits_,
                                            expected_contact_limits_, max_loop_count_per_side,
                                            leg1_leg2_symbol_list, refresh_sec_update_fixture):
    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0

    leg1_leg2_symbol_list = []
    total_plans = 10
    pair_plan_list = []
    for i in range(1, total_plans + 1):
        leg1_symbol = f"Type1_Sec_{i}"
        leg2_symbol = f"Type2_Sec_{i}"
        leg1_leg2_symbol_list.append((leg1_symbol, leg2_symbol))

        stored_pair_plan_basemodel = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
        pair_plan_list.append(stored_pair_plan_basemodel)
        time.sleep(2)

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(leg1_leg2_symbol_list)) as executor:
        results = [executor.submit(handle_test_buy_sell_chore, leg1_leg2_symbol[0], leg1_leg2_symbol[1],
                                   max_loop_count_per_side, refresh_sec_update_fixture, copy.deepcopy(buy_chore_),
                                   copy.deepcopy(sell_chore_), copy.deepcopy(buy_fill_journal_),
                                   copy.deepcopy(sell_fill_journal_), copy.deepcopy(expected_buy_chore_snapshot_),
                                   copy.deepcopy(expected_sell_chore_snapshot_),
                                   copy.deepcopy(expected_symbol_side_snapshot_), pair_plan_list[idx],
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(expected_plan_brief_),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), False)
                   for idx, leg1_leg2_symbol in enumerate(leg1_leg2_symbol_list)]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())
            else:
                plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = future.result()
                overall_buy_notional += plan_buy_notional
                overall_sell_notional += plan_sell_notional
                overall_buy_fill_notional += plan_buy_fill_notional
                overall_sell_fill_notional += plan_sell_fill_notional

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
def test_same_pair_parallel_run(static_data_, clean_and_set_limits, pair_securities_with_sides_,
                                buy_chore_, sell_chore_, buy_fill_journal_,
                                sell_fill_journal_, expected_buy_chore_snapshot_,
                                expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
                                pair_plan_, expected_plan_limits_, expected_plan_status_,
                                expected_plan_brief_, expected_contact_status_,
                                last_barter_fixture_list, symbol_overview_obj_list,
                                market_depth_basemodel_list, expected_chore_limits_,
                                expected_contact_limits_, max_loop_count_per_side,
                                leg1_leg2_symbol_list, refresh_sec_update_fixture):
    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0

    total_plans = 10
    leg1_symbol = "Type1_Sec_1"
    leg2_symbol = "Type2_Sec_1"

    buy_sell_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
    time.sleep(2)

    sell_buy_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_,
                                       leg1_side=Side.SELL, leg2_side=Side.BUY)
    time.sleep(2)

    pair_plan_to_test_callable_list = [
        (buy_sell_pair_plan, handle_test_buy_sell_chore),
        (sell_buy_pair_plan, handle_test_sell_buy_chore)
    ]

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(pair_plan_to_test_callable_list)) as executor:
        results = [executor.submit(test_callable, leg1_symbol, leg2_symbol,
                                   max_loop_count_per_side, refresh_sec_update_fixture, copy.deepcopy(buy_chore_),
                                   copy.deepcopy(sell_chore_), copy.deepcopy(buy_fill_journal_),
                                   copy.deepcopy(sell_fill_journal_), copy.deepcopy(expected_buy_chore_snapshot_),
                                   copy.deepcopy(expected_sell_chore_snapshot_),
                                   copy.deepcopy(expected_symbol_side_snapshot_), create_pair_plan,
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(expected_plan_brief_),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), False)
                   for create_pair_plan, test_callable in pair_plan_to_test_callable_list]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise future.exception()
            else:
                plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = future.result()
                overall_buy_notional += plan_buy_notional
                overall_sell_notional += plan_sell_notional
                overall_buy_fill_notional += plan_buy_fill_notional
                overall_sell_fill_notional += plan_sell_fill_notional

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
def test_same_pair_parallel_run_both_side_in_pair(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0

    total_plans = 10
    leg1_symbol = "Type1_Sec_1"
    leg2_symbol = "Type2_Sec_1"

    buy_sell_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
    time.sleep(2)

    sell_buy_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_,
                                       leg1_side=Side.SELL, leg2_side=Side.BUY)
    time.sleep(2)

    pair_plan_to_test_callable_list = [
        (buy_sell_pair_plan, handle_test_buy_sell_pair_chore),
        (sell_buy_pair_plan, handle_test_sell_buy_pair_chore)
    ]

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(pair_plan_to_test_callable_list)) as executor:
        results = [executor.submit(test_callable, leg1_symbol, leg2_symbol,
                                   max_loop_count_per_side, refresh_sec_update_fixture, copy.deepcopy(buy_chore_),
                                   copy.deepcopy(sell_chore_), copy.deepcopy(buy_fill_journal_),
                                   copy.deepcopy(sell_fill_journal_), copy.deepcopy(expected_buy_chore_snapshot_),
                                   copy.deepcopy(expected_sell_chore_snapshot_),
                                   copy.deepcopy(expected_symbol_side_snapshot_), create_pair_plan,
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(expected_plan_brief_),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), False)
                   for create_pair_plan, test_callable in pair_plan_to_test_callable_list]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise future.exception()
            else:
                plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = future.result()
                overall_buy_notional += plan_buy_notional
                overall_sell_notional += plan_sell_notional
                overall_buy_fill_notional += plan_buy_fill_notional
                overall_sell_fill_notional += plan_sell_fill_notional

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
def test_same_pair_parallel_place_chore_in_sequence(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):

    total_plans = 10
    leg1_symbol = "Type1_Sec_1"
    leg2_symbol = "Type2_Sec_1"

    buy_sell_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
    time.sleep(2)

    sell_buy_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_,
                                       leg1_side=Side.SELL, leg2_side=Side.BUY)
    time.sleep(2)
    pair_plan_list = [buy_sell_pair_plan, sell_buy_pair_plan]
    expected_plan_limits_list = [copy.deepcopy(expected_plan_limits_), copy.deepcopy(expected_plan_limits_)]

    max_loop_count_per_side = 2
    plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = (
        handle_test_buy_sell_n_sell_buy_pair_chore(
            max_loop_count_per_side,
            refresh_sec_update_fixture, buy_chore_,
            sell_chore_,
            buy_fill_journal_, sell_fill_journal_,
            expected_buy_chore_snapshot_,
            expected_sell_chore_snapshot_,
            expected_symbol_side_snapshot_,
            pair_plan_list, expected_plan_limits_list,
            expected_plan_status_, expected_plan_brief_,
            last_barter_fixture_list,
            symbol_overview_obj_list,
            market_depth_basemodel_list,
            False))

    expected_contact_status_.overall_buy_notional = plan_buy_notional
    expected_contact_status_.overall_sell_notional = plan_sell_notional
    expected_contact_status_.overall_buy_fill_notional = plan_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = plan_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
def test_same_n_opposite_plans_in_combination1(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):

    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0

    total_plans = 10
    pair_plan_to_test_callable_list = []
    for i in range(1, 5):
        if i < 3:
            # round-trip plan pair - total 2
            leg1_symbol = f"Type1_Sec_{i}"
            leg2_symbol = f"Type2_Sec_{i}"

            buy_sell_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
            time.sleep(2)

            sell_buy_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_,
                                               leg1_side=Side.SELL, leg2_side=Side.BUY)
            time.sleep(2)

            pair_plan_to_test_callable_list.extend([
                (leg1_symbol, leg2_symbol, buy_sell_pair_plan, handle_test_buy_sell_pair_chore),
                (leg1_symbol, leg2_symbol, sell_buy_pair_plan, handle_test_sell_buy_pair_chore)
            ])
        elif i < 4:
            # premium buy-sell plan - total 1
            leg1_symbol = f"Type1_Sec_{i}"
            leg2_symbol = f"Type2_Sec_{i}"

            buy_sell_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
            time.sleep(2)
            pair_plan_to_test_callable_list.append((leg1_symbol, leg2_symbol, buy_sell_pair_plan,
                                                     handle_test_buy_sell_pair_chore))
        else:
            # premium sell-buy plan - total 1
            leg1_symbol = f"Type1_Sec_{i}"
            leg2_symbol = f"Type2_Sec_{i}"

            sell_buy_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_,
                                               leg1_side=Side.SELL, leg2_side=Side.BUY)
            time.sleep(2)
            pair_plan_to_test_callable_list.append((leg1_symbol, leg2_symbol, sell_buy_pair_plan,
                                                     handle_test_sell_buy_pair_chore))

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(pair_plan_to_test_callable_list)) as executor:
        results = [executor.submit(test_callable, leg1_symbol, leg2_symbol,
                                   max_loop_count_per_side, refresh_sec_update_fixture, copy.deepcopy(buy_chore_),
                                   copy.deepcopy(sell_chore_), copy.deepcopy(buy_fill_journal_),
                                   copy.deepcopy(sell_fill_journal_), copy.deepcopy(expected_buy_chore_snapshot_),
                                   copy.deepcopy(expected_sell_chore_snapshot_),
                                   copy.deepcopy(expected_symbol_side_snapshot_), create_pair_plan,
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(expected_plan_brief_),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), False)
                   for leg1_symbol, leg2_symbol, create_pair_plan, test_callable in
                   pair_plan_to_test_callable_list]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise future.exception()
            else:
                plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = future.result()
                overall_buy_notional += plan_buy_notional
                overall_sell_notional += plan_sell_notional
                overall_buy_fill_notional += plan_buy_fill_notional
                overall_sell_fill_notional += plan_sell_fill_notional

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
def test_same_n_opposite_plans_in_combination2(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):

    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0

    total_plans = 10
    pair_plan_to_test_callable_list = []
    # round-trip plan pair - total 2
    leg1_symbol = f"Type1_Sec_1"
    leg2_symbol = f"Type2_Sec_1"

    buy_sell_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
    time.sleep(2)

    sell_buy_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_,
                                       leg1_side=Side.SELL, leg2_side=Side.BUY)
    time.sleep(2)
    pair_plan_to_test_callable_list.extend([
        (leg1_symbol, leg2_symbol, buy_sell_pair_plan, handle_test_buy_sell_pair_chore),
        (leg1_symbol, leg2_symbol, sell_buy_pair_plan, handle_test_sell_buy_pair_chore)
    ])

    pair_plan_data_for_ready = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
    time.sleep(2)

    leg1_symbol = f"Type1_Sec_2"
    leg2_symbol = f"Type2_Sec_2"

    buy_sell_pair_plan = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
    time.sleep(2)
    pair_plan_to_test_callable_list.extend([
        (leg1_symbol, leg2_symbol, buy_sell_pair_plan, handle_test_buy_sell_pair_chore)
    ])

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(pair_plan_to_test_callable_list)) as executor:
        results = [executor.submit(test_callable, leg1_symbol, leg2_symbol,
                                   max_loop_count_per_side, refresh_sec_update_fixture, copy.deepcopy(buy_chore_),
                                   copy.deepcopy(sell_chore_), copy.deepcopy(buy_fill_journal_),
                                   copy.deepcopy(sell_fill_journal_), copy.deepcopy(expected_buy_chore_snapshot_),
                                   copy.deepcopy(expected_sell_chore_snapshot_),
                                   copy.deepcopy(expected_symbol_side_snapshot_), create_pair_plan,
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(expected_plan_brief_),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), False)
                   for leg1_symbol, leg2_symbol, create_pair_plan, test_callable in
                   pair_plan_to_test_callable_list]

        ready_plan_result = [executor.submit(move_snoozed_pair_plan_to_ready_n_then_active, pair_plan_data_for_ready,
                                        copy.deepcopy(market_depth_basemodel_list),
                                        copy.deepcopy(symbol_overview_obj_list),
                                        copy.deepcopy(expected_plan_limits_),
                                        copy.deepcopy(expected_plan_status_), True)]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise future.exception()
            else:
                plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = future.result()
                overall_buy_notional += plan_buy_notional
                overall_sell_notional += plan_sell_notional
                overall_buy_fill_notional += plan_buy_fill_notional
                overall_sell_fill_notional += plan_sell_fill_notional

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise future.exception()
        else:
            future.result()

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
def test_sell_buy_chore_multi_pair_parallel(static_data_, clean_and_set_limits, pair_securities_with_sides_,
                                            buy_chore_, sell_chore_, buy_fill_journal_,
                                            sell_fill_journal_, expected_buy_chore_snapshot_,
                                            expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
                                            pair_plan_, expected_plan_limits_, expected_plan_status_,
                                            expected_plan_brief_, expected_contact_status_,
                                            last_barter_fixture_list, symbol_overview_obj_list,
                                            market_depth_basemodel_list, expected_chore_limits_,
                                            expected_contact_limits_, max_loop_count_per_side,
                                            leg1_leg2_symbol_list, refresh_sec_update_fixture):
    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0

    leg1_leg2_symbol_list = []
    total_plans = 10
    pair_plan_list = []
    for i in range(1, total_plans + 1):
        leg1_symbol = f"Type1_Sec_{i}"
        leg2_symbol = f"Type2_Sec_{i}"
        leg1_leg2_symbol_list.append((leg1_symbol, leg2_symbol))

        stored_pair_plan_basemodel = create_plan(leg1_symbol, leg2_symbol, pair_plan_,
                                                   leg1_side=Side.SELL, leg2_side=Side.BUY)
        pair_plan_list.append(stored_pair_plan_basemodel)
        time.sleep(2)

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(leg1_leg2_symbol_list)) as executor:
        results = [executor.submit(handle_test_sell_buy_chore, leg1_leg2_symbol[0], leg1_leg2_symbol[1],
                                   max_loop_count_per_side, refresh_sec_update_fixture, copy.deepcopy(buy_chore_),
                                   copy.deepcopy(sell_chore_), copy.deepcopy(buy_fill_journal_),
                                   copy.deepcopy(sell_fill_journal_), copy.deepcopy(expected_buy_chore_snapshot_),
                                   copy.deepcopy(expected_sell_chore_snapshot_),
                                   copy.deepcopy(expected_symbol_side_snapshot_), pair_plan_list[idx],
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(expected_plan_brief_),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), False)
                   for idx, leg1_leg2_symbol in enumerate(leg1_leg2_symbol_list)]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())
            else:
                plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = future.result()
                overall_buy_notional += plan_buy_notional
                overall_sell_notional += plan_sell_notional
                overall_buy_fill_notional += plan_buy_fill_notional
                overall_sell_fill_notional += plan_sell_fill_notional

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly1
def test_buy_sell_non_systematic_chore_multi_pair_serialized(static_data_, clean_and_set_limits,
                                                             pair_securities_with_sides_,
                                                             buy_chore_, sell_chore_, buy_fill_journal_,
                                                             sell_fill_journal_, expected_buy_chore_snapshot_,
                                                             expected_sell_chore_snapshot_,
                                                             expected_symbol_side_snapshot_,
                                                             pair_plan_, expected_plan_limits_,
                                                             expected_plan_status_,
                                                             expected_plan_brief_, expected_contact_status_,
                                                             last_barter_fixture_list, symbol_overview_obj_list,
                                                             market_depth_basemodel_list, expected_chore_limits_,
                                                             expected_contact_limits_, max_loop_count_per_side,
                                                             leg1_leg2_symbol_list, refresh_sec_update_fixture):
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:int(len(leg1_leg2_symbol_list) / 2)]
    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0
    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        stored_pair_plan_basemodel = create_plan(leg1_symbol, leg2_symbol, pair_plan_)

        plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = (
            handle_test_buy_sell_chore(leg1_symbol, leg2_symbol, max_loop_count_per_side,
                                       refresh_sec_update_fixture, buy_chore_, sell_chore_, buy_fill_journal_,
                                       sell_fill_journal_, expected_buy_chore_snapshot_, expected_sell_chore_snapshot_,
                                       expected_symbol_side_snapshot_, stored_pair_plan_basemodel,
                                       expected_plan_limits_, expected_plan_status_, expected_plan_brief_,
                                       last_barter_fixture_list, symbol_overview_obj_list,
                                       market_depth_basemodel_list, is_non_systematic_run=True))
        overall_buy_notional += plan_buy_notional
        overall_sell_notional += plan_sell_notional
        overall_buy_fill_notional += plan_buy_fill_notional
        overall_sell_fill_notional += plan_sell_fill_notional

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
def test_buy_sell_non_systematic_chore_multi_pair_parallel(static_data_, clean_and_set_limits,
                                                           pair_securities_with_sides_,
                                                           buy_chore_, sell_chore_, buy_fill_journal_,
                                                           sell_fill_journal_, expected_buy_chore_snapshot_,
                                                           expected_sell_chore_snapshot_,
                                                           expected_symbol_side_snapshot_,
                                                           pair_plan_, expected_plan_limits_, expected_plan_status_,
                                                           expected_plan_brief_, expected_contact_status_,
                                                           last_barter_fixture_list, symbol_overview_obj_list,
                                                           market_depth_basemodel_list, expected_chore_limits_,
                                                           expected_contact_limits_, max_loop_count_per_side,
                                                           leg1_leg2_symbol_list, refresh_sec_update_fixture):
    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0

    leg1_leg2_symbol_list = []
    total_plans = 10
    pair_plan_list = []
    for i in range(1, total_plans + 1):
        leg1_symbol = f"Type1_Sec_{i}"
        leg2_symbol = f"Type2_Sec_{i}"
        leg1_leg2_symbol_list.append((leg1_symbol, leg2_symbol))

        stored_pair_plan_basemodel = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
        pair_plan_list.append(stored_pair_plan_basemodel)
        time.sleep(2)

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(leg1_leg2_symbol_list)) as executor:
        results = [executor.submit(handle_test_buy_sell_chore, buy_sell_symbol[0], buy_sell_symbol[1],
                                   max_loop_count_per_side, refresh_sec_update_fixture, copy.deepcopy(buy_chore_),
                                   copy.deepcopy(sell_chore_), copy.deepcopy(buy_fill_journal_),
                                   copy.deepcopy(sell_fill_journal_), copy.deepcopy(expected_buy_chore_snapshot_),
                                   copy.deepcopy(expected_sell_chore_snapshot_),
                                   copy.deepcopy(expected_symbol_side_snapshot_), pair_plan_list[idx],
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(expected_plan_brief_),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), True)
                   for idx, buy_sell_symbol in enumerate(leg1_leg2_symbol_list)]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())
            else:
                plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = future.result()
                overall_buy_notional += plan_buy_notional
                overall_sell_notional += plan_sell_notional
                overall_buy_fill_notional += plan_buy_fill_notional
                overall_sell_fill_notional += plan_sell_fill_notional

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
def test_buy_sell_pair_chore(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    triggers buy & sell pair chore (single buy chore followed by single sell chore) for max_loop_count_per_side times
    """
    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0

    leg1_leg2_symbol_list = []
    total_plans = 10
    pair_plan_list = []
    for i in range(1, total_plans + 1):
        leg1_symbol = f"Type1_Sec_{i}"
        leg2_symbol = f"Type2_Sec_{i}"
        leg1_leg2_symbol_list.append((leg1_symbol, leg2_symbol))

        stored_pair_plan_basemodel = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
        pair_plan_list.append(stored_pair_plan_basemodel)
        time.sleep(2)

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(leg1_leg2_symbol_list)) as executor:
        results = [executor.submit(handle_test_buy_sell_pair_chore, leg1_leg2_symbol[0], leg1_leg2_symbol[1],
                                   max_loop_count_per_side, refresh_sec_update_fixture, copy.deepcopy(buy_chore_),
                                   copy.deepcopy(sell_chore_), copy.deepcopy(buy_fill_journal_),
                                   copy.deepcopy(sell_fill_journal_), copy.deepcopy(expected_buy_chore_snapshot_),
                                   copy.deepcopy(expected_sell_chore_snapshot_),
                                   copy.deepcopy(expected_symbol_side_snapshot_), pair_plan_list[idx],
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(expected_plan_brief_),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), False)
                   for idx, leg1_leg2_symbol in enumerate(leg1_leg2_symbol_list)]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())
            else:
                plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = future.result()
                overall_buy_notional += plan_buy_notional
                overall_sell_notional += plan_sell_notional
                overall_buy_fill_notional += plan_buy_fill_notional
                overall_sell_fill_notional += plan_sell_fill_notional

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
def test_sell_buy_pair_chore(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    triggers sell & buy pair chore (single sell chore followed by single buy chore) for max_loop_count_per_side times
    """
    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0

    leg1_leg2_symbol_list = []
    total_plans = 10
    pair_plan_list = []
    for i in range(1, total_plans + 1):
        leg1_symbol = f"Type1_Sec_{i}"
        leg2_symbol = f"Type2_Sec_{i}"
        leg1_leg2_symbol_list.append((leg1_symbol, leg2_symbol))

        stored_pair_plan_basemodel = create_plan(leg1_symbol, leg2_symbol, pair_plan_,
                                                   leg1_side=Side.SELL, leg2_side=Side.BUY)
        pair_plan_list.append(stored_pair_plan_basemodel)
        time.sleep(2)

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(leg1_leg2_symbol_list)) as executor:
        results = [executor.submit(handle_test_sell_buy_pair_chore, leg1_leg2_symbol[0], leg1_leg2_symbol[1],
                                   max_loop_count_per_side, refresh_sec_update_fixture, copy.deepcopy(buy_chore_),
                                   copy.deepcopy(sell_chore_), copy.deepcopy(buy_fill_journal_),
                                   copy.deepcopy(sell_fill_journal_), copy.deepcopy(expected_buy_chore_snapshot_),
                                   copy.deepcopy(expected_sell_chore_snapshot_),
                                   copy.deepcopy(expected_symbol_side_snapshot_), pair_plan_list[idx],
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(expected_plan_brief_),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), False)
                   for idx, leg1_leg2_symbol in enumerate(leg1_leg2_symbol_list)]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())
            else:
                plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = future.result()
                overall_buy_notional += plan_buy_notional
                overall_sell_notional += plan_sell_notional
                overall_buy_fill_notional += plan_buy_fill_notional
                overall_sell_fill_notional += plan_sell_fill_notional

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
@pytest.mark.parametrize("market_depth_basemodel_list", [5, 10, 20], indirect=True)
def test_multiple_market_depths_in_plans(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0

    exch_to_market_depth_lvl_dict = executor_config_yaml_dict.get("exch_to_market_depth_lvl", {})
    parametrized_val = int(len(market_depth_basemodel_list)/4)
    for key, val in exch_to_market_depth_lvl_dict.items():
        if val == parametrized_val:
            exch_id = key
            break
    else:
        assert False, (f"Can't find exch_id with depth lvl matching with this test run's {parametrized_val=} in "
                       f"executor config file")

    leg1_leg2_symbol_list = []
    total_plans = 10
    pair_plan_list = []
    for i in range(1, total_plans + 1):
        leg1_symbol = f"Type1_Sec_{i}"
        leg2_symbol = f"Type2_Sec_{i}"
        leg1_leg2_symbol_list.append((leg1_symbol, leg2_symbol))

        stored_pair_plan_basemodel = create_plan(leg1_symbol, leg2_symbol, pair_plan_)

        # setting exch_id based on parametrized value explicitly post plan create - create time exch_id is
        # taken from static data so gets overrided by static data value
        stored_pair_plan_basemodel.pair_plan_params.plan_leg1.exch_id = exch_id
        stored_pair_plan_basemodel.pair_plan_params.plan_leg2.exch_id = exch_id
        updated_pair_plan_basemodel = email_book_service_native_web_client.put_pair_plan_client(stored_pair_plan_basemodel)
        pair_plan_list.append(updated_pair_plan_basemodel)
        time.sleep(2)

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(leg1_leg2_symbol_list)) as executor:
        results = [executor.submit(handle_test_buy_sell_pair_chore, leg1_leg2_symbol[0], leg1_leg2_symbol[1],
                                   max_loop_count_per_side, refresh_sec_update_fixture, copy.deepcopy(buy_chore_),
                                   copy.deepcopy(sell_chore_), copy.deepcopy(buy_fill_journal_),
                                   copy.deepcopy(sell_fill_journal_), copy.deepcopy(expected_buy_chore_snapshot_),
                                   copy.deepcopy(expected_sell_chore_snapshot_),
                                   copy.deepcopy(expected_symbol_side_snapshot_), pair_plan_list[idx],
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(expected_plan_brief_),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), False)
                   for idx, leg1_leg2_symbol in enumerate(leg1_leg2_symbol_list)]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())
            else:
                plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = future.result()
                overall_buy_notional += plan_buy_notional
                overall_sell_notional += plan_sell_notional
                overall_buy_fill_notional += plan_buy_fill_notional
                overall_sell_fill_notional += plan_sell_fill_notional

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
def test_asymmetric_market_depths_in_plans(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    overall_buy_notional = 0
    overall_sell_notional = 0
    overall_buy_fill_notional = 0
    overall_sell_fill_notional = 0

    leg1_leg2_symbol_list = []
    total_plans = 10
    pair_plan_list = []
    for i in range(1, total_plans + 1):
        leg1_symbol = f"Type1_Sec_{i}"
        leg2_symbol = f"Type2_Sec_{i}"
        leg1_leg2_symbol_list.append((leg1_symbol, leg2_symbol))

        stored_pair_plan_basemodel = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
        pair_plan_list.append(stored_pair_plan_basemodel)
        time.sleep(2)

    # keeping bid side length=3 and ask side length=4
    market_depth_basemodel_list_ = (market_depth_basemodel_list[:3] +    # cb_sec bid
                                    market_depth_basemodel_list[5:9] +  # cb_sec ask
                                    market_depth_basemodel_list[10:13] +  # eqt_sec bid
                                    market_depth_basemodel_list[15:19])    # eqt_sec ask
    # updating last positions - same code is used in other tests also and
    # last position px and qty is used in executor calculations
    market_depth_basemodel_list_[2] = market_depth_basemodel_list[4]
    market_depth_basemodel_list_[2].position = 2
    market_depth_basemodel_list_[6] = market_depth_basemodel_list[9]
    market_depth_basemodel_list_[6].position = 3
    market_depth_basemodel_list_[9] = market_depth_basemodel_list[14]
    market_depth_basemodel_list_[9].position = 2
    market_depth_basemodel_list_[13] = market_depth_basemodel_list[19]
    market_depth_basemodel_list_[13].position = 3

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(leg1_leg2_symbol_list)) as executor:
        results = [executor.submit(handle_test_buy_sell_pair_chore, leg1_leg2_symbol[0], leg1_leg2_symbol[1],
                                   max_loop_count_per_side, refresh_sec_update_fixture, copy.deepcopy(buy_chore_),
                                   copy.deepcopy(sell_chore_), copy.deepcopy(buy_fill_journal_),
                                   copy.deepcopy(sell_fill_journal_), copy.deepcopy(expected_buy_chore_snapshot_),
                                   copy.deepcopy(expected_sell_chore_snapshot_),
                                   copy.deepcopy(expected_symbol_side_snapshot_), pair_plan_list[idx],
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(expected_plan_brief_),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list_), False)
                   for idx, leg1_leg2_symbol in enumerate(leg1_leg2_symbol_list)]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())
            else:
                plan_buy_notional, plan_sell_notional, plan_buy_fill_notional, plan_sell_fill_notional = future.result()
                overall_buy_notional += plan_buy_notional
                overall_sell_notional += plan_sell_notional
                overall_buy_fill_notional += plan_buy_fill_notional
                overall_sell_fill_notional += plan_sell_fill_notional

    expected_contact_status_.overall_buy_notional = overall_buy_notional
    expected_contact_status_.overall_sell_notional = overall_sell_notional
    expected_contact_status_.overall_buy_fill_notional = overall_buy_fill_notional
    expected_contact_status_.overall_sell_fill_notional = overall_sell_fill_notional
    verify_contact_status(expected_contact_status_)


@pytest.mark.nightly
def test_trigger_kill_switch_systematic(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                                        expected_plan_limits_, expected_plan_status_,
                                        symbol_overview_obj_list, last_barter_fixture_list,
                                        market_depth_basemodel_list, refresh_sec_update_fixture):
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture

    created_pair_plan, executor_web_client = (
        create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list,
                                           last_barter_fixture_list,
                                           market_depth_basemodel_list))

    bid_buy_top_market_depth, ask_sell_top_market_depth = (
        get_buy_bid_n_ask_sell_market_depth(leg1_symbol, leg2_symbol, created_pair_plan))

    # positive test
    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
    time.sleep(1)
    update_tob_through_market_depth_to_place_buy_chore(created_pair_plan.cpp_port, bid_buy_top_market_depth,
                                                       ask_sell_top_market_depth)

    # internally checks chore_journal existence
    chore_journal: ChoreJournal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW,
                                                                                 leg1_symbol, executor_web_client)

    # negative test
    system_control = SystemControlBaseModel.from_kwargs(_id=1, kill_switch=True)
    updated_system_control = email_book_service_native_web_client.patch_system_control_client(
        system_control.to_dict(exclude_none=True))
    assert updated_system_control.kill_switch, "Unexpected: kill_switch is False, expected to be True"

    # validating if bartering_link.trigger_kill_switch got called
    check_str = "Called BarteringLink.trigger_kill_switch"
    alert_fail_msg = f"Can't find contact alert saying '{check_str}'"
    time.sleep(5)
    check_alert_str_in_contact_alert(check_str, alert_fail_msg)

    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
    time.sleep(1)
    update_tob_through_market_depth_to_place_buy_chore(created_pair_plan.cpp_port, bid_buy_top_market_depth,
                                                       ask_sell_top_market_depth)
    # internally checking buy chore
    chore_journal = \
        get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW,
                                                       leg1_symbol, executor_web_client,
                                                       last_chore_id=chore_journal.chore.chore_id,
                                                       expect_no_chore=True)

    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
    # required to make buy side tob latest
    run_last_barter(leg1_symbol, leg2_symbol, [last_barter_fixture_list[0]], created_pair_plan.cpp_port)

    update_tob_through_market_depth_to_place_sell_chore(created_pair_plan.cpp_port, ask_sell_top_market_depth,
                                                        bid_buy_top_market_depth)
    # internally checking sell chore
    chore_journal = \
        get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW,
                                                       leg2_symbol, executor_web_client, expect_no_chore=True)


@pytest.mark.nightly
def test_trigger_kill_switch_non_systematic(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                                            pair_plan_, expected_plan_limits_,
                                            expected_plan_status_, symbol_overview_obj_list,
                                            last_barter_fixture_list, market_depth_basemodel_list,
                                            buy_chore_, sell_chore_,
                                            refresh_sec_update_fixture):
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]

    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture

    (active_pair_plan, executor_web_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list, get_config_data=False)

    # positive test
    # placing buy chore
    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
    place_new_chore(leg1_symbol, Side.BUY, buy_chore_.chore.px, buy_chore_.chore.qty, executor_web_client,
                    buy_inst_type)
    time.sleep(2)
    # internally checking buy chore
    chore_journal: ChoreJournal = \
        get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW,
                                                       leg1_symbol, executor_web_client)

    # negative test
    system_control = SystemControlBaseModel.from_kwargs(_id=1, kill_switch=True)
    updated_system_control = email_book_service_native_web_client.patch_system_control_client(
        system_control.to_dict(exclude_none=True))
    assert updated_system_control.kill_switch, "Unexpected: kill_switch is False, expected to be True"

    # validating if bartering_link.trigger_kill_switch got called
    check_str = "Called BarteringLink.trigger_kill_switch"
    alert_fail_msg = f"Can't find contact alert saying '{check_str}'"
    time.sleep(5)
    check_alert_str_in_contact_alert(check_str, alert_fail_msg)

    # placing buy chore
    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
    place_new_chore(leg1_symbol, Side.BUY, buy_chore_.chore.px, buy_chore_.chore.qty, executor_web_client,
                    buy_inst_type)
    time.sleep(2)
    # internally checking buy chore
    chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW,
                                                                   leg1_symbol, executor_web_client,
                                                                   last_chore_id=chore_journal.chore.chore_id,
                                                                   expect_no_chore=True)

    # placing sell chore
    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
    place_new_chore(leg2_symbol, Side.SELL, sell_chore_.chore.px, sell_chore_.chore.qty, executor_web_client,
                    sell_inst_type)
    time.sleep(2)
    # internally checking sell chore
    chore_journal = \
        get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW,
                                                       leg2_symbol, executor_web_client, expect_no_chore=True)


@pytest.mark.nightly
def test_revoke_kill_switch(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                            expected_plan_limits_, expected_plan_status_,
                            symbol_overview_obj_list, last_barter_fixture_list,
                            market_depth_basemodel_list, refresh_sec_update_fixture):
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]

    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture
    created_pair_plan, executor_web_client = (
        create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list,
                                           last_barter_fixture_list,
                                           market_depth_basemodel_list))

    # positive test
    system_control = SystemControlBaseModel.from_kwargs(_id=1, kill_switch=True)
    updated_system_control = email_book_service_native_web_client.patch_system_control_client(
        system_control.to_dict(exclude_none=True))
    assert updated_system_control.kill_switch, "Unexpected: kill_switch is False, expected to be True"

    bid_buy_top_market_depth, ask_sell_top_market_depth = (
        get_buy_bid_n_ask_sell_market_depth(leg1_symbol, leg2_symbol, created_pair_plan))
    time.sleep(2)
    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
    time.sleep(1)
    update_tob_through_market_depth_to_place_buy_chore(created_pair_plan.cpp_port, bid_buy_top_market_depth,
                                                       ask_sell_top_market_depth)
    # internally checking buy chore
    chore_journal = \
        get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW,
                                                       leg1_symbol, executor_web_client, expect_no_chore=True)

    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
    # required to make buy side tob latest
    run_last_barter(leg1_symbol, leg2_symbol, [last_barter_fixture_list[0]], created_pair_plan.cpp_port)

    update_tob_through_market_depth_to_place_sell_chore(created_pair_plan.cpp_port, ask_sell_top_market_depth,
                                                        bid_buy_top_market_depth)
    # internally checking sell chore
    chore_journal = \
        get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW,
                                                       leg2_symbol, executor_web_client, expect_no_chore=True)

    # negative test
    system_control = SystemControlBaseModel.from_kwargs(_id=1, kill_switch=False)
    updated_system_control = email_book_service_native_web_client.patch_system_control_client(
        system_control.to_dict(exclude_none=True))
    assert not updated_system_control.kill_switch, "Unexpected: kill_switch is True, expected to be False"

    # validating if bartering_link.trigger_kill_switch got called
    check_str = "Called BarteringLink.revoke_kill_switch_n_resume_bartering"
    alert_fail_msg = f"Can't find contact alert saying '{check_str}'"
    time.sleep(5)
    check_alert_str_in_contact_alert(check_str, alert_fail_msg)

    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
    time.sleep(1)
    update_tob_through_market_depth_to_place_buy_chore(created_pair_plan.cpp_port, bid_buy_top_market_depth,
                                                       ask_sell_top_market_depth)

    # internally checks chore_journal existence
    chore_journal: ChoreJournal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW,
                                                                                 leg1_symbol, executor_web_client)
    time.sleep(residual_wait_sec)

    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
    # required to make buy side tob latest
    run_last_barter(leg1_symbol, leg2_symbol, [last_barter_fixture_list[0]], created_pair_plan.cpp_port)

    update_tob_through_market_depth_to_place_sell_chore(created_pair_plan.cpp_port, ask_sell_top_market_depth,
                                                        bid_buy_top_market_depth)
    # internally checking sell chore
    chore_journal = \
        get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW,
                                                       leg2_symbol, executor_web_client)


@pytest.mark.nightly
def test_trigger_switch_fail(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_,
        symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list):

    config_file_path = STRAT_EXECUTOR / "data" / f"kill_switch_simulate_config.yaml"
    config_dict: Dict = YAMLConfigurationManager.load_yaml_configurations(config_file_path)
    config_dict_str = YAMLConfigurationManager.load_yaml_configurations(config_file_path, load_as_str=True)

    try:
        # updating yaml_configs according to this test
        config_dict["trigger_kill_switch"] = False
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        email_book_service_native_web_client.log_simulator_reload_config_query_client()

        try:
            system_control = SystemControlBaseModel.from_kwargs(_id=1, kill_switch=True)
            email_book_service_native_web_client.patch_system_control_client(
                system_control.to_dict(exclude_none=True))
        except Exception as e:
            if "bartering_link.trigger_kill_switch failed" not in str(e):
                raise Exception("Something went wrong while enabling kill_switch kill switch")
        else:
            assert False, ("Configured simulate config to return False from trigger_kill_switch to fail enable "
                           "kill switch, but patch went successful - check why simulate didn't work")

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        print(f"Some Error Occurred: exception: {e}, "
              f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        raise Exception(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))
        # updating simulator's configs
        email_book_service_native_web_client.log_simulator_reload_config_query_client()


@pytest.mark.nightly
def test_revoke_switch_fail(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_,
        symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list):
    config_file_path = STRAT_EXECUTOR / "data" / f"kill_switch_simulate_config.yaml"
    config_dict: Dict = YAMLConfigurationManager.load_yaml_configurations(config_file_path)
    config_dict_str = YAMLConfigurationManager.load_yaml_configurations(config_file_path, load_as_str=True)

    system_control = SystemControlBaseModel.from_kwargs(_id=1, kill_switch=True)
    updated_system_control = email_book_service_native_web_client.patch_system_control_client(
        system_control.to_dict(exclude_none=True))
    assert updated_system_control.kill_switch, "Unexpected: kill_switch is False, expected to be True"
    try:
        # updating yaml_configs according to this test
        config_dict["revoke_kill_switch_n_resume_bartering"] = False
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        email_book_service_native_web_client.log_simulator_reload_config_query_client()

        try:
            system_control = SystemControlBaseModel.from_kwargs(_id=1, kill_switch=False)
            email_book_service_native_web_client.patch_system_control_client(
                system_control.to_dict(exclude_none=True))
        except Exception as e:
            if "bartering_link.revoke_kill_switch_n_resume_bartering failed" not in str(e):
                raise Exception("Something went wrong while disabling kill_switch kill switch")
        else:
            assert False, ("Configured simulate config to return False from revoke_kill_switch_n_resume_bartering to "
                           "fail disable kill switch, but patch went successful - check why simulate didn't work")

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        print(f"Some Error Occurred: exception: {e}, "
              f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        raise Exception(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))
        # updating simulator's configs
        email_book_service_native_web_client.log_simulator_reload_config_query_client()


@pytest.mark.nightly
def test_simulated_partial_fills(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                                 pair_plan_, expected_plan_limits_,
                                 expected_plan_status_, symbol_overview_obj_list,
                                 last_barter_fixture_list, market_depth_basemodel_list,
                                 buy_chore_, sell_chore_,
                                 max_loop_count_per_side, refresh_sec_update_fixture):
    partial_filled_qty: int | None = None
    unfilled_amount: int | None = None
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    # updating fixture values for this test-case
    max_loop_count_per_side = 2
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:2]

    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        created_pair_plan, executor_http_client = (
            create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list,
                                               last_barter_fixture_list,
                                               market_depth_basemodel_list))

        config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(created_pair_plan.id)

        try:
            # updating yaml_configs according to this test
            for symbol in config_dict["symbol_configs"]:
                config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
                config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

            # updating simulator's configs
            executor_http_client.barter_simulator_reload_config_query_client()

            # buy fills check
            for check_symbol in [leg1_symbol, leg2_symbol]:
                chore_id = None
                total_partial_filled_qty = 0
                for loop_count in range(1, max_loop_count_per_side + 1):
                    chore_id, partial_filled_qty = \
                        underlying_handle_simulated_partial_fills_test(loop_count, check_symbol, leg1_symbol,
                                                                       leg2_symbol,
                                                                       last_barter_fixture_list,
                                                                       chore_id, config_dict,
                                                                       created_pair_plan, executor_http_client)
                    total_partial_filled_qty += partial_filled_qty
                    if not executor_config_yaml_dict.get("allow_multiple_unfilled_chore_pairs_per_plan"):
                        # Sleeping to let the chore get cxlled
                        time.sleep(residual_wait_sec)
                time.sleep(5)
                plan_status: PlanStatusBaseModel = executor_http_client.get_plan_status_client(created_pair_plan.id)
                if check_symbol == leg1_symbol:
                    assert total_partial_filled_qty == plan_status.total_fill_buy_qty, (
                        f"Unmatched total_fill_buy_qty: expected {total_partial_filled_qty} "
                        f"received {plan_status.total_fill_buy_qty}")
                else:
                    assert total_partial_filled_qty == plan_status.total_fill_sell_qty, (
                           f"Unmatched total_fill_sell_qty: expected {total_partial_filled_qty} "
                           f"received {plan_status.total_fill_sell_qty}")
        except AssertionError as e:
            raise AssertionError(e)
        except Exception as e:
            print(f"Some Error Occurred: exception: {e}, "
                  f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
            raise Exception(e)
        finally:
            YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_simulated_multi_partial_fills(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                                       pair_plan_, expected_plan_limits_,
                                       expected_plan_status_, symbol_overview_obj_list,
                                       last_barter_fixture_list, market_depth_basemodel_list,
                                       buy_chore_, sell_chore_,
                                       max_loop_count_per_side, refresh_sec_update_fixture):

    partial_filled_qty: int | None = None
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    # updating fixture values for this test-case
    max_loop_count_per_side = 2
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:2]

    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        created_pair_plan, executor_http_client = (
            create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list,
                                               last_barter_fixture_list, market_depth_basemodel_list))

        config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(created_pair_plan.id)

        try:
            # updating yaml_configs according to this test
            for symbol in config_dict["symbol_configs"]:
                config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
                config_dict["symbol_configs"][symbol]["fill_percent"] = 10
                config_dict["symbol_configs"][symbol]["total_fill_count"] = 5
            YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

            # updating simulator's configs
            executor_http_client.barter_simulator_reload_config_query_client()

            # buy fills check
            for check_symbol in [leg1_symbol, leg2_symbol]:
                chore_id = None
                for loop_count in range(1, max_loop_count_per_side + 1):
                    chore_id, partial_filled_qty = \
                        underlying_handle_simulated_multi_partial_fills_test(loop_count, check_symbol, leg1_symbol,
                                                                             leg2_symbol, created_pair_plan,
                                                                             last_barter_fixture_list, chore_id,
                                                                             executor_http_client, config_dict)
                    if not executor_config_yaml_dict.get("allow_multiple_unfilled_chore_pairs_per_plan"):
                        # Sleeping to let the chore get cxlled
                        time.sleep(residual_wait_sec)

                symbol_configs = get_symbol_configs(check_symbol, config_dict)
                plan_status: PlanStatusBaseModel = executor_http_client.get_plan_status_client(created_pair_plan.id)

                total_fill_qty = plan_status.total_fill_buy_qty \
                    if check_symbol == leg1_symbol else plan_status.total_fill_sell_qty
                expected_total_fill_qty = \
                    partial_filled_qty * max_loop_count_per_side * symbol_configs.get("total_fill_count")
                assert expected_total_fill_qty == total_fill_qty, "total_fill_qty mismatched: expected " \
                                                                  f"{expected_total_fill_qty} received " \
                                                                  f"{total_fill_qty}"
        except AssertionError as e:
            raise AssertionError(e)
        except Exception as e:
            print(f"Some Error Occurred: exception: {e}, "
                  f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
            raise Exception(e)
        finally:
            YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_filled_status(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                       pair_plan_, expected_plan_limits_,
                       expected_plan_status_, symbol_overview_obj_list,
                       last_barter_fixture_list, market_depth_basemodel_list,
                       buy_chore_, sell_chore_, refresh_sec_update_fixture):
        buy_symbol = leg1_leg2_symbol_list[0][0]
        sell_symbol = leg1_leg2_symbol_list[0][1]
        expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture

        (created_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
         config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
            buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
            expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
            market_depth_basemodel_list)

        try:
            # updating yaml_configs according to this test
            for symbol in config_dict["symbol_configs"]:
                config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
                config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

            # updating simulator's configs
            executor_http_client.barter_simulator_reload_config_query_client()

            # buy fills check
            run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)

            px = 100
            qty = 90
            place_new_chore(buy_symbol, Side.BUY, px, qty, executor_http_client, buy_inst_type)
            time.sleep(2)  # delay for chore to get placed

            ack_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, buy_symbol,
                                                                               executor_http_client)
            latest_fill_journal = get_latest_fill_journal_from_chore_id(ack_chore_journal.chore.chore_id,
                                                                        executor_http_client)
            last_fill_date_time = latest_fill_journal.fill_date_time
            filled_qty = get_partial_allowed_fill_qty(buy_symbol, config_dict, ack_chore_journal.chore.qty)
            assert latest_fill_journal.fill_qty == filled_qty, f"filled_qty mismatched: expected filled_qty {filled_qty} " \
                                                               f"received {latest_fill_journal.fill_qty}"
            chore_snapshot = get_chore_snapshot_from_chore_id(ack_chore_journal.chore.chore_id, executor_http_client)
            assert chore_snapshot.chore_status == ChoreStatusType.OE_ACKED, "ChoreStatus mismatched: expected status " \
                                                                            f"ChoreStatusType.OE_ACKED received " \
                                                                            f"{chore_snapshot.chore_status}"

            # processing remaining 50% fills
            executor_http_client.barter_simulator_process_fill_query_client(
                ack_chore_journal.chore.chore_id, ack_chore_journal.chore.px,
                ack_chore_journal.chore.qty, ack_chore_journal.chore.side,
                ack_chore_journal.chore.security.sec_id, ack_chore_journal.chore.underlying_account)
            latest_fill_journal = get_latest_fill_journal_from_chore_id(ack_chore_journal.chore.chore_id,
                                                                        executor_http_client)
            assert latest_fill_journal.fill_date_time != last_fill_date_time, "last_fill_date_time mismatched: " \
                                                                              f"expected {latest_fill_journal} " \
                                                                              f"received " \
                                                                              f"{latest_fill_journal.fill_date_time}"
            assert latest_fill_journal.fill_qty == filled_qty, f"fill_qty mismatched: expected {filled_qty} " \
                                                               f"received {latest_fill_journal.fill_qty}"

            chore_snapshot = get_chore_snapshot_from_chore_id(ack_chore_journal.chore.chore_id, executor_http_client)
            assert chore_snapshot.chore_status == ChoreStatusType.OE_FILLED, "ChoreStatus mismatched: expected status " \
                                                                             f"ChoreStatusType.OE_FILLED received " \
                                                                             f"{chore_snapshot.chore_status}"
        except AssertionError as e:
            raise AssertionError(e)
        except Exception as e:
            print(f"Some Error Occurred: exception: {e}, "
                  f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
            raise Exception(e)
        finally:
            YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


def _check_over_fill_computes(sell_symbol, created_pair_plan, executor_http_client, chore_journal,
                              latest_fill_journal, chore_snapshot_before_over_fill, expected_plan_limits_):
    # Checking if plan went to pause
    pair_plan = email_book_service_native_web_client.get_pair_plan_client(created_pair_plan.id)
    assert pair_plan.plan_state == PlanState.PlanState_PAUSED, \
        f"Expected Plan to be Paused, found state: {pair_plan.plan_state}, pair_plan: {pair_plan}"

    chore_snapshot = get_chore_snapshot_from_chore_id(chore_journal.chore.chore_id, executor_http_client)
    assert chore_snapshot.chore_status == ChoreStatusType.OE_OVER_FILLED, \
        f"ChoreStatus mismatched: expected status {ChoreStatusType.OE_OVER_FILLED} received " \
        f"{chore_snapshot.chore_status}"
    assert chore_snapshot.filled_qty == chore_snapshot_before_over_fill.filled_qty + latest_fill_journal.fill_qty, \
        ("chore_snapshot filled_qty mismatch: expected chore_snapshot filled_qty: "
         f"{chore_snapshot_before_over_fill.filled_qty + latest_fill_journal.fill_qty} "
         f"but found {chore_snapshot.filled_qty = }")
    assert chore_snapshot.fill_notional == chore_snapshot.filled_qty * get_px_in_usd(latest_fill_journal.fill_px), \
        ("chore_snapshot filled_qty mismatch: expected chore_snapshot fill_notional: "
         f"{chore_snapshot.filled_qty * get_px_in_usd(latest_fill_journal.fill_px)} "
         f"but found {chore_snapshot.fill_notional = }")

    symbol_side_snapshot_list = (
        executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
            chore_snapshot.chore_brief.security.sec_id, chore_snapshot.chore_brief.side))
    assert len(symbol_side_snapshot_list) == 1, \
        (f"found {len(symbol_side_snapshot_list) = }, must be exact 1 for symbol and side: "
         f"{chore_snapshot.chore_brief.security.sec_id, chore_snapshot.chore_brief.side}")

    symbol_side_snapshot = symbol_side_snapshot_list[0]
    assert symbol_side_snapshot.total_filled_qty == chore_snapshot.filled_qty, \
        (f"Mismatched: expected symbol_side_snapshot total_filled_qty: {chore_snapshot.filled_qty}, "
         f"found: {symbol_side_snapshot.total_filled_qty = }")

    plan_brief = executor_http_client.get_plan_brief_client(created_pair_plan.id)
    assert plan_brief.pair_buy_side_bartering_brief.open_qty == 0, \
        (f"Mismatched: expected buy_side_bartering_brief open_qty: 0, "
         f"found: {plan_brief.pair_buy_side_bartering_brief.open_qty = }")
    assert plan_brief.pair_buy_side_bartering_brief.open_notional == 0, \
        ("Mismatched: expected plan_brief.pair_buy_side_bartering_brief.open_notional: 0, "
         f"found: {plan_brief.pair_buy_side_bartering_brief.open_notional = }")

    # only leg1 chores were placed so no hedge ratio is required in consumable_notional
    consumable_notional = (expected_plan_limits_.max_single_leg_notional -
                           symbol_side_snapshot.total_fill_notional)
    assert plan_brief.pair_buy_side_bartering_brief.consumable_notional == consumable_notional, \
        (f"Mismatched: expected plan_brief.pair_buy_side_bartering_brief.consumable_notional: {consumable_notional}, "
         f"found: {plan_brief.pair_buy_side_bartering_brief.consumable_notional=}")
    total_security_size: int = \
        static_data.get_security_float_from_ticker(chore_snapshot.chore_brief.security.sec_id)
    consumable_concentration = ((total_security_size / 100 * expected_plan_limits_.max_concentration) -
                                symbol_side_snapshot.total_filled_qty)
    assert plan_brief.pair_buy_side_bartering_brief.consumable_concentration == consumable_concentration, \
        (f"Mismatched: expected plan_brief.pair_buy_side_bartering_brief.consumable_concentration: "
         f"{consumable_concentration}, found: {plan_brief.pair_buy_side_bartering_brief.consumable_concentration=}")
    consumable_cxl_qty = \
        (((symbol_side_snapshot.total_filled_qty + symbol_side_snapshot.total_cxled_qty) / 100) *
         expected_plan_limits_.cancel_rate.max_cancel_rate) - symbol_side_snapshot.total_cxled_qty
    assert plan_brief.pair_buy_side_bartering_brief.consumable_cxl_qty == consumable_cxl_qty, \
        (f"Mismatched: expected plan_brief.pair_buy_side_bartering_brief.consumable_cxl_qty: "
         f"{consumable_cxl_qty}, found: {plan_brief.pair_buy_side_bartering_brief.consumable_cxl_qty=}")
    sell_symbol_side_snapshot_list = (
        executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(sell_symbol, Side.SELL))
    sell_symbol_side_snapshot = sell_symbol_side_snapshot_list[0]
    consumable_nett_filled_notional = (expected_plan_limits_.max_net_filled_notional -
                                       abs(symbol_side_snapshot.total_fill_notional -
                                           sell_symbol_side_snapshot.total_fill_notional))
    assert (plan_brief.consumable_nett_filled_notional ==
            consumable_nett_filled_notional), \
        (f"Mismatched: expected plan_brief.consumable_nett_filled_notional: "
         f"{consumable_nett_filled_notional}, found: "
         f"{plan_brief.consumable_nett_filled_notional=}")

    plan_status = executor_http_client.get_plan_status_client(created_pair_plan.id)
    assert plan_status.total_open_buy_qty == 0, \
        (f"Mismatched: expected plan_status.total_open_buy_qty: 0, "
         f"found: {plan_status.total_open_buy_qty=}")
    assert plan_status.total_open_buy_notional == 0, \
        (f"Mismatched: expected plan_status.total_open_buy_notional: 0, "
         f"found: {plan_status.total_open_buy_notional=}")
    assert plan_status.total_fill_buy_qty == chore_snapshot.filled_qty, \
        (f"Mismatched: expected plan_status.total_fill_buy_qty: {chore_snapshot.filled_qty}, "
         f"found: {plan_status.total_fill_buy_qty=}")
    assert (plan_status.total_fill_buy_notional ==
            chore_snapshot.filled_qty * get_px_in_usd(chore_snapshot.last_update_fill_px)), \
        (f"Mismatched: expected plan_status.total_fill_buy_notional: {chore_snapshot.filled_qty}, "
         f"found: {plan_status.total_fill_buy_notional=}")

    contact_status = email_book_service_native_web_client.get_contact_status_client(1)
    assert (contact_status.overall_buy_notional ==
            (chore_snapshot_before_over_fill.last_update_fill_qty *
             get_px_in_usd(chore_snapshot_before_over_fill.last_update_fill_px) +
             chore_snapshot.last_update_fill_qty * get_px_in_usd(chore_snapshot.last_update_fill_px)))


@pytest.mark.nightly
def test_over_fill(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
                   expected_plan_status_, symbol_overview_obj_list,
                   last_barter_fixture_list, market_depth_basemodel_list,
                   buy_chore_, sell_chore_, refresh_sec_update_fixture):
    """
    Test case when chore_snapshot is in OE_ACKED and fill is triggered to make it over_filled
    """
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture

    created_pair_plan, executor_http_client = (
        create_pre_chore_test_requirements(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                           market_depth_basemodel_list))

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(created_pair_plan.id)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 60
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        bid_buy_top_market_depth, ask_sell_top_market_depth = (
            get_buy_bid_n_ask_sell_market_depth(buy_symbol, sell_symbol, created_pair_plan))

        # buy fills check
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
        time.sleep(1)
        update_tob_through_market_depth_to_place_buy_chore(created_pair_plan.cpp_port, bid_buy_top_market_depth,
                                                           ask_sell_top_market_depth)
        time.sleep(2)  # delay for chore to get placed

        ack_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, buy_symbol,
                                                                           executor_http_client)
        latest_fill_journal = get_latest_fill_journal_from_chore_id(ack_chore_journal.chore.chore_id,
                                                                    executor_http_client)
        last_fill_date_time = latest_fill_journal.fill_date_time
        filled_qty = get_partial_allowed_fill_qty(buy_symbol, config_dict, ack_chore_journal.chore.qty)
        assert latest_fill_journal.fill_qty == filled_qty, f"fill_qty mismatched: expected {filled_qty} " \
                                                           f"received {latest_fill_journal.fill_qty}"
        chore_snapshot_before_over_fill = (
            get_chore_snapshot_from_chore_id(ack_chore_journal.chore.chore_id, executor_http_client))
        assert chore_snapshot_before_over_fill.chore_status == ChoreStatusType.OE_ACKED, \
            "ChoreStatus mismatched: expected status ChoreStatusType.OE_ACKED received " \
            f"{chore_snapshot_before_over_fill.chore_status}"

        # processing fill for over_fill
        executor_http_client.barter_simulator_process_fill_query_client(
            ack_chore_journal.chore.chore_id, ack_chore_journal.chore.px,
            ack_chore_journal.chore.qty, ack_chore_journal.chore.side,
            ack_chore_journal.chore.security.sec_id, ack_chore_journal.chore.underlying_account)
        latest_fill_journal = get_latest_fill_journal_from_chore_id(ack_chore_journal.chore.chore_id,
                                                                    executor_http_client)
        assert latest_fill_journal.fill_date_time != last_fill_date_time, "last_fill_date_time mismatched: " \
                                                                          f"expected {latest_fill_journal} " \
                                                                          f"received " \
                                                                          f"{latest_fill_journal.fill_date_time}"
        assert latest_fill_journal.fill_qty == filled_qty, f"fill_qty mismatched: expected {filled_qty} " \
                                                           f"received {latest_fill_journal.fill_qty}"

        _check_over_fill_computes(sell_symbol, created_pair_plan, executor_http_client, ack_chore_journal,
                                  latest_fill_journal, chore_snapshot_before_over_fill, expected_plan_limits_)

        time.sleep(5)
        check_str = "Unexpected: Received fill that will make chore_snapshot OVER_FILLED"
        assert_fail_msg = f"Couldn't find any alert saying: {check_str}"
        check_alert_str_in_plan_alerts_n_contact_alerts(created_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        print(f"Some Error Occurred: exception: {e}, "
              f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        raise Exception(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_over_fill_after_fulfill(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, refresh_sec_update_fixture):
    """
    Test case when chore_snapshot is in OE_FILLED and fill is triggered to make it over_filled - fill after FILLED
    must be ignored and plan must be PAUSED with alert
    """
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture

    created_pair_plan, executor_http_client = (
        create_pre_chore_test_requirements(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                           market_depth_basemodel_list))

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(created_pair_plan.id)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 100
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        bid_buy_top_market_depth, ask_sell_top_market_depth = (
            get_buy_bid_n_ask_sell_market_depth(buy_symbol, sell_symbol, created_pair_plan))

        # buy fills check
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
        time.sleep(1)
        update_tob_through_market_depth_to_place_buy_chore(created_pair_plan.cpp_port, bid_buy_top_market_depth,
                                                           ask_sell_top_market_depth)
        time.sleep(5)  # delay for chore to get placed

        ack_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, buy_symbol,
                                                                           executor_http_client)
        latest_fill_journal = get_latest_fill_journal_from_chore_id(ack_chore_journal.chore.chore_id,
                                                                    executor_http_client)
        last_fill_date_time = latest_fill_journal.fill_date_time
        filled_qty = get_partial_allowed_fill_qty(buy_symbol, config_dict, ack_chore_journal.chore.qty)
        assert latest_fill_journal.fill_qty == filled_qty, f"fill_qty mismatched: expected {filled_qty} " \
                                                           f"received {latest_fill_journal.fill_qty}"
        chore_snapshot_before_over_fill = get_chore_snapshot_from_chore_id(ack_chore_journal.chore.chore_id,
                                                                           executor_http_client)
        assert chore_snapshot_before_over_fill.filled_qty == chore_snapshot_before_over_fill.chore_brief.qty, \
            ("chore_snapshot filled_qty mismatch: expected complete fill, i.e., "
             f"{chore_snapshot_before_over_fill.chore_brief.qty} received {chore_snapshot_before_over_fill.filled_qty}")
        assert chore_snapshot_before_over_fill.chore_status == ChoreStatusType.OE_FILLED, \
            (f"ChoreStatus mismatched: expected status ChoreStatusType.OE_FILLED received "
             f"{chore_snapshot_before_over_fill.chore_status = }")

        # processing fill for over_fill
        executor_http_client.barter_simulator_process_fill_query_client(
            ack_chore_journal.chore.chore_id, ack_chore_journal.chore.px,
            ack_chore_journal.chore.qty, ack_chore_journal.chore.side,
            ack_chore_journal.chore.security.sec_id, ack_chore_journal.chore.underlying_account)
        time.sleep(2)
        latest_fill_journal = get_latest_fill_journal_from_chore_id(ack_chore_journal.chore.chore_id,
                                                                    executor_http_client)
        assert latest_fill_journal.fill_date_time != last_fill_date_time, \
            "last_fill_date_time mismatched: expected {latest_fill_journal} received " \
            f"{latest_fill_journal.fill_date_time}"
        assert latest_fill_journal.fill_qty == filled_qty, f"fill_qty mismatched: expected {filled_qty} " \
                                                           f"received {latest_fill_journal.fill_qty}"

        chore_snapshot_after_over_fill = get_chore_snapshot_from_chore_id(ack_chore_journal.chore.chore_id,
                                                                          executor_http_client)
        assert chore_snapshot_after_over_fill.chore_status == ChoreStatusType.OE_FILLED, \
            (f"ChoreStatus mismatched: expected status ChoreStatusType.OE_FILLED received "
             f"{chore_snapshot_after_over_fill.chore_status = }")

        # Checking if plan went to pause
        pair_plan = email_book_service_native_web_client.get_pair_plan_client(created_pair_plan.id)
        assert pair_plan.plan_state == PlanState.PlanState_PAUSED, \
            f"Expected Plan to be Paused, found state: {pair_plan.plan_state}, pair_plan: {pair_plan}"

        time.sleep(5)
        check_str = "Unsupported - Fill received for completely filled chore_snapshot"
        assert_fail_msg = f"Couldn't find any alert saying: {check_str}"
        check_alert_str_in_plan_alerts_n_contact_alerts(created_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        print(f"Some Error Occurred: exception: {e}, "
              f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        raise Exception(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_ack_to_rej_chores(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                           expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
                           last_barter_fixture_list, market_depth_basemodel_list,
                           max_loop_count_per_side, refresh_sec_update_fixture):
    # updating fixture values for this test-case
    max_loop_count_per_side = 5
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:2]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        # explicitly setting waived_initial_chores to 10 for this test case
        expected_plan_limits_.cancel_rate.waived_initial_chores = 10
        created_pair_plan, executor_http_client = (
            create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list,
                                               last_barter_fixture_list, market_depth_basemodel_list))

        config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(created_pair_plan.id)

        try:
            # updating yaml_configs according to this test
            for symbol in config_dict["symbol_configs"]:
                config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
                config_dict["symbol_configs"][symbol]["fill_percent"] = 50
                config_dict["symbol_configs"][symbol]["simulate_ack_to_reject_chores"] = True
            YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

            # updating simulator's configs
            executor_http_client.barter_simulator_reload_config_query_client()

            handle_rej_chore_test(leg1_symbol, leg2_symbol, created_pair_plan, expected_plan_limits_,
                                  last_barter_fixture_list, max_loop_count_per_side,
                                  True, executor_http_client, config_dict, residual_wait_sec)
        except AssertionError as e:
            raise AssertionError(e)
        except Exception as e:
            err_str_ = (f"Some Error Occurred: exception: {e}, "
                       f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
            print(err_str_)
            raise Exception(err_str_)
        finally:
            YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_unack_to_rej_chores(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                             expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
                             last_barter_fixture_list, market_depth_basemodel_list,
                             max_loop_count_per_side, refresh_sec_update_fixture):
    # updating fixture values for this test-case
    max_loop_count_per_side = 5
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:2]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        # explicitly setting waived_initial_chores to 10 for this test case
        expected_plan_limits_.cancel_rate.waived_initial_chores = 10
        created_pair_plan, executor_http_client = (
            create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list,
                                               last_barter_fixture_list, market_depth_basemodel_list))

        config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(created_pair_plan.id)

        try:
            # updating yaml_configs according to this test
            for symbol in config_dict["symbol_configs"]:
                config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
                config_dict["symbol_configs"][symbol]["fill_percent"] = 50
                config_dict["symbol_configs"][symbol]["simulate_new_to_reject_chores"] = True
            YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

            # updating simulator's configs
            executor_http_client.barter_simulator_reload_config_query_client()

            handle_rej_chore_test(leg1_symbol, leg2_symbol, created_pair_plan, expected_plan_limits_,
                                  last_barter_fixture_list, max_loop_count_per_side,
                                  False, executor_http_client, config_dict, residual_wait_sec)
        except AssertionError as e:
            raise AssertionError(e)
        except Exception as e:
            err_str_ = (f"Some Error Occurred: exception: {e}, "
                        f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
            print(err_str_)
            raise Exception(err_str_)
        finally:
            YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_cxl_rej_n_revert_to_acked(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                                   pair_plan_, expected_plan_limits_,
                                   expected_plan_status_, symbol_overview_obj_list,
                                   last_barter_fixture_list, market_depth_basemodel_list,
                                   buy_chore_, sell_chore_,
                                   max_loop_count_per_side, refresh_sec_update_fixture):
    # updating fixture values for this test-case
    max_loop_count_per_side = 5
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:2]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture

    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        created_pair_plan, executor_http_client = (
            create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list,
                                               last_barter_fixture_list,
                                               market_depth_basemodel_list))

        config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(created_pair_plan.id)

        try:
            # updating yaml_configs according to this test
            for symbol in config_dict["symbol_configs"]:
                config_dict["symbol_configs"][symbol]["simulate_ack_to_cxl_rej_chores"] = True
                config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
                config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

            # updating simulator's configs
            executor_http_client.barter_simulator_reload_config_query_client()

            bid_buy_top_market_depth, ask_sell_top_market_depth = (
                get_buy_bid_n_ask_sell_market_depth(leg1_symbol, leg2_symbol, created_pair_plan))

            for check_symbol in [leg1_symbol, leg2_symbol]:
                continues_chore_count, continues_special_chore_count = get_continuous_chore_configs(check_symbol,
                                                                                                    config_dict)
                chore_count = 0
                special_chore_count = 0
                last_cxl_chore_id = None
                last_cxl_rej_chore_id = None
                for loop_count in range(1, max_loop_count_per_side + 1):
                    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
                    if check_symbol == leg1_symbol:
                        time.sleep(1)
                        update_tob_through_market_depth_to_place_buy_chore(created_pair_plan.cpp_port,
                                                                           bid_buy_top_market_depth,
                                                                           ask_sell_top_market_depth)
                    else:
                        # required to make buy side tob latest
                        run_last_barter(leg1_symbol, leg2_symbol, [last_barter_fixture_list[0]], created_pair_plan.cpp_port)

                        update_tob_through_market_depth_to_place_sell_chore(created_pair_plan.cpp_port,
                                                                            ask_sell_top_market_depth,
                                                                            bid_buy_top_market_depth)
                    time.sleep(10)  # delay for chore to get placed and trigger cxl

                    if chore_count < continues_chore_count:
                        check_chore_event = ChoreEventType.OE_CXL_ACK
                        chore_count += 1
                    else:
                        if special_chore_count < continues_special_chore_count:
                            check_chore_event = "REJ"
                            special_chore_count += 1
                        else:
                            check_chore_event = ChoreEventType.OE_CXL_ACK
                            chore_count = 1
                            special_chore_count = 0

                    # internally contains assert statements
                    last_cxl_chore_id, last_cxl_rej_chore_id = verify_cxl_rej(last_cxl_chore_id, last_cxl_rej_chore_id,
                                                                              check_chore_event, check_symbol,
                                                                              executor_http_client,
                                                                              ChoreStatusType.OE_ACKED)
        except AssertionError as e:
            raise AssertionError(e)
        except Exception as e:
            err_str_ = (f"Some Error Occurred: exception: {e}, "
                        f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
            print(err_str_)
            raise Exception(err_str_)
        finally:
            YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_cxl_rej_n_revert_to_unack(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                                   pair_plan_, expected_plan_limits_,
                                   expected_plan_status_, symbol_overview_obj_list,
                                   last_barter_fixture_list, market_depth_basemodel_list,
                                   buy_chore_, sell_chore_,
                                   max_loop_count_per_side, refresh_sec_update_fixture):
    # updating fixture values for this test-case
    max_loop_count_per_side = 5
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:2]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture

    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        created_pair_plan, executor_http_client = (
            create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list,
                                               last_barter_fixture_list,
                                               market_depth_basemodel_list))

        config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(created_pair_plan.id)

        try:
            # updating yaml_configs according to this test
            for symbol in config_dict["symbol_configs"]:
                config_dict["symbol_configs"][symbol]["simulate_new_to_cxl_rej_chores"] = True
                config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
                config_dict["symbol_configs"][symbol]["fill_percent"] = 50

            YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

            # updating simulator's configs
            executor_http_client.barter_simulator_reload_config_query_client()

            bid_buy_top_market_depth, ask_sell_top_market_depth = (
                get_buy_bid_n_ask_sell_market_depth(leg1_symbol, leg2_symbol, created_pair_plan))

            for check_symbol in [leg1_symbol, leg2_symbol]:
                continues_chore_count, continues_special_chore_count = get_continuous_chore_configs(check_symbol,
                                                                                                    config_dict)
                chore_count = 0
                special_chore_count = 0
                last_cxl_chore_id = None
                last_cxl_rej_chore_id = None
                for loop_count in range(1, max_loop_count_per_side + 1):
                    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
                    if check_symbol == leg1_symbol:
                        time.sleep(1)
                        update_tob_through_market_depth_to_place_buy_chore(created_pair_plan.cpp_port,
                                                                           bid_buy_top_market_depth,
                                                                           ask_sell_top_market_depth)
                    else:
                        # required to make buy side tob latest
                        run_last_barter(leg1_symbol, leg2_symbol, [last_barter_fixture_list[0]], created_pair_plan.cpp_port)

                        update_tob_through_market_depth_to_place_sell_chore(created_pair_plan.cpp_port,
                                                                            ask_sell_top_market_depth,
                                                                            bid_buy_top_market_depth)
                    time.sleep(10)  # delay for chore to get placed and trigger cxl

                    if chore_count < continues_chore_count:
                        check_chore_event = ChoreEventType.OE_CXL_ACK
                        chore_count += 1
                    else:
                        if special_chore_count < continues_special_chore_count:
                            check_chore_event = "REJ"
                            special_chore_count += 1
                        else:
                            check_chore_event = ChoreEventType.OE_CXL_ACK
                            chore_count = 1
                            special_chore_count = 0

                    # internally contains assert statements
                    last_cxl_chore_id, last_cxl_rej_chore_id = verify_cxl_rej(last_cxl_chore_id, last_cxl_rej_chore_id,
                                                                              check_chore_event, check_symbol,
                                                                              executor_http_client,
                                                                              ChoreStatusType.OE_UNACK)
        except AssertionError as e:
            raise AssertionError(e)
        except Exception as e:
            err_str_ = (f"Some Error Occurred: exception: {e}, "
                        f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
            print(err_str_)
            raise Exception(err_str_)
        finally:
            YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_cxl_rej_n_revert_to_filled(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                                    pair_plan_, expected_plan_limits_,
                                    expected_plan_status_, symbol_overview_obj_list,
                                    last_barter_fixture_list, market_depth_basemodel_list,
                                    buy_chore_, sell_chore_,
                                    max_loop_count_per_side, refresh_sec_update_fixture):
    # updating fixture values for this test-case
    max_loop_count_per_side = 5
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:2]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture

    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
         config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
            leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
            expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
            market_depth_basemodel_list)

        try:
            # updating yaml_configs according to this test
            for symbol in config_dict["symbol_configs"]:
                config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
                config_dict["symbol_configs"][symbol]["fill_percent"] = 50
                config_dict["symbol_configs"][symbol]["force_fully_fill"] = True
                config_dict["symbol_configs"][symbol]["simulate_ack_to_cxl_rej_chores"] = True

            YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

            # updating simulator's configs
            executor_http_client.barter_simulator_reload_config_query_client()

            for check_symbol in [leg1_symbol, leg2_symbol]:
                continues_chore_count, continues_special_chore_count = get_continuous_chore_configs(check_symbol,
                                                                                                    config_dict)
                chore_count = 0
                special_chore_count = 0
                last_cxl_chore_id = None
                last_cxl_rej_chore_id = None
                for loop_count in range(1, max_loop_count_per_side + 1):
                    run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
                    if check_symbol == leg1_symbol:
                        px = 100
                        qty = 90
                        place_new_chore(leg1_symbol, Side.BUY, px, qty, executor_http_client, buy_inst_type)
                    else:
                        px = 110
                        qty = 94
                        place_new_chore(leg2_symbol, Side.SELL, px, qty, executor_http_client, sell_inst_type)
                    time.sleep(10)  # delay for chore to get placed and trigger cxl

                    if chore_count < continues_chore_count:
                        check_chore_event = ChoreEventType.OE_CXL_ACK
                        chore_count += 1
                    else:
                        if special_chore_count < continues_special_chore_count:
                            check_chore_event = "REJ"
                            special_chore_count += 1
                        else:
                            check_chore_event = ChoreEventType.OE_CXL_ACK
                            chore_count = 1
                            special_chore_count = 0

                    # internally contains assert statements
                    if check_chore_event == "REJ":
                        # internally checks chore_journal is not None else raises assert exception internally
                        latest_cxl_rej_chore_journal = \
                            get_latest_chore_journal_with_events_and_symbol([ChoreEventType.OE_CXL_INT_REJ,
                                                                             ChoreEventType.OE_CXL_BRK_REJ,
                                                                             ChoreEventType.OE_CXL_EXH_REJ],
                                                                            check_symbol, executor_http_client,
                                                                            last_chore_id=last_cxl_rej_chore_id)
                        last_cxl_rej_chore_id = latest_cxl_rej_chore_journal.chore.chore_id

                        chore_snapshot = get_chore_snapshot_from_chore_id(latest_cxl_rej_chore_journal.chore.chore_id,
                                                                          executor_http_client)
                        assert chore_snapshot.chore_status == ChoreStatusType.OE_FILLED, \
                            f"Unexpected chore_snapshot.chore_status: expected {ChoreStatusType.OE_FILLED}, " \
                            f"received {chore_snapshot.chore_status}"
                    else:
                        # checks chore_journal is not None else raises assert exception internally
                        latest_cxl_chore_journal = get_latest_chore_journal_with_event_and_symbol(
                            ChoreEventType.OE_CXL_ACK, check_symbol, executor_http_client,
                            last_chore_id=last_cxl_chore_id)
                        last_cxl_chore_id = latest_cxl_chore_journal.chore.chore_id

        except AssertionError as e:
            raise AssertionError(e)
        except Exception as e:
            err_str_ = (f"Some Error Occurred: exception: {e}, "
                        f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
            print(err_str_)
            raise Exception(err_str_)
        finally:
            YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


def test_no_cxl_req_from_residual_refresh_is_state_already_cxl_req(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
        pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list,
        market_depth_basemodel_list, last_barter_fixture_list,
        refresh_sec_update_fixture):
    # creating plan
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    max_loop_count_per_side = 2
    residual_wait_sec = 4 * refresh_sec_update_fixture
    created_pair_plan, executor_http_client = (
        create_pre_chore_test_requirements(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list,
                                           last_barter_fixture_list,
                                           market_depth_basemodel_list))

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(created_pair_plan.id)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["avoid_cxl_ack_after_cxl_req"] = True

        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        bid_buy_top_market_depth, ask_sell_top_market_depth = (
            get_buy_bid_n_ask_sell_market_depth(buy_symbol, sell_symbol, created_pair_plan))

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
        time.sleep(1)
        update_tob_through_market_depth_to_place_buy_chore(created_pair_plan.cpp_port, bid_buy_top_market_depth,
                                                           ask_sell_top_market_depth)

        cxl_req_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL,
                                                                               buy_symbol, executor_http_client)
        time.sleep(residual_wait_sec)
        get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL,
                                                       buy_symbol, executor_http_client, expect_no_chore=True,
                                                       last_chore_id=cxl_req_chore_journal.chore.chore_id)
    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_alert_handling_for_pair_plan(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                                       pair_plan_, expected_plan_limits_,
                                       expected_plan_status_, symbol_overview_obj_list,
                                       market_depth_basemodel_list):
    # creating plan
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    total_loop_count = 5
    active_pair_plan, executor_http_client = create_n_activate_plan(buy_symbol, sell_symbol, pair_plan_,
                                                                      expected_plan_limits_, expected_plan_status_,
                                                                      symbol_overview_obj_list,
                                                                      market_depth_basemodel_list)
    broker_id_list = []
    for loop_count in range(total_loop_count):
        broker = broker_fixture()
        broker.id = Broker.next_id()

        plan_limits: PlanLimitsBaseModel = PlanLimitsBaseModel.from_kwargs(_id=active_pair_plan.id,
                                                                              eligible_brokers=[broker])
        updated_plan_limits = executor_http_client.patch_plan_limits_client(
            plan_limits.to_dict(exclude_none=True))

        assert broker in updated_plan_limits.eligible_brokers, f"couldn't find {broker} in " \
                                                                f"eligible_brokers list " \
                                                                f"{updated_plan_limits.eligible_brokers}"
        broker_id_list.append(broker.id)

    # deleting broker
    for broker_id in broker_id_list:
        delete_intended_broker = BrokerBaseModel(id=broker_id)
        plan_limits: PlanLimitsBaseModel = PlanLimitsBaseModel.from_kwargs(_id=active_pair_plan.id,
                                                                  eligible_brokers=[delete_intended_broker])
        updated_plan_limits = executor_http_client.patch_plan_limits_client(
            plan_limits.to_dict(exclude_none=True))

        broker_id_list = [broker.id for broker in updated_plan_limits.eligible_brokers]
        assert broker_id not in broker_id_list, f"Unexpectedly found broker_id {broker_id} in broker_id list " \
                                                f"{broker_id_list}"


@pytest.mark.nightly
def test_underlying_account_cumulative_fill_qty_query(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                                                      pair_plan_, expected_plan_limits_,
                                                      expected_plan_status_, symbol_overview_obj_list,
                                                      last_barter_fixture_list, market_depth_basemodel_list,
                                                      refresh_sec_update_fixture):
    underlying_account_prefix: str = "Acc"
    buy_tob_last_update_date_time_tracker: DateTime | None = None
    sell_tob_last_update_date_time_tracker: DateTime | None = None
    buy_chore_id = None
    sell_chore_id = None
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:2]
    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
        residual_wait_sec = 4 * refresh_sec_update_fixture
        active_pair_plan, executor_http_client = (
            create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list,
                                               last_barter_fixture_list, market_depth_basemodel_list))

        bid_buy_top_market_depth, ask_sell_top_market_depth = (
            get_buy_bid_n_ask_sell_market_depth(leg1_symbol, leg2_symbol, active_pair_plan))

        # buy handling
        buy_tob_last_update_date_time_tracker, buy_chore_id = \
            create_fills_for_underlying_account_test(leg1_symbol, leg2_symbol, active_pair_plan,
                                                     buy_tob_last_update_date_time_tracker, buy_chore_id,
                                                     underlying_account_prefix, Side.BUY, executor_http_client,
                                                     bid_buy_top_market_depth, ask_sell_top_market_depth,
                                                     last_barter_fixture_list)

        time.sleep(residual_wait_sec)   #

        # sell handling
        sell_tob_last_update_date_time_tracker, sell_chore_id = \
            create_fills_for_underlying_account_test(leg1_symbol, leg2_symbol, active_pair_plan,
                                                     sell_tob_last_update_date_time_tracker, sell_chore_id,
                                                     underlying_account_prefix, Side.SELL, executor_http_client,
                                                     bid_buy_top_market_depth, ask_sell_top_market_depth,
                                                     last_barter_fixture_list)

        for symbol, side in [(leg1_symbol, "BUY"), (leg2_symbol, "SELL")]:
            underlying_account_cumulative_fill_qty_obj_list = \
                executor_http_client.get_underlying_account_cumulative_fill_qty_query_client(symbol, side)
            assert len(underlying_account_cumulative_fill_qty_obj_list) == 1, \
                "Expected exactly one obj from query get_underlying_account_cumulative_fill_qty_query_client," \
                f"received {len(underlying_account_cumulative_fill_qty_obj_list)}, received list " \
                f"{underlying_account_cumulative_fill_qty_obj_list}"
            assert len(
                underlying_account_cumulative_fill_qty_obj_list[0].underlying_account_n_cumulative_fill_qty) == 2, \
                "length of list field underlying_account_n_cumulative_fill_qty of " \
                "underlying_account_cumulative_fill_qty_obj mismatched, expected 2 received " \
                f"{len(underlying_account_cumulative_fill_qty_obj_list[0].underlying_account_n_cumulative_fill_qty)}"

            underlying_account_count = 2
            for loop_count in range(underlying_account_count):
                underlying_account_n_cum_fill_qty_obj = \
                    underlying_account_cumulative_fill_qty_obj_list[0].underlying_account_n_cumulative_fill_qty[
                        loop_count]
                assert underlying_account_n_cum_fill_qty_obj.underlying_account == \
                       f"{underlying_account_prefix}_{underlying_account_count - loop_count}", \
                       "underlying_account string field of underlying_account_n_cum_fill_qty_obj mismatched: " \
                       f"expected {underlying_account_prefix}_{underlying_account_count - loop_count} " \
                       f"received {underlying_account_n_cum_fill_qty_obj.underlying_account}"
                assert underlying_account_n_cum_fill_qty_obj.cumulative_qty == 15, \
                    "Unexpected cumulative qty: expected 15 received " \
                    f"{underlying_account_n_cum_fill_qty_obj.cumulative_qty}"


@pytest.mark.nightly
def test_last_n_sec_chore_qty_sum(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                                  pair_plan_, expected_plan_limits_,
                                  expected_plan_status_, symbol_overview_obj_list,
                                  last_barter_fixture_list, market_depth_basemodel_list,
                                  buy_fill_journal_, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    total_chore_count_for_each_side = 5
    expected_plan_limits_ = copy.deepcopy(expected_plan_limits_)
    expected_plan_limits_.residual_restriction.max_residual = 105000
    expected_plan_limits_.max_open_chores_per_side = 10
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    active_pair_plan, executor_http_client = (
        create_pre_chore_test_requirements(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                           market_depth_basemodel_list))

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(active_pair_plan.id)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        bid_buy_top_market_depth, ask_sell_top_market_depth = (
            get_buy_bid_n_ask_sell_market_depth(buy_symbol, sell_symbol, active_pair_plan))

        # buy testing
        buy_new_chore_id = None
        chore_create_time_list = []
        chore_qty_list = []
        for loop_count in range(total_chore_count_for_each_side):
            run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
            time.sleep(1)
            update_tob_through_market_depth_to_place_buy_chore(active_pair_plan.cpp_port, bid_buy_top_market_depth,
                                                               ask_sell_top_market_depth)

            ack_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW,
                                                                               buy_symbol, executor_http_client,
                                                                               last_chore_id=buy_new_chore_id)
            buy_new_chore_id = ack_chore_journal.chore.chore_id
            chore_create_time_list.append(ack_chore_journal.chore_event_date_time)
            chore_qty_list.append(ack_chore_journal.chore.qty)
            if not executor_config_yaml_dict.get("allow_multiple_unfilled_chore_pairs_per_plan"):
                time.sleep(residual_wait_sec)   # wait for this chore to get cancelled by residual
            else:
                time.sleep(2)

        chore_create_time_list.reverse()
        chore_qty_list.reverse()
        last_n_sec_qty = 0
        for loop_count in range(total_chore_count_for_each_side):
            delta = DateTime.utcnow() - chore_create_time_list[loop_count]
            last_n_sec = int(math.ceil(delta.total_seconds())) + 1
            last_n_sec_qty += chore_qty_list[loop_count]

            # making contact_limits_obj.rolling_max_chore_count.rolling_tx_count_period_seconds computed last_n_sec(s)
            # this is required as last_n_sec_chore_qty takes internally this limit as last_n_sec to provide chore_qty
            # in query
            rolling_max_chore_count = RollingMaxChoreCountBaseModel(rolling_tx_count_period_seconds=last_n_sec)
            contact_limits = ContactLimitsBaseModel.from_kwargs(_id=1, rolling_max_chore_count=rolling_max_chore_count)
            updated_contact_limits = \
                email_book_service_native_web_client.patch_contact_limits_client(
                    contact_limits.to_dict(exclude_none=True))
            assert updated_contact_limits.rolling_max_chore_count.rolling_tx_count_period_seconds == last_n_sec, \
                f"Unexpected last_n_sec value: expected {last_n_sec}, " \
                f"received {updated_contact_limits.rolling_max_chore_count.rolling_tx_count_period_seconds}"

            call_date_time = DateTime.utcnow()
            executor_check_snapshot_obj = \
                executor_http_client.get_executor_check_snapshot_query_client(buy_symbol, "BUY", last_n_sec)

            assert len(executor_check_snapshot_obj) == 1, \
                f"Received unexpected length of list of executor_check_snapshot_obj from query," \
                f"expected one obj received {len(executor_check_snapshot_obj)}"
            assert executor_check_snapshot_obj[0].last_n_sec_chore_qty == last_n_sec_qty, \
                f"Chore qty mismatched for last {last_n_sec} " \
                f"secs of {buy_symbol} from {call_date_time} for side {Side.BUY}"
    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_acked_unsolicited_cxl(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                               expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
                               last_barter_fixture_list, market_depth_basemodel_list,
                               buy_chore_, sell_chore_,
                               max_loop_count_per_side, refresh_sec_update_fixture):
    # updating fixture values for this test-case
    max_loop_count_per_side = 5
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:2]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        # explicitly setting waived_initial_chores to 10 for this test case
        expected_plan_limits_.cancel_rate.waived_initial_chores = 10
        active_pair_plan, executor_http_client = (
            create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                               market_depth_basemodel_list))

        config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(active_pair_plan.id)

        try:
            # updating yaml_configs according to this test
            for symbol in config_dict["symbol_configs"]:
                config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
                config_dict["symbol_configs"][symbol]["fill_percent"] = 50
                config_dict["symbol_configs"][symbol]["simulate_ack_unsolicited_cxl_chores"] = True
            YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

            # updating simulator's configs
            executor_http_client.barter_simulator_reload_config_query_client()

            handle_unsolicited_cxl(leg1_symbol, leg2_symbol, active_pair_plan, last_barter_fixture_list,
                                   max_loop_count_per_side, executor_http_client, config_dict, residual_wait_sec)
        except AssertionError as e:
            raise AssertionError(e)
        except Exception as e:
            err_str_ = (f"Some Error Occurred: exception: {e}, "
                        f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
            print(err_str_)
            raise Exception(err_str_)
        finally:
            YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_unacked_unsolicited_cxl(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
                                 expected_plan_status_, symbol_overview_obj_list,
                                 last_barter_fixture_list, market_depth_basemodel_list,
                                 buy_chore_, sell_chore_,
                                 max_loop_count_per_side, refresh_sec_update_fixture):
    # updating fixture values for this test-case
    max_loop_count_per_side = 5
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:2]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        # explicitly setting waived_initial_chores to 10 for this test case
        expected_plan_limits_.cancel_rate.waived_initial_chores = 10
        active_pair_plan, executor_http_client = (
            create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list,
                                               last_barter_fixture_list,
                                               market_depth_basemodel_list))

        config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(active_pair_plan.id)

        try:
            # updating yaml_configs according to this test
            for symbol in config_dict["symbol_configs"]:
                config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
                config_dict["symbol_configs"][symbol]["fill_percent"] = 50
                config_dict["symbol_configs"][symbol]["simulate_new_unsolicited_cxl_chores"] = True
            YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

            # updating simulator's configs
            executor_http_client.barter_simulator_reload_config_query_client()

            handle_unsolicited_cxl(leg1_symbol, leg2_symbol, active_pair_plan, last_barter_fixture_list,
                                   max_loop_count_per_side, executor_http_client, config_dict, residual_wait_sec)
        except AssertionError as e:
            raise AssertionError(e)
        except Exception as e:
            err_str_ = (f"Some Error Occurred: exception: {e}, "
                        f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
            print(err_str_)
            raise Exception(err_str_)
        finally:
            YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_pair_plan_related_models_update_counters(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                                                   pair_plan_, expected_plan_limits_, expected_plan_status_,
                                                   symbol_overview_obj_list, last_barter_fixture_list,
                                                   market_depth_basemodel_list,
                                                   refresh_sec_update_fixture):
    activated_plans = []
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture

    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:5]
    # creates and activates multiple pair_plans
    for buy_symbol, sell_symbol in leg1_leg2_symbol_list:
        activated_plan, executor_http_client = (
            create_pre_chore_test_requirements(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list,
                                               last_barter_fixture_list, market_depth_basemodel_list))
        activated_plans.append((activated_plan, executor_http_client))

    for index, (activated_plan, executor_http_client) in enumerate(activated_plans):
        # updating pair_plan_params
        pair_plan = \
            PairPlanBaseModel.from_kwargs(_id=activated_plan.id,
                                           pair_plan_params=PairPlanParamsBaseModel(common_premium=index))
        updates_pair_plan = email_book_service_native_web_client.patch_pair_plan_client(
            pair_plan.to_dict(exclude_none=True))
        assert updates_pair_plan.pair_plan_params_update_seq_num == \
               activated_plan.pair_plan_params_update_seq_num + 1, (
                f"Mismatched pair_plan_params_update_seq_num: expected "
                f"{activated_plan.pair_plan_params_update_seq_num + 1}, received "
                f"{updates_pair_plan.pair_plan_params_update_seq_num}")

    for index, (activated_plan, executor_http_client) in enumerate(activated_plans):
        plan_limits_obj = executor_http_client.get_plan_limits_client(activated_plan.id)

        # updating plan_limits
        plan_limits = PlanLimitsBaseModel.from_kwargs(_id=activated_plan.id, max_concentration=index)
        updates_plan_limits = executor_http_client.patch_plan_limits_client(
            plan_limits.to_dict(exclude_none=True))
        assert updates_plan_limits.plan_limits_update_seq_num == \
               plan_limits_obj.plan_limits_update_seq_num + 1, (
                f"Mismatched plan_limits_update_seq_num: expected "
                f"{plan_limits_obj.plan_limits_update_seq_num + 1}, received "
                f"{updates_plan_limits.plan_limits_update_seq_num}")

    for index, (activated_plan, executor_http_client) in enumerate(activated_plans):
        plan_status_obj = executor_http_client.get_plan_status_client(activated_plan.id)

        # updating plan_status
        plan_status = PlanStatusBaseModel.from_kwargs(_id=activated_plan.id, average_premuim=index)
        updates_plan_status = executor_http_client.patch_plan_status_client(
            plan_status.to_dict(exclude_none=True))
        assert updates_plan_status.plan_status_update_seq_num == \
               plan_status_obj.plan_status_update_seq_num + 1, (
                f"Mismatched plan_limits_update_seq_num: expected "
                f"{plan_status_obj.plan_status_update_seq_num + 1}, received "
                f"{updates_plan_status.plan_status_update_seq_num}")


# @@@ deprecated: Not applicable anymore after ContactAlert model changes
# @pytest.mark.nightly
# def test_contact_alert_updates(static_data_, clean_and_set_limits, sample_alert):
#     stored_contact_alert = log_book_web_client.get_contact_alert_client(contact_alert_id=1)
#
#     alert = copy.deepcopy(sample_alert)
#     contact_alert_basemodel = ContactAlertBaseModel(_id=1, alerts=[alert])
#     updated_contact_alert = log_book_web_client.patch_contact_alert_client(
#             jsonable_encoder(contact_alert_basemodel, by_alias=True, exclude_none=True))
#     assert stored_contact_alert.alert_update_seq_num + 1 == updated_contact_alert.alert_update_seq_num, \
#         f"Mismatched alert_update_seq_num: expected {stored_contact_alert.alert_update_seq_num + 1}, " \
#         f"received {updated_contact_alert.alert_update_seq_num}"
#
#     max_loop_count = 5
#     for loop_count in range(max_loop_count):
#         alert.alert_brief = f"Test update - {loop_count}"
#         contact_alert_basemodel = ContactAlertBaseModel(_id=1, alerts=[alert])
#         alert_updated_contact_alert = log_book_web_client.patch_contact_alert_client(
#                 jsonable_encoder(contact_alert_basemodel, by_alias=True, exclude_none=True))
#         assert updated_contact_alert.alert_update_seq_num + (loop_count + 1) == \
#                alert_updated_contact_alert.alert_update_seq_num, (
#                 f"Mismatched alert_update_seq_num: expected "
#                 f"{updated_contact_alert.alert_update_seq_num + (loop_count + 1)}, "
#                 f"received {alert_updated_contact_alert.alert_update_seq_num}")


@pytest.mark.nightly
def test_partial_ack(static_data_, clean_and_set_limits, pair_plan_,
                     expected_plan_limits_,
                     expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                     market_depth_basemodel_list, leg1_leg2_symbol_list, refresh_sec_update_fixture):
    partial_ack_qty: int | None = None

    # updating fixture values for this test-case
    max_loop_count_per_side = 5
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:2]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
         config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
            leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
            expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
            market_depth_basemodel_list)

        try:
            # updating yaml_configs according to this test
            for symbol in config_dict["symbol_configs"]:
                config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
                config_dict["symbol_configs"][symbol]["ack_percent"] = 50
            YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

            # updating simulator's configs
            executor_http_client.barter_simulator_reload_config_query_client()

            # buy fills check
            new_chore_id = None
            acked_chore_id = None
            for loop_count in range(1, max_loop_count_per_side + 1):
                run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
                px = 100
                qty = 90
                place_new_chore(leg1_symbol, Side.BUY, px, qty, executor_http_client, buy_inst_type)
                time.sleep(2)  # delay for chore to get placed

                new_chore_id, acked_chore_id, partial_ack_qty = \
                    handle_partial_ack_checks(leg1_symbol, new_chore_id, acked_chore_id, executor_http_client,
                                              config_dict)

                if not executor_config_yaml_dict.get("allow_multiple_unfilled_chore_pairs_per_plan"):
                    time.sleep(residual_wait_sec)    # wait to make this open chore residual

            time.sleep(5)
            plan_status = executor_http_client.get_plan_status_client(active_pair_plan.id)
            assert partial_ack_qty * max_loop_count_per_side == plan_status.total_fill_buy_qty, \
                f"Mismatched total_fill_buy_qty: Expected {partial_ack_qty * max_loop_count_per_side}, " \
                f"received {plan_status.total_fill_buy_qty}"

            # sell fills check
            new_chore_id = None
            acked_chore_id = None
            for loop_count in range(1, max_loop_count_per_side + 1):
                run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
                px = 110
                qty = 95
                place_new_chore(leg2_symbol, Side.SELL, px, qty, executor_http_client, sell_inst_type)
                time.sleep(2)

                new_chore_id, acked_chore_id, partial_ack_qty = \
                    handle_partial_ack_checks(leg2_symbol, new_chore_id, acked_chore_id, executor_http_client,
                                              config_dict)

                if not executor_config_yaml_dict.get("allow_multiple_unfilled_chore_pairs_per_plan"):
                    time.sleep(residual_wait_sec)    # wait to make this open chore residual

            plan_status = executor_http_client.get_plan_status_client(active_pair_plan.id)
            assert partial_ack_qty * max_loop_count_per_side == plan_status.total_fill_sell_qty, \
                f"Mismatched total_fill_sell_qty: Expected {partial_ack_qty * max_loop_count_per_side}, " \
                f"received {plan_status.total_fill_sell_qty}"
        except AssertionError as e:
            raise AssertionError(e)
        except Exception as e:
            err_str_ = (f"Some Error Occurred: exception: {e}, "
                        f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
            print(err_str_)
            raise Exception(err_str_)
        finally:
            YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_update_residual_query(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                               expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
                               last_barter_fixture_list, market_depth_basemodel_list,
                               refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    active_pair_plan, executor_http_client = (
        create_pre_chore_test_requirements(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list,
                                           last_barter_fixture_list,
                                           market_depth_basemodel_list))
    total_loop_count = 5
    residual_qty = 5

    buy_last_barter_px, sell_last_barter_px = get_both_side_last_barter_px()

    buy_residual_qty = 0
    sell_residual_qty = 0
    buy_residual_notional = 0
    sell_residual_notional = 0
    for loop_count in range(total_loop_count):
        # buy side
        executor_http_client.update_residuals_query_client(buy_symbol, Side.BUY, residual_qty)
        buy_residual_qty += residual_qty
        plan_status = executor_http_client.get_plan_status_client(active_pair_plan.id)
        plan_brief_list = executor_http_client.get_all_plan_brief_client()

        # since only one plan is created in this test
        plan_brief = plan_brief_list[0]

        buy_residual_notional = buy_residual_qty * get_px_in_usd(buy_last_barter_px)
        residual_notional = abs(buy_residual_notional - sell_residual_notional)
        assert buy_residual_qty == plan_brief.pair_buy_side_bartering_brief.residual_qty, \
            f"Mismatch residual_qty: expected {buy_residual_qty} received " \
            f"{plan_brief.pair_buy_side_bartering_brief.residual_qty}"
        assert residual_notional == plan_status.residual.residual_notional, \
            f"Mismatch buy residual_notional, expected {residual_notional}, received " \
            f"{plan_status.residual.residual_notional}"

        # sell side
        executor_http_client.update_residuals_query_client(sell_symbol, Side.SELL, residual_qty)
        sell_residual_qty += residual_qty
        plan_status = executor_http_client.get_plan_status_client(active_pair_plan.id)
        plan_brief_list = executor_http_client.get_all_plan_brief_client()

        # since only one plan is created in this test
        plan_brief = plan_brief_list[0]

        sell_residual_notional = sell_residual_qty * get_px_in_usd(sell_last_barter_px)
        residual_notional = abs(buy_residual_notional - sell_residual_notional)
        assert sell_residual_qty == plan_brief.pair_sell_side_bartering_brief.residual_qty, \
            f"Mismatch residual_qty: expected {sell_residual_qty}, received " \
            f"{plan_brief.pair_sell_side_bartering_brief.residual_qty}"
        assert plan_status.residual.residual_notional == residual_notional, \
            (f"Mismatch sell residual_notional: expected {residual_notional} received "
             f"{plan_status.residual.residual_notional}")


@pytest.mark.nightly
def test_ack_post_unack_unsol_cxl(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                                  expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
                                  last_barter_fixture_list, market_depth_basemodel_list,
                                  buy_chore_, sell_chore_,
                                  max_loop_count_per_side, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["simulate_new_unsolicited_cxl_chores"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
        px = 100
        qty = 90
        place_new_chore(buy_symbol, Side.BUY, px, qty, executor_http_client, buy_inst_type)

        latest_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW, buy_symbol,
                                                                          executor_http_client)
        latest_cxl_ack_obj = get_latest_chore_journal_with_events_and_symbol([ChoreEventType.OE_CXL_ACK,
                                                                              ChoreEventType.OE_UNSOL_CXL], buy_symbol,
                                                                             executor_http_client)

        executor_http_client.barter_simulator_process_chore_ack_query_client(
            latest_unack_obj.chore.chore_id,
            latest_unack_obj.chore.px,
            latest_unack_obj.chore.qty,
            latest_unack_obj.chore.side,
            latest_unack_obj.chore.security.sec_id,
            latest_unack_obj.chore.underlying_account)

        chore_snapshot = get_chore_snapshot_from_chore_id(latest_unack_obj.chore.chore_id,
                                                          executor_http_client)

        assert chore_snapshot.chore_status == ChoreStatusType.OE_DOD, \
            f"Mismatched: Chore status must be DOD but found: {chore_snapshot.chore_status = }"

        check_str = ("Unexpected: Received chore_journal of event: ChoreEventType.OE_ACK on chore of "
                     "chore_snapshot status: ChoreStatusType.OE_DOD")
        assert_fail_msg = f"Can't find alert of {check_str} in neither plan_alert nor contact_alert"
        time.sleep(5)
        check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_fill_post_unack_unsol_cxl(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["simulate_new_unsolicited_cxl_chores"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        buy_symbol_side_snapshot = None
        buy_qty = None
        buy_px = None
        buy_filled_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                            (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            # buy test
            if side == Side.BUY:
                buy_qty = qty
                buy_px = px

            run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            latest_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW, chore_symbol,
                                                                              executor_http_client)
            latest_cxl_ack_obj = get_latest_chore_journal_with_events_and_symbol([ChoreEventType.OE_CXL_ACK,
                                                                                  ChoreEventType.OE_UNSOL_CXL],
                                                                                 chore_symbol,
                                                                                 executor_http_client)

            chore_snapshot = get_chore_snapshot_from_chore_id(latest_unack_obj.chore.chore_id,
                                                              executor_http_client)
            assert chore_snapshot.chore_status == ChoreStatusType.OE_DOD, \
                f"Mismatched: Chore status must be DOD but found: {chore_snapshot.chore_status = }"
            assert chore_snapshot.cxled_qty == latest_unack_obj.chore.qty, \
                (f"Mismatched: ChoreSnapshot cxled_qty must be {latest_unack_obj.chore.qty}, found "
                 f"{chore_snapshot.cxled_qty}")
            assert chore_snapshot.cxled_notional == qty * get_px_in_usd(px), \
                (f"Mismatched: ChoreSnapshot cxled_notional must be "
                 f"{qty * get_px_in_usd(px)}, found {chore_snapshot.cxled_notional}")
            assert chore_snapshot.avg_cxled_px == latest_unack_obj.chore.px, \
                (f"Mismatched: ChoreSnapshot avg_cxled_px must be "
                 f"{latest_unack_obj.chore.px}, found {chore_snapshot.avg_cxled_px}")
            assert chore_snapshot.filled_qty == 0, \
                f"Mismatched: ChoreSnapshot avg_cxled_px must be 0, found {chore_snapshot.filled_qty}"
            assert chore_snapshot.fill_notional == 0, \
                f"Mismatched: ChoreSnapshot fill_notional must be 0, found {chore_snapshot.fill_notional}"
            assert chore_snapshot.avg_fill_px == 0, \
                f"Mismatched: ChoreSnapshot avg_fill_px must be 0, found {chore_snapshot.avg_fill_px}"

            symbol_side_snapshot_list = (
                executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                    latest_unack_obj.chore.security.sec_id, latest_unack_obj.chore.side))
            assert len(symbol_side_snapshot_list) == 1, \
                (f"found {len(symbol_side_snapshot_list) = }, must be exact 1 for symbol and side: "
                 f"{latest_unack_obj.chore.security.sec_id, latest_unack_obj.chore.side}")

            symbol_side_snapshot = symbol_side_snapshot_list[0]
            if side == Side.BUY:
                buy_symbol_side_snapshot = symbol_side_snapshot
            assert symbol_side_snapshot.total_qty == chore_snapshot.chore_brief.qty, \
                (f"Mismatched: expected symbol_side_snapshot.total_qty: {chore_snapshot.chore_brief.qty}, "
                 f"found {symbol_side_snapshot.total_qty = }")
            assert symbol_side_snapshot.avg_px == chore_snapshot.chore_brief.px, \
                (f"Mismatched: expected symbol_side_snapshot.avg_px: {chore_snapshot.chore_brief.px}, "
                 f"found {symbol_side_snapshot.avg_px = }")
            assert symbol_side_snapshot.total_filled_qty == 0, \
                (f"Mismatched: symbol_side_snapshot.total_filled_qty must be 0, found "
                 f"{symbol_side_snapshot.total_filled_qty = }")
            assert symbol_side_snapshot.total_fill_notional == 0, \
                (f"Mismatched: symbol_side_snapshot.total_fill_notional must be 0, found "
                 f"{symbol_side_snapshot.total_fill_notional = }")
            assert symbol_side_snapshot.avg_fill_px == 0, \
                (f"Mismatched: symbol_side_snapshot.avg_fill_px must be 0, found "
                 f"{symbol_side_snapshot.avg_fill_px = }")
            assert symbol_side_snapshot.total_cxled_qty == latest_unack_obj.chore.qty, \
                (f"Mismatched: symbol_side_snapshot.total_cxled_qty must be {latest_unack_obj.chore.qty}, found "
                 f"{symbol_side_snapshot.total_cxled_qty = }")
            assert (symbol_side_snapshot.total_cxled_notional ==
                    (latest_unack_obj.chore.qty * get_px_in_usd(latest_unack_obj.chore.px))), \
                (f"Mismatched: symbol_side_snapshot.total_cxled_notional must be "
                 f"{latest_unack_obj.chore.qty * get_px_in_usd(latest_unack_obj.chore.px)}, found "
                 f"{symbol_side_snapshot.total_cxled_notional = }")
            assert symbol_side_snapshot.avg_cxled_px == latest_unack_obj.chore.px, \
                (f"Mismatched: symbol_side_snapshot.avg_cxled_px must be {latest_unack_obj.chore.px}, found "
                 f"{symbol_side_snapshot.avg_cxled_px = }")
            assert symbol_side_snapshot.last_update_fill_px == 0, \
                (f"Mismatched: symbol_side_snapshot.last_update_fill_px must be 0, found "
                 f"{symbol_side_snapshot.last_update_fill_px = }")
            assert symbol_side_snapshot.last_update_fill_qty == 0, \
                (f"Mismatched: symbol_side_snapshot.last_update_fill_qty must be 0, found "
                 f"{symbol_side_snapshot.last_update_fill_qty = }")

            buy_last_barter_px, sell_last_barter_px = get_both_side_last_barter_px()
            plan_limits = executor_http_client.get_plan_limits_client(1)
            plan_brief = executor_http_client.get_plan_brief_client(active_pair_plan.id)
            if side == Side.BUY:
                plan_brief_bartering_brief = plan_brief.pair_buy_side_bartering_brief
                hedge_ratio = 1
            else:
                plan_brief_bartering_brief = plan_brief.pair_sell_side_bartering_brief
                hedge_ratio = active_pair_plan.pair_plan_params.hedge_ratio
            assert (plan_brief_bartering_brief.open_qty == 0), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_qty: "
                 f"0, found {plan_brief_bartering_brief.open_qty = }")
            assert (plan_brief_bartering_brief.open_notional == 0), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_notional: "
                 f"0, found {plan_brief_bartering_brief.open_notional = }")
            assert (plan_brief_bartering_brief.residual_qty == chore_snapshot.cxled_qty), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.residual_qty: "
                 f"{chore_snapshot.cxled_qty}, found {plan_brief_bartering_brief.open_notional = }")
            assert (plan_brief_bartering_brief.consumable_open_chores == 5), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_chores: "
                 f"5, found {plan_brief_bartering_brief.consumable_open_chores = }")
            assert (plan_brief_bartering_brief.all_bkr_cxlled_qty == chore_snapshot.cxled_qty), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.all_bkr_cxlled_qty: "
                 f"{chore_snapshot.cxled_qty}, found {plan_brief_bartering_brief.all_bkr_cxlled_qty = }")
            assert (plan_brief_bartering_brief.consumable_notional == (
                    (plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_notional: "
                 f"{(plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_notional = }")
            assert (plan_brief_bartering_brief.consumable_open_notional == plan_limits.max_open_single_leg_notional), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_notional: "
                 f"{plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_open_notional = }")
            total_security_size: int = \
                static_data.get_security_float_from_ticker(chore_snapshot.chore_brief.security.sec_id)
            assert (plan_brief_bartering_brief.consumable_concentration == (
                    (total_security_size / 100 * plan_limits.max_concentration) -
                    symbol_side_snapshot.total_filled_qty)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_concentration: "
                 f"{(total_security_size / 100 * plan_limits.max_concentration) - symbol_side_snapshot.total_filled_qty}, "
                 f"found {plan_brief_bartering_brief.consumable_concentration = }")
            assert (plan_brief_bartering_brief.consumable_cxl_qty == (
                    (((symbol_side_snapshot.total_filled_qty +
                       symbol_side_snapshot.total_cxled_qty) / 100) * plan_limits.cancel_rate.max_cancel_rate) -
                    symbol_side_snapshot.total_cxled_qty)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_cxl_qty: "
                 f"{plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_cxl_qty = }")
            if side == Side.BUY:
                other_side_residual_qty = 0
            else:
                other_side_residual_qty = buy_qty - buy_filled_qty
            if side == Side.BUY:
                current_last_barter_px = buy_last_barter_px
                other_last_barter_px = sell_last_barter_px
            else:
                current_last_barter_px = sell_last_barter_px
                other_last_barter_px = buy_last_barter_px
            assert (plan_brief_bartering_brief.indicative_consumable_residual == (
                    plan_limits.residual_restriction.max_residual -
                    ((plan_brief_bartering_brief.residual_qty *
                      get_px_in_usd(current_last_barter_px)) - (
                             other_side_residual_qty * get_px_in_usd(other_last_barter_px))))), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.indicative_consumable_residual: "
                 f"{plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief_bartering_brief.indicative_consumable_residual = }")

            if side == Side.BUY:
                other_side_fill_notional = 0
            else:
                other_side_fill_notional = buy_symbol_side_snapshot.total_fill_notional
            assert (plan_brief.consumable_nett_filled_notional == (
                    plan_limits.max_net_filled_notional -
                    abs(symbol_side_snapshot.total_fill_notional - other_side_fill_notional))), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief."
                 f"consumable_nett_filled_notional: {plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief.consumable_nett_filled_notional=}")

            plan_status = executor_http_client.get_plan_status_client(active_pair_plan.id)
            if side == Side.BUY:
                total_qty = plan_status.total_buy_qty
                total_open_qty = plan_status.total_open_buy_qty
                total_open_notional = plan_status.total_open_buy_notional
                avg_open_px = plan_status.avg_open_buy_px
                total_fill_qty = plan_status.total_fill_buy_qty
                total_fill_notional = plan_status.total_fill_buy_notional
                avg_fill_px = plan_status.avg_fill_buy_px
                total_cxl_qty = plan_status.total_cxl_buy_qty
                total_cxl_notional = plan_status.total_cxl_buy_notional
                avg_cxl_px = plan_status.avg_cxl_buy_px
            else:
                total_qty = plan_status.total_sell_qty
                total_open_qty = plan_status.total_open_sell_qty
                total_open_notional = plan_status.total_open_sell_notional
                avg_open_px = plan_status.avg_open_sell_px
                total_fill_qty = plan_status.total_fill_sell_qty
                total_fill_notional = plan_status.total_fill_sell_notional
                avg_fill_px = plan_status.avg_fill_sell_px
                total_cxl_qty = plan_status.total_cxl_sell_qty
                total_cxl_notional = plan_status.total_cxl_sell_notional
                avg_cxl_px = plan_status.avg_cxl_sell_px

            total_open_exposure = plan_status.total_open_exposure
            total_fill_exposure = plan_status.total_fill_exposure
            total_cxl_exposure = plan_status.total_cxl_exposure
            assert total_qty == chore_snapshot.chore_brief.qty, \
                (f"Mismatched: expected plan_status.total_{side.lower()}_qty: "
                 f"{chore_snapshot.chore_brief.qty}, found {total_qty = }")
            assert total_open_qty == 0, \
                (f"Mismatched: expected plan_status total_open_{side.lower()}_qty: "
                 f"0, found {total_open_qty = }")
            assert (total_open_notional == 0), \
                (f"Mismatched: expected plan_status.total_open_{side.lower()}_notional: "
                 f"0, found {total_open_notional = }")
            assert (avg_open_px == 0), \
                (f"Mismatched: expected plan_status.avg_open_{side.lower()}_px: "
                 f"0, found {avg_open_px = }")
            assert (total_fill_qty == 0), \
                (f"Mismatched: expected plan_status.total_fill_{side.lower()}_qty: "
                 f"0, found {total_fill_qty = }")
            assert (total_fill_notional == 0), \
                (f"Mismatched: expected plan_status.total_fill_{side.lower()}_notional: "
                 f"0, found {total_fill_notional = }")
            assert (avg_fill_px == 0), \
                (f"Mismatched: expected plan_status.avg_fill_{side.lower()}_px: "
                 f"0, found {avg_fill_px = }")
            assert (total_cxl_qty == qty), \
                (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_qty: "
                 f"{qty}, found {total_cxl_qty = }")
            assert (total_cxl_notional == qty * get_px_in_usd(px)), \
                (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_notional: "
                 f"{qty * get_px_in_usd(px)}, found {total_cxl_notional = }")
            assert (avg_cxl_px == px), \
                (f"Mismatched: expected plan_status.avg_cxl_{side.lower()}_px: "
                 f"{px}, found {avg_cxl_px = }")
            if side == Side.BUY:
                assert (total_open_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_open_exposure: "
                     f"0, found {total_open_exposure = }")
                assert (total_fill_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_fill_exposure: "
                     f"0, found {total_fill_exposure = }")
                assert (total_cxl_exposure == qty * get_px_in_usd(px)), \
                    (f"Mismatched: expected plan_status.total_cxl_exposure: "
                     f"{qty * get_px_in_usd(px)}, found {total_cxl_exposure = }")
            else:
                assert (total_open_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_open_exposure: "
                     f"0, found {total_open_exposure = }")
                assert (total_fill_exposure == buy_filled_qty * get_px_in_usd(buy_px)), \
                    (f"Mismatched: expected plan_status.total_fill_exposure: "
                     f"{buy_filled_qty * get_px_in_usd(buy_px)}, found {total_fill_exposure = }")
                assert (total_cxl_exposure == (buy_qty - buy_filled_qty) * get_px_in_usd(buy_px) - qty * get_px_in_usd(px)), \
                    (f"Mismatched: expected plan_status.total_cxl_exposure: "
                     f"{(buy_qty - buy_filled_qty) * get_px_in_usd(buy_px) - qty * get_px_in_usd(px)}, "
                     f"found {total_cxl_exposure = }")

            contact_status = email_book_service_native_web_client.get_contact_status_client(1)
            if side == Side.BUY:
                overall_notional = contact_status.overall_buy_notional
            else:
                overall_notional = contact_status.overall_sell_notional
            assert (overall_notional == 0), \
                (f"Mismatched: expected contact_status.overall_{side.lower()}_notional: "
                 f"0, found {overall_notional = }")

            # applying ack leading to overfill
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_unack_obj.chore.chore_id, latest_unack_obj.chore.px, latest_unack_obj.chore.qty,
                latest_unack_obj.chore.side, latest_unack_obj.chore.security.sec_id,
                latest_unack_obj.chore.underlying_account)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            if side == Side.BUY:
                buy_filled_qty = filled_qty

            chore_snapshot = get_chore_snapshot_from_chore_id(latest_unack_obj.chore.chore_id,
                                                              executor_http_client)
            assert chore_snapshot.chore_status == ChoreStatusType.OE_DOD, \
                f"Mismatched: Chore status must be OE_DOD but found: {chore_snapshot.chore_status = }"
            assert chore_snapshot.cxled_qty == qty - filled_qty, \
                (f"Mismatched: ChoreSnapshot cxled_qty must be {qty - filled_qty}, found "
                 f"{chore_snapshot.cxled_qty}")
            assert chore_snapshot.cxled_notional == (qty - filled_qty) * get_px_in_usd(px), \
                (f"Mismatched: ChoreSnapshot cxled_notional must be "
                 f"{(qty - filled_qty) * get_px_in_usd(px)}, found {chore_snapshot.cxled_notional}")
            assert chore_snapshot.avg_cxled_px == px, \
                (f"Mismatched: ChoreSnapshot avg_cxled_px must be "
                 f"{px}, found {chore_snapshot.avg_cxled_px}")
            assert chore_snapshot.filled_qty == filled_qty, \
                f"Mismatched: ChoreSnapshot avg_cxled_px must be {filled_qty}, found {chore_snapshot.filled_qty}"
            assert chore_snapshot.fill_notional == filled_qty * get_px_in_usd(px), \
                (f"Mismatched: ChoreSnapshot fill_notional must be {filled_qty * get_px_in_usd(px)}, "
                 f"found {chore_snapshot.fill_notional}")
            assert chore_snapshot.avg_fill_px == px, \
                f"Mismatched: ChoreSnapshot avg_fill_px must be {px}, found {chore_snapshot.avg_fill_px}"

            symbol_side_snapshot_list = (
                executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                    latest_unack_obj.chore.security.sec_id, latest_unack_obj.chore.side))
            assert len(symbol_side_snapshot_list) == 1, \
                (f"found {len(symbol_side_snapshot_list) = }, must be exact 1 for symbol and side: "
                 f"{latest_unack_obj.chore.security.sec_id, latest_unack_obj.chore.side}")

            symbol_side_snapshot = symbol_side_snapshot_list[0]
            if side == Side.BUY:
                buy_symbol_side_snapshot = symbol_side_snapshot
            assert symbol_side_snapshot.total_qty == qty, \
                (f"Mismatched: expected symbol_side_snapshot.total_qty: {qty}, "
                 f"found {symbol_side_snapshot.total_qty = }")
            assert symbol_side_snapshot.avg_px == px, \
                (f"Mismatched: expected symbol_side_snapshot.avg_px: {px}, "
                 f"found {symbol_side_snapshot.avg_px = }")
            assert symbol_side_snapshot.total_filled_qty == filled_qty, \
                (f"Mismatched: symbol_side_snapshot.total_filled_qty must be {filled_qty}, found "
                 f"{symbol_side_snapshot.total_filled_qty = }")
            assert symbol_side_snapshot.total_fill_notional == filled_qty * get_px_in_usd(px), \
                (f"Mismatched: symbol_side_snapshot.total_fill_notional must be {filled_qty * get_px_in_usd(px)}, "
                 f"found {symbol_side_snapshot.total_fill_notional = }")
            assert symbol_side_snapshot.avg_fill_px == px, \
                (f"Mismatched: symbol_side_snapshot.avg_fill_px must be {px}, found "
                 f"{symbol_side_snapshot.avg_fill_px = }")
            assert symbol_side_snapshot.total_cxled_qty == (qty - filled_qty), \
                (f"Mismatched: symbol_side_snapshot.total_cxled_qty must be {qty - filled_qty}, found "
                 f"{symbol_side_snapshot.total_cxled_qty = }")
            assert (symbol_side_snapshot.total_cxled_notional == (qty - filled_qty) * get_px_in_usd(px)), \
                (f"Mismatched: symbol_side_snapshot.total_cxled_notional must be "
                 f"{(qty - filled_qty) * get_px_in_usd(px)}, found {symbol_side_snapshot.total_cxled_notional = }")
            assert symbol_side_snapshot.avg_cxled_px == px, \
                (f"Mismatched: symbol_side_snapshot.avg_cxled_px must be {px}, found "
                 f"{symbol_side_snapshot.avg_cxled_px = }")
            assert symbol_side_snapshot.last_update_fill_px == px, \
                (f"Mismatched: symbol_side_snapshot.last_update_fill_px must be {px}, found "
                 f"{symbol_side_snapshot.last_update_fill_px = }")
            assert symbol_side_snapshot.last_update_fill_qty == filled_qty, \
                (f"Mismatched: symbol_side_snapshot.last_update_fill_qty must be {filled_qty}, found "
                 f"{symbol_side_snapshot.last_update_fill_qty = }")

            buy_last_barter_px, sell_last_barter_px = get_both_side_last_barter_px()
            plan_limits = executor_http_client.get_plan_limits_client(1)
            plan_brief = executor_http_client.get_plan_brief_client(active_pair_plan.id)
            if side == Side.BUY:
                plan_brief_bartering_brief = plan_brief.pair_buy_side_bartering_brief
            else:
                plan_brief_bartering_brief = plan_brief.pair_sell_side_bartering_brief
            assert (plan_brief_bartering_brief.open_qty == 0), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_qty: "
                 f"0, found {plan_brief_bartering_brief.open_qty = }")
            assert (plan_brief_bartering_brief.open_notional == 0), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_notional: "
                 f"0, found {plan_brief_bartering_brief.open_notional = }")
            assert (plan_brief_bartering_brief.residual_qty == (qty - filled_qty)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.residual_qty: "
                 f"{qty - filled_qty}, found {plan_brief_bartering_brief.residual_qty = }")
            assert (plan_brief_bartering_brief.consumable_open_chores == 5), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_chores: "
                 f"5, found {plan_brief_bartering_brief.consumable_open_chores = }")
            assert (plan_brief_bartering_brief.all_bkr_cxlled_qty == (qty - filled_qty)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.all_bkr_cxlled_qty: "
                 f"{(qty - filled_qty)}, found {plan_brief_bartering_brief.all_bkr_cxlled_qty = }")
            assert (plan_brief_bartering_brief.consumable_notional == (
                    (plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_notional: "
                 f"{(plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_notional = }")
            assert (plan_brief_bartering_brief.consumable_open_notional == plan_limits.max_open_single_leg_notional), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_notional: "
                 f"{plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_open_notional = }")
            total_security_size: int = \
                static_data.get_security_float_from_ticker(chore_snapshot.chore_brief.security.sec_id)
            assert (plan_brief_bartering_brief.consumable_concentration == (
                    (total_security_size / 100 * plan_limits.max_concentration) -
                    symbol_side_snapshot.total_filled_qty)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_concentration: "
                 f"{(total_security_size / 100 * plan_limits.max_concentration) - symbol_side_snapshot.total_filled_qty}, "
                 f"found {plan_brief_bartering_brief.consumable_concentration = }")
            assert (plan_brief_bartering_brief.consumable_cxl_qty == (
                    (((symbol_side_snapshot.total_filled_qty +
                       symbol_side_snapshot.total_cxled_qty) / 100) * plan_limits.cancel_rate.max_cancel_rate) -
                    symbol_side_snapshot.total_cxled_qty)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_cxl_qty: "
                 f"{plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_cxl_qty = }")
            if side == Side.BUY:
                other_side_residual_qty = 0
                current_last_barter_px = buy_last_barter_px
                other_last_barter_px = sell_last_barter_px
            else:
                other_side_residual_qty = buy_qty - buy_filled_qty
                current_last_barter_px = sell_last_barter_px
                other_last_barter_px = buy_last_barter_px

            assert (plan_brief_bartering_brief.indicative_consumable_residual == (
                    plan_limits.residual_restriction.max_residual -
                    ((plan_brief_bartering_brief.residual_qty *
                      get_px_in_usd(current_last_barter_px)) - (
                             other_side_residual_qty * get_px_in_usd(other_last_barter_px))))), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.indicative_consumable_residual: "
                 f"{plan_limits.residual_restriction.max_residual - ((plan_brief_bartering_brief.residual_qty * get_px_in_usd(current_last_barter_px)) - (other_side_residual_qty * get_px_in_usd(other_last_barter_px)))}, "
                 f"found {plan_brief_bartering_brief.indicative_consumable_residual = }")

            if side == Side.BUY:
                other_side_fill_notional = 0
            else:
                other_side_fill_notional = buy_symbol_side_snapshot.total_fill_notional
            assert (plan_brief.consumable_nett_filled_notional == (
                    plan_limits.max_net_filled_notional -
                    abs(symbol_side_snapshot.total_fill_notional - other_side_fill_notional))), \
                (
                    f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief."
                    f"consumable_nett_filled_notional: {plan_limits.max_open_single_leg_notional}, "
                    f"found {plan_brief.consumable_nett_filled_notional = }")

            plan_status = executor_http_client.get_plan_status_client(active_pair_plan.id)
            if side == Side.BUY:
                total_qty = plan_status.total_buy_qty
                total_open_qty = plan_status.total_open_buy_qty
                total_open_notional = plan_status.total_open_buy_notional
                avg_open_px = plan_status.avg_open_buy_px
                total_fill_qty = plan_status.total_fill_buy_qty
                total_fill_notional = plan_status.total_fill_buy_notional
                avg_fill_px = plan_status.avg_fill_buy_px
                total_cxl_qty = plan_status.total_cxl_buy_qty
                total_cxl_notional = plan_status.total_cxl_buy_notional
                avg_cxl_px = plan_status.avg_cxl_buy_px
            else:
                total_qty = plan_status.total_sell_qty
                total_open_qty = plan_status.total_open_sell_qty
                total_open_notional = plan_status.total_open_sell_notional
                avg_open_px = plan_status.avg_open_sell_px
                total_fill_qty = plan_status.total_fill_sell_qty
                total_fill_notional = plan_status.total_fill_sell_notional
                avg_fill_px = plan_status.avg_fill_sell_px
                total_cxl_qty = plan_status.total_cxl_sell_qty
                total_cxl_notional = plan_status.total_cxl_sell_notional
                avg_cxl_px = plan_status.avg_cxl_sell_px

            total_open_exposure = plan_status.total_open_exposure
            total_fill_exposure = plan_status.total_fill_exposure
            total_cxl_exposure = plan_status.total_cxl_exposure
            assert total_qty == qty, \
                (f"Mismatched: expected plan_status.total_{side.lower()}_qty: "
                 f"{qty}, found {total_qty = }")
            assert total_open_qty == 0, \
                (f"Mismatched: expected plan_status total_open_{side.lower()}_qty: "
                 f"0, found {total_open_qty = }")
            assert (total_open_notional == 0), \
                (f"Mismatched: expected plan_status.total_open_{side.lower()}_notional: "
                 f"0, found {total_open_notional = }")
            assert (avg_open_px == 0), \
                (f"Mismatched: expected plan_status.avg_open_{side.lower()}_px: "
                 f"0, found {avg_open_px = }")
            assert (total_fill_qty == filled_qty), \
                (f"Mismatched: expected plan_status.total_fill_{side.lower()}_qty: "
                 f"{filled_qty}, found {total_fill_qty = }")
            assert (total_fill_notional == filled_qty * get_px_in_usd(px)), \
                (f"Mismatched: expected plan_status.total_fill_{side.lower()}_notional: "
                 f"{filled_qty * get_px_in_usd(px)}, found {total_fill_notional = }")
            assert (avg_fill_px == px), \
                (f"Mismatched: expected plan_status.avg_fill_{side.lower()}_px: "
                 f"{px}, found {avg_fill_px = }")
            assert (total_cxl_qty == (qty - filled_qty)), \
                (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_qty: "
                 f"{qty - filled_qty}, found {total_cxl_qty = }")
            assert (total_cxl_notional == (qty - filled_qty) * get_px_in_usd(px)), \
                (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_notional: "
                 f"{(qty - filled_qty) * get_px_in_usd(px)}, found {total_cxl_notional = }")
            assert (avg_cxl_px == px), \
                (f"Mismatched: expected plan_status.avg_cxl_{side.lower()}_px: "
                 f"{px}, found {avg_cxl_px = }")
            if side == Side.BUY:
                assert (total_open_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_open_exposure: "
                     f"0, found {total_open_exposure = }")
                assert (total_fill_exposure == filled_qty * get_px_in_usd(px)), \
                    (f"Mismatched: expected plan_status.total_fill_exposure: "
                     f"{filled_qty * get_px_in_usd(px)}, found {total_fill_exposure = }")
                assert (total_cxl_exposure == (qty - filled_qty) * get_px_in_usd(px)), \
                    (f"Mismatched: expected plan_status.total_cxl_exposure: "
                     f"0, found {total_cxl_exposure = }")
            else:
                assert (total_open_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_open_exposure: "
                     f"0, found {total_open_exposure = }")
                assert (total_fill_exposure == (
                        buy_filled_qty * get_px_in_usd(buy_px) - filled_qty * get_px_in_usd(px))), \
                    (f"Mismatched: expected plan_status.total_fill_exposure: "
                     f"{buy_filled_qty * get_px_in_usd(buy_px) - filled_qty * get_px_in_usd(px)}, "
                     f"found {total_fill_exposure = }")
                assert (total_cxl_exposure == (buy_qty - buy_filled_qty) * get_px_in_usd(buy_px) - (qty - filled_qty) * get_px_in_usd(px)), \
                    (f"Mismatched: expected plan_status.total_cxl_exposure: "
                     f"{(buy_qty - buy_filled_qty) * get_px_in_usd(buy_px) - (qty - filled_qty) * get_px_in_usd(px)}, "
                     f"found {total_cxl_exposure = }")

            contact_status = email_book_service_native_web_client.get_contact_status_client(1)
            if side == Side.BUY:
                overall_notional = contact_status.overall_buy_notional
            else:
                overall_notional = contact_status.overall_sell_notional
            assert (overall_notional == filled_qty * get_px_in_usd(px)), \
                (f"Mismatched: expected contact_status.overall_{side.lower()}_notional: "
                 f"{filled_qty * get_px_in_usd(px)}, found {overall_notional = }")

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_fulfill_post_unack_unsol_cxl(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["simulate_new_unsolicited_cxl_chores"] = True
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        executor_config_file_path = STRAT_EXECUTOR / "data" / f"config.yaml"
        executor_config_dict: Dict = YAMLConfigurationManager.load_yaml_configurations(executor_config_file_path)

        buy_symbol_side_snapshot = None
        buy_px = None
        buy_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                            (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            # buy test
            if side == Side.BUY:
                buy_px = px
                buy_qty = qty

            run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            latest_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW, chore_symbol,
                                                                              executor_http_client)
            latest_cxl_ack_obj = get_latest_chore_journal_with_events_and_symbol([ChoreEventType.OE_CXL_ACK,
                                                                                  ChoreEventType.OE_UNSOL_CXL],
                                                                                 chore_symbol,
                                                                                 executor_http_client)

            chore_snapshot = get_chore_snapshot_from_chore_id(latest_unack_obj.chore.chore_id,
                                                              executor_http_client)
            assert chore_snapshot.chore_status == ChoreStatusType.OE_DOD, \
                f"Mismatched: Chore status must be DOD but found: {chore_snapshot.chore_status=}"
            assert chore_snapshot.cxled_qty == latest_unack_obj.chore.qty, \
                (f"Mismatched: ChoreSnapshot cxled_qty must be {latest_unack_obj.chore.qty}, found "
                 f"{chore_snapshot.cxled_qty}")
            assert chore_snapshot.cxled_notional == qty * get_px_in_usd(px), \
                (f"Mismatched: ChoreSnapshot cxled_notional must be "
                 f"{qty * get_px_in_usd(px)}, found {chore_snapshot.cxled_notional}")
            assert chore_snapshot.avg_cxled_px == latest_unack_obj.chore.px, \
                (f"Mismatched: ChoreSnapshot avg_cxled_px must be "
                 f"{latest_unack_obj.chore.px}, found {chore_snapshot.avg_cxled_px}")
            assert chore_snapshot.filled_qty == 0, \
                f"Mismatched: ChoreSnapshot avg_cxled_px must be 0, found {chore_snapshot.filled_qty}"
            assert chore_snapshot.fill_notional == 0, \
                f"Mismatched: ChoreSnapshot fill_notional must be 0, found {chore_snapshot.fill_notional}"
            assert chore_snapshot.avg_fill_px == 0, \
                f"Mismatched: ChoreSnapshot avg_fill_px must be 0, found {chore_snapshot.avg_fill_px}"

            symbol_side_snapshot_list = (
                executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                    latest_unack_obj.chore.security.sec_id, latest_unack_obj.chore.side))
            assert len(symbol_side_snapshot_list) == 1, \
                (f"found {len(symbol_side_snapshot_list)=}, must be exact 1 for symbol and side: "
                 f"{latest_unack_obj.chore.security.sec_id, latest_unack_obj.chore.side}")

            symbol_side_snapshot = symbol_side_snapshot_list[0]
            if side == Side.BUY:
                buy_symbol_side_snapshot = symbol_side_snapshot
            assert symbol_side_snapshot.total_qty == chore_snapshot.chore_brief.qty, \
                (f"Mismatched: expected symbol_side_snapshot.total_qty: {chore_snapshot.chore_brief.qty}, "
                 f"found {symbol_side_snapshot.total_qty = }")
            assert symbol_side_snapshot.avg_px == chore_snapshot.chore_brief.px, \
                (f"Mismatched: expected symbol_side_snapshot.avg_px: {chore_snapshot.chore_brief.px}, "
                 f"found {symbol_side_snapshot.avg_px = }")
            assert symbol_side_snapshot.total_filled_qty == 0, \
                (f"Mismatched: symbol_side_snapshot.total_filled_qty must be 0, found "
                 f"{symbol_side_snapshot.total_filled_qty = }")
            assert symbol_side_snapshot.total_fill_notional == 0, \
                (f"Mismatched: symbol_side_snapshot.total_fill_notional must be 0, found "
                 f"{symbol_side_snapshot.total_fill_notional = }")
            assert symbol_side_snapshot.avg_fill_px == 0, \
                (f"Mismatched: symbol_side_snapshot.avg_fill_px must be 0, found "
                 f"{symbol_side_snapshot.avg_fill_px = }")
            assert symbol_side_snapshot.total_cxled_qty == latest_unack_obj.chore.qty, \
                (f"Mismatched: symbol_side_snapshot.total_cxled_qty must be {latest_unack_obj.chore.qty}, found "
                 f"{symbol_side_snapshot.total_cxled_qty = }")
            assert (symbol_side_snapshot.total_cxled_notional ==
                    (latest_unack_obj.chore.qty * get_px_in_usd(latest_unack_obj.chore.px))), \
                (f"Mismatched: symbol_side_snapshot.total_cxled_notional must be "
                 f"{latest_unack_obj.chore.qty * get_px_in_usd(latest_unack_obj.chore.px)}, found "
                 f"{symbol_side_snapshot.total_cxled_notional = }")
            assert symbol_side_snapshot.avg_cxled_px == latest_unack_obj.chore.px, \
                (f"Mismatched: symbol_side_snapshot.avg_cxled_px must be {latest_unack_obj.chore.px}, found "
                 f"{symbol_side_snapshot.avg_cxled_px = }")
            assert symbol_side_snapshot.last_update_fill_px == 0, \
                (f"Mismatched: symbol_side_snapshot.last_update_fill_px must be 0, found "
                 f"{symbol_side_snapshot.last_update_fill_px = }")
            assert symbol_side_snapshot.last_update_fill_qty == 0, \
                (f"Mismatched: symbol_side_snapshot.last_update_fill_qty must be 0, found "
                 f"{symbol_side_snapshot.last_update_fill_qty = }")

            buy_last_barter_px, sell_last_barter_px = get_both_side_last_barter_px()
            plan_limits = executor_http_client.get_plan_limits_client(1)
            plan_brief = executor_http_client.get_plan_brief_client(active_pair_plan.id)
            if side == Side.BUY:
                plan_brief_bartering_brief = plan_brief.pair_buy_side_bartering_brief
                hedge_ratio = 1
            else:
                plan_brief_bartering_brief = plan_brief.pair_sell_side_bartering_brief
                hedge_ratio = active_pair_plan.pair_plan_params.hedge_ratio
            assert (plan_brief_bartering_brief.open_qty == 0), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_qty: "
                 f"0, found {plan_brief_bartering_brief.open_qty=}")
            assert (plan_brief_bartering_brief.open_notional == 0), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_notional: "
                 f"0, found {plan_brief_bartering_brief.open_notional=}")
            assert (plan_brief_bartering_brief.residual_qty == chore_snapshot.cxled_qty), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.residual_qty: "
                 f"{chore_snapshot.cxled_qty}, found {plan_brief_bartering_brief.open_notional=}")
            assert (plan_brief_bartering_brief.consumable_open_chores == 5), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_chores: "
                 f"5, found {plan_brief_bartering_brief.consumable_open_chores=}")
            assert (plan_brief_bartering_brief.all_bkr_cxlled_qty == chore_snapshot.cxled_qty), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.all_bkr_cxlled_qty: "
                 f"{chore_snapshot.cxled_qty}, found {plan_brief_bartering_brief.all_bkr_cxlled_qty=}")
            assert (plan_brief_bartering_brief.consumable_notional == (
                    (plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_notional: "
                 f"{(plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_notional = }")
            assert (plan_brief_bartering_brief.consumable_open_notional == plan_limits.max_open_single_leg_notional), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_notional: "
                 f"{plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_open_notional=}")
            total_security_size: int = \
                static_data.get_security_float_from_ticker(chore_snapshot.chore_brief.security.sec_id)
            assert (plan_brief_bartering_brief.consumable_concentration == (
                    (total_security_size / 100 * plan_limits.max_concentration) -
                    symbol_side_snapshot.total_filled_qty)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_concentration: "
                 f"{(total_security_size / 100 * plan_limits.max_concentration) - symbol_side_snapshot.total_filled_qty}, "
                 f"found {plan_brief_bartering_brief.consumable_concentration=}")
            assert (plan_brief_bartering_brief.consumable_cxl_qty == (
                    (((symbol_side_snapshot.total_filled_qty +
                       symbol_side_snapshot.total_cxled_qty) / 100) * plan_limits.cancel_rate.max_cancel_rate) -
                    symbol_side_snapshot.total_cxled_qty)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_cxl_qty: "
                 f"{plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_cxl_qty=}")
            other_side_residual_qty = 0
            if side == Side.BUY:
                current_last_barter_px = buy_last_barter_px
                other_last_barter_px = sell_last_barter_px
            else:
                current_last_barter_px = sell_last_barter_px
                other_last_barter_px = buy_last_barter_px
            assert (plan_brief_bartering_brief.indicative_consumable_residual == (
                    plan_limits.residual_restriction.max_residual -
                    ((plan_brief_bartering_brief.residual_qty *
                      get_px_in_usd(current_last_barter_px)) - (
                             other_side_residual_qty * get_px_in_usd(other_last_barter_px))))), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.indicative_consumable_residual: "
                 f"{plan_limits.residual_restriction.max_residual - ((plan_brief_bartering_brief.residual_qty * get_px_in_usd(current_last_barter_px)) - (other_side_residual_qty * get_px_in_usd(other_last_barter_px)))}, "
                 f"found {plan_brief_bartering_brief.indicative_consumable_residual=}")

            if side == Side.BUY:
                other_side_fill_notional = 0
            else:
                other_side_fill_notional = buy_symbol_side_snapshot.total_fill_notional
            assert (plan_brief.consumable_nett_filled_notional == (
                    plan_limits.max_net_filled_notional -
                    abs(symbol_side_snapshot.total_fill_notional - other_side_fill_notional))), \
                (
                    f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief."
                    f"consumable_nett_filled_notional: {plan_limits.max_open_single_leg_notional}, "
                    f"found {plan_brief.consumable_nett_filled_notional=}")

            plan_status = executor_http_client.get_plan_status_client(active_pair_plan.id)
            if side == Side.BUY:
                total_qty = plan_status.total_buy_qty
                total_open_qty = plan_status.total_open_buy_qty
                total_open_notional = plan_status.total_open_buy_notional
                avg_open_px = plan_status.avg_open_buy_px
                total_fill_qty = plan_status.total_fill_buy_qty
                total_fill_notional = plan_status.total_fill_buy_notional
                avg_fill_px = plan_status.avg_fill_buy_px
                total_cxl_qty = plan_status.total_cxl_buy_qty
                total_cxl_notional = plan_status.total_cxl_buy_notional
                avg_cxl_px = plan_status.avg_cxl_buy_px
            else:
                total_qty = plan_status.total_sell_qty
                total_open_qty = plan_status.total_open_sell_qty
                total_open_notional = plan_status.total_open_sell_notional
                avg_open_px = plan_status.avg_open_sell_px
                total_fill_qty = plan_status.total_fill_sell_qty
                total_fill_notional = plan_status.total_fill_sell_notional
                avg_fill_px = plan_status.avg_fill_sell_px
                total_cxl_qty = plan_status.total_cxl_sell_qty
                total_cxl_notional = plan_status.total_cxl_sell_notional
                avg_cxl_px = plan_status.avg_cxl_sell_px

            total_open_exposure = plan_status.total_open_exposure
            total_fill_exposure = plan_status.total_fill_exposure
            total_cxl_exposure = plan_status.total_cxl_exposure
            assert total_qty == chore_snapshot.chore_brief.qty, \
                (f"Mismatched: expected plan_status.total_{side.lower()}_qty: "
                 f"{chore_snapshot.chore_brief.qty}, found {total_qty=}")
            assert total_open_qty == 0, \
                (f"Mismatched: expected plan_status total_open_{side.lower()}_qty: "
                 f"0, found {total_open_qty=}")
            assert (total_open_notional == 0), \
                (f"Mismatched: expected plan_status.total_open_{side.lower()}_notional: "
                 f"0, found {total_open_notional=}")
            assert (avg_open_px == 0), \
                (f"Mismatched: expected plan_status.avg_open_{side.lower()}_px: "
                 f"0, found {avg_open_px=}")
            assert (total_fill_qty == 0), \
                (f"Mismatched: expected plan_status.total_fill_{side.lower()}_qty: "
                 f"0, found {total_fill_qty=}")
            assert (total_fill_notional == 0), \
                (f"Mismatched: expected plan_status.total_fill_{side.lower()}_notional: "
                 f"0, found {total_fill_notional=}")
            assert (avg_fill_px == 0), \
                (f"Mismatched: expected plan_status.avg_fill_{side.lower()}_px: "
                 f"0, found {avg_fill_px=}")
            assert (total_cxl_qty == qty), \
                (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_qty: "
                 f"{qty}, found {total_cxl_qty=}")
            assert (total_cxl_notional == qty * get_px_in_usd(px)), \
                (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_notional: "
                 f"{qty * get_px_in_usd(px)}, found {total_cxl_notional=}")
            assert (avg_cxl_px == px), \
                (f"Mismatched: expected plan_status.avg_cxl_{side.lower()}_px: "
                 f"{px}, found {avg_cxl_px=}")
            if side == Side.BUY:
                assert (total_open_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_open_exposure: "
                     f"0, found {total_open_exposure=}")
                assert (total_fill_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_fill_exposure: "
                     f"0, found {total_fill_exposure=}")
                assert (total_cxl_exposure == qty * get_px_in_usd(px)), \
                    (f"Mismatched: expected plan_status.total_cxl_exposure: "
                     f"{qty * get_px_in_usd(px)}, found {total_cxl_exposure=}")
            else:
                assert (total_open_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_open_exposure: "
                     f"0, found {total_open_exposure=}")
                assert (total_fill_exposure == buy_qty * get_px_in_usd(buy_px)), \
                    (f"Mismatched: expected plan_status.total_fill_exposure: "
                     f"{buy_qty * get_px_in_usd(px)}, found {total_fill_exposure=}")
                assert (total_cxl_exposure == - qty * get_px_in_usd(px)), \
                    (f"Mismatched: expected plan_status.total_cxl_exposure: "
                     f"{- qty * get_px_in_usd(px)}, found {total_cxl_exposure=}")

            contact_status = email_book_service_native_web_client.get_contact_status_client(1)
            if side == Side.BUY:
                overall_notional = contact_status.overall_buy_notional
            else:
                overall_notional = contact_status.overall_sell_notional
            assert (overall_notional == 0), \
                (f"Mismatched: expected contact_status.overall_{side.lower()}_notional: "
                 f"0, found {overall_notional=}")

            # applying ack leading to fulfill
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_unack_obj.chore.chore_id, latest_unack_obj.chore.px,
                latest_unack_obj.chore.qty, latest_unack_obj.chore.side, latest_unack_obj.chore.security.sec_id,
                latest_unack_obj.chore.underlying_account)
            chore_snapshot = get_chore_snapshot_from_chore_id(latest_unack_obj.chore.chore_id,
                                                              executor_http_client)

            if executor_config_dict.get("pause_fulfill_post_chore_dod"):
                assert chore_snapshot.filled_qty == 0, f"Mismatch chore_snapshot.filled_qty, expected 0, " \
                                                       f"received {chore_snapshot.filled_qty}"
                assert chore_snapshot.cxled_qty == chore_snapshot.chore_brief.qty, \
                    f"Mismatch chore_snapshot.cxled_qty: expected {chore_snapshot.chore_brief.qty}, received " \
                    f"{chore_snapshot.cxled_qty}"
                assert chore_snapshot.chore_status == ChoreStatusType.OE_DOD, \
                    f"Mismatch chore_snapshot.chore_status: expected ChoreStatusType.OE_DOD, " \
                    f"received {chore_snapshot.chore_status}"
            else:
                assert chore_snapshot.chore_status == ChoreStatusType.OE_FILLED, \
                    f"Mismatched: Chore status must be OE_FILLED but found: {chore_snapshot.chore_status = }"
                assert chore_snapshot.cxled_qty == 0, \
                    (f"Mismatched: ChoreSnapshot cxled_qty must be 0, found "
                     f"{chore_snapshot.cxled_qty}")
                assert chore_snapshot.cxled_notional == 0, \
                    (f"Mismatched: ChoreSnapshot cxled_notional must be "
                     f"0, found {chore_snapshot.cxled_notional}")
                assert chore_snapshot.avg_cxled_px == 0, \
                    (f"Mismatched: ChoreSnapshot avg_cxled_px must be "
                     f"0, found {chore_snapshot.avg_cxled_px}")
                assert chore_snapshot.filled_qty == qty, \
                    f"Mismatched: ChoreSnapshot avg_cxled_px must be {qty}, found {chore_snapshot.filled_qty}"
                assert chore_snapshot.fill_notional == qty * get_px_in_usd(px), \
                    (f"Mismatched: ChoreSnapshot fill_notional must be {qty * get_px_in_usd(px)}, "
                     f"found {chore_snapshot.fill_notional}")
                assert chore_snapshot.avg_fill_px == px, \
                    f"Mismatched: ChoreSnapshot avg_fill_px must be {px}, found {chore_snapshot.avg_fill_px}"

                symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        latest_unack_obj.chore.security.sec_id, latest_unack_obj.chore.side))
                assert len(symbol_side_snapshot_list) == 1, \
                    (f"found {len(symbol_side_snapshot_list) = }, must be exact 1 for symbol and side: "
                     f"{latest_unack_obj.chore.security.sec_id, latest_unack_obj.chore.side}")

                symbol_side_snapshot = symbol_side_snapshot_list[0]
                if side == Side.BUY:
                    buy_symbol_side_snapshot = symbol_side_snapshot
                assert symbol_side_snapshot.total_qty == qty, \
                    (f"Mismatched: expected symbol_side_snapshot.total_qty: {qty}, "
                     f"found {symbol_side_snapshot.total_qty = }")
                assert symbol_side_snapshot.avg_px == px, \
                    (f"Mismatched: expected symbol_side_snapshot.avg_px: {px}, "
                     f"found {symbol_side_snapshot.avg_px = }")
                assert symbol_side_snapshot.total_filled_qty == qty, \
                    (f"Mismatched: symbol_side_snapshot.total_filled_qty must be {qty}, found "
                     f"{symbol_side_snapshot.total_filled_qty = }")
                assert symbol_side_snapshot.total_fill_notional == qty * get_px_in_usd(px), \
                    (f"Mismatched: symbol_side_snapshot.total_fill_notional must be {qty * get_px_in_usd(px)}, "
                     f"found {symbol_side_snapshot.total_fill_notional = }")
                assert symbol_side_snapshot.avg_fill_px == px, \
                    (f"Mismatched: symbol_side_snapshot.avg_fill_px must be {px}, found "
                     f"{symbol_side_snapshot.avg_fill_px = }")
                assert symbol_side_snapshot.total_cxled_qty == 0, \
                    (f"Mismatched: symbol_side_snapshot.total_cxled_qty must be 0, found "
                     f"{symbol_side_snapshot.total_cxled_qty = }")
                assert (symbol_side_snapshot.total_cxled_notional == 0), \
                    (f"Mismatched: symbol_side_snapshot.total_cxled_notional must be "
                     f"0, found {symbol_side_snapshot.total_cxled_notional = }")
                assert symbol_side_snapshot.avg_cxled_px == 0, \
                    (f"Mismatched: symbol_side_snapshot.avg_cxled_px must be 0, found "
                     f"{symbol_side_snapshot.avg_cxled_px = }")
                assert symbol_side_snapshot.last_update_fill_px == px, \
                    (f"Mismatched: symbol_side_snapshot.last_update_fill_px must be {px}, found "
                     f"{symbol_side_snapshot.last_update_fill_px = }")
                assert symbol_side_snapshot.last_update_fill_qty == qty, \
                    (f"Mismatched: symbol_side_snapshot.last_update_fill_qty must be {qty}, found "
                     f"{symbol_side_snapshot.last_update_fill_qty = }")

                buy_last_barter_px, sell_last_barter_px = get_both_side_last_barter_px()
                plan_limits = executor_http_client.get_plan_limits_client(1)
                plan_brief = executor_http_client.get_plan_brief_client(active_pair_plan.id)
                if side == Side.BUY:
                    plan_brief_bartering_brief = plan_brief.pair_buy_side_bartering_brief
                else:
                    plan_brief_bartering_brief = plan_brief.pair_sell_side_bartering_brief
                assert (plan_brief_bartering_brief.open_qty == 0), \
                    (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_qty: "
                     f"0, found {plan_brief_bartering_brief.open_qty = }")
                assert (plan_brief_bartering_brief.open_notional == 0), \
                    (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_notional: "
                     f"0, found {plan_brief_bartering_brief.open_notional = }")
                assert (plan_brief_bartering_brief.residual_qty == 0), \
                    (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.residual_qty: "
                     f"0, found {plan_brief_bartering_brief.residual_qty = }")
                assert (plan_brief_bartering_brief.consumable_open_chores == 5), \
                    (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_chores: "
                     f"5, found {plan_brief_bartering_brief.consumable_open_chores = }")
                assert (plan_brief_bartering_brief.all_bkr_cxlled_qty == 0), \
                    (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.all_bkr_cxlled_qty: "
                     f"0, found {plan_brief_bartering_brief.all_bkr_cxlled_qty = }")
                assert (plan_brief_bartering_brief.consumable_notional == (
                        (plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional)), \
                    (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_notional: "
                     f"{(plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional}, "
                     f"found {plan_brief_bartering_brief.consumable_notional = }")
                assert (plan_brief_bartering_brief.consumable_open_notional == plan_limits.max_open_single_leg_notional), \
                    (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_notional: "
                     f"{plan_limits.max_open_single_leg_notional}, "
                     f"found {plan_brief_bartering_brief.consumable_open_notional = }")
                total_security_size: int = \
                    static_data.get_security_float_from_ticker(chore_snapshot.chore_brief.security.sec_id)
                assert (plan_brief_bartering_brief.consumable_concentration == (
                        (total_security_size / 100 * plan_limits.max_concentration) -
                        symbol_side_snapshot.total_filled_qty)), \
                    (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_concentration: "
                     f"{(total_security_size / 100 * plan_limits.max_concentration) - symbol_side_snapshot.total_filled_qty}, "
                     f"found {plan_brief_bartering_brief.consumable_concentration = }")
                assert (plan_brief_bartering_brief.consumable_cxl_qty == (
                        (((symbol_side_snapshot.total_filled_qty +
                           symbol_side_snapshot.total_cxled_qty) / 100) * plan_limits.cancel_rate.max_cancel_rate) -
                        symbol_side_snapshot.total_cxled_qty)), \
                    (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_cxl_qty: "
                     f"{plan_limits.max_open_single_leg_notional}, "
                     f"found {plan_brief_bartering_brief.consumable_cxl_qty = }")
                other_side_residual_qty = 0
                assert (plan_brief_bartering_brief.indicative_consumable_residual == (
                        plan_limits.residual_restriction.max_residual -
                        ((plan_brief_bartering_brief.residual_qty *
                          get_px_in_usd(current_last_barter_px)) - (
                                 other_side_residual_qty * get_px_in_usd(other_last_barter_px))))), \
                    (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.indicative_consumable_residual: "
                     f"{plan_limits.residual_restriction.max_residual - ((plan_brief_bartering_brief.residual_qty * get_px_in_usd(current_last_barter_px)) - (other_side_residual_qty * get_px_in_usd(other_last_barter_px)))}, "
                     f"found {plan_brief_bartering_brief.indicative_consumable_residual = }")

                if side == Side.BUY:
                    other_side_fill_notional = 0
                else:
                    other_side_fill_notional = buy_symbol_side_snapshot.total_fill_notional
                assert (plan_brief.consumable_nett_filled_notional == (
                        plan_limits.max_net_filled_notional -
                        abs(symbol_side_snapshot.total_fill_notional - other_side_fill_notional))), \
                    (
                        f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief."
                        f"consumable_nett_filled_notional: {plan_limits.max_open_single_leg_notional}, "
                        f"found {plan_brief.consumable_nett_filled_notional = }")

                plan_status = executor_http_client.get_plan_status_client(active_pair_plan.id)
                if side == Side.BUY:
                    total_qty = plan_status.total_buy_qty
                    total_open_qty = plan_status.total_open_buy_qty
                    total_open_notional = plan_status.total_open_buy_notional
                    avg_open_px = plan_status.avg_open_buy_px
                    total_fill_qty = plan_status.total_fill_buy_qty
                    total_fill_notional = plan_status.total_fill_buy_notional
                    avg_fill_px = plan_status.avg_fill_buy_px
                    total_cxl_qty = plan_status.total_cxl_buy_qty
                    total_cxl_notional = plan_status.total_cxl_buy_notional
                    avg_cxl_px = plan_status.avg_cxl_buy_px
                else:
                    total_qty = plan_status.total_sell_qty
                    total_open_qty = plan_status.total_open_sell_qty
                    total_open_notional = plan_status.total_open_sell_notional
                    avg_open_px = plan_status.avg_open_sell_px
                    total_fill_qty = plan_status.total_fill_sell_qty
                    total_fill_notional = plan_status.total_fill_sell_notional
                    avg_fill_px = plan_status.avg_fill_sell_px
                    total_cxl_qty = plan_status.total_cxl_sell_qty
                    total_cxl_notional = plan_status.total_cxl_sell_notional
                    avg_cxl_px = plan_status.avg_cxl_sell_px

                total_open_exposure = plan_status.total_open_exposure
                total_fill_exposure = plan_status.total_fill_exposure
                total_cxl_exposure = plan_status.total_cxl_exposure
                assert total_qty == qty, \
                    (f"Mismatched: expected plan_status.total_{side.lower()}_qty: "
                     f"{qty}, found {total_qty = }")
                assert total_open_qty == 0, \
                    (f"Mismatched: expected plan_status total_open_{side.lower()}_qty: "
                     f"0, found {total_open_qty = }")
                assert (total_open_notional == 0), \
                    (f"Mismatched: expected plan_status.total_open_{side.lower()}_notional: "
                     f"0, found {total_open_notional = }")
                assert (avg_open_px == 0), \
                    (f"Mismatched: expected plan_status.avg_open_{side.lower()}_px: "
                     f"0, found {avg_open_px = }")
                assert (total_fill_qty == qty), \
                    (f"Mismatched: expected plan_status.total_fill_{side.lower()}_qty: "
                     f"{qty}, found {total_fill_qty = }")
                assert (total_fill_notional == qty * get_px_in_usd(px)), \
                    (f"Mismatched: expected plan_status.total_fill_{side.lower()}_notional: "
                     f"{qty * get_px_in_usd(px)}, found {total_fill_notional = }")
                assert (avg_fill_px == px), \
                    (f"Mismatched: expected plan_status.avg_fill_{side.lower()}_px: "
                     f"{px}, found {avg_fill_px = }")
                assert (total_cxl_qty == 0), \
                    (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_qty: "
                     f"0, found {total_cxl_qty = }")
                assert (total_cxl_notional == 0), \
                    (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_notional: "
                     f"0, found {total_cxl_notional = }")
                assert (avg_cxl_px == 0), \
                    (f"Mismatched: expected plan_status.avg_cxl_{side.lower()}_px: "
                     f"0, found {avg_cxl_px = }")
                if side == Side.BUY:
                    assert (total_open_exposure == 0), \
                        (f"Mismatched: expected plan_status.total_open_exposure: "
                         f"0, found {total_open_exposure = }")
                    assert (total_fill_exposure == qty * get_px_in_usd(px)), \
                        (f"Mismatched: expected plan_status.total_fill_exposure: "
                         f"{qty * get_px_in_usd(px)}, found {total_fill_exposure = }")
                    assert (total_cxl_exposure == 0), \
                        (f"Mismatched: expected plan_status.total_cxl_exposure: "
                         f"0, found {total_cxl_exposure = }")
                else:
                    assert (total_open_exposure == 0), \
                        (f"Mismatched: expected plan_status.total_open_exposure: "
                         f"0, found {total_open_exposure = }")
                    assert (total_fill_exposure == (
                            buy_qty * get_px_in_usd(buy_px) - qty * get_px_in_usd(px))), \
                        (f"Mismatched: expected plan_status.total_fill_exposure: "
                         f"{buy_qty * get_px_in_usd(buy_px) - qty * get_px_in_usd(px)}, "
                         f"found {total_fill_exposure = }")
                    assert (total_cxl_exposure == 0), \
                        (f"Mismatched: expected plan_status.total_cxl_exposure: "
                         f"0, found {total_cxl_exposure = }")

                contact_status = email_book_service_native_web_client.get_contact_status_client(1)
                if side == Side.BUY:
                    overall_notional = contact_status.overall_buy_notional
                else:
                    overall_notional = contact_status.overall_sell_notional
                assert (overall_notional == qty * get_px_in_usd(px)), \
                    (f"Mismatched: expected contact_status.overall_{side.lower()}_notional: "
                     f"{qty * get_px_in_usd(px)}, found {overall_notional = }")

            # Checking alert in plan_alert
            time.sleep(2)
            if executor_config_dict.get("pause_fulfill_post_chore_dod"):
                check_str = ("Unexpected: Received fill that makes chore_snapshot OE_FILLED which is already of "
                             "state OE_DOD, ignoring this fill and putting this plan to PAUSE")
                time.sleep(2)

                pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
                assert pair_plan.plan_state == PlanState.PlanState_PAUSED, \
                    f"Mismatch: pair_plan must have plan_state PAUSED but found {pair_plan.plan_state = }"
            else:
                check_str = "Received fill that makes chore_snapshot OE_FILLED which is already of state OE_DOD"
                time.sleep(2)

            assert_fail_msg = f"Can't find alert of {check_str} in neither plan_alert nor contact_alert"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_overfill_post_unack_unsol_cxl(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["simulate_new_unsolicited_cxl_chores"] = True
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        buy_symbol_side_snapshot = None
        buy_overfill_qty = None
        buy_px = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            # buy test
            overfill_qty = qty + 10  # extra to make overfill
            if side == Side.BUY:
                buy_overfill_qty = overfill_qty
                buy_px = px

            run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            latest_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW, chore_symbol,
                                                                              executor_http_client)
            latest_cxl_ack_obj = get_latest_chore_journal_with_events_and_symbol([ChoreEventType.OE_CXL_ACK,
                                                                                  ChoreEventType.OE_UNSOL_CXL], chore_symbol,
                                                                                 executor_http_client)

            chore_snapshot = get_chore_snapshot_from_chore_id(latest_unack_obj.chore.chore_id,
                                                              executor_http_client)
            assert chore_snapshot.chore_status == ChoreStatusType.OE_DOD, \
                f"Mismatched: Chore status must be DOD but found: {chore_snapshot.chore_status = }"
            assert chore_snapshot.cxled_qty == latest_unack_obj.chore.qty, \
                (f"Mismatched: ChoreSnapshot cxled_qty must be {latest_unack_obj.chore.qty}, found "
                 f"{chore_snapshot.cxled_qty}")
            assert chore_snapshot.cxled_notional == qty * get_px_in_usd(px), \
                (f"Mismatched: ChoreSnapshot cxled_notional must be "
                 f"{qty * get_px_in_usd(px)}, found {chore_snapshot.cxled_notional}")
            assert chore_snapshot.avg_cxled_px == latest_unack_obj.chore.px, \
                (f"Mismatched: ChoreSnapshot avg_cxled_px must be "
                 f"{latest_unack_obj.chore.px}, found {chore_snapshot.avg_cxled_px}")
            assert chore_snapshot.filled_qty == 0, \
                f"Mismatched: ChoreSnapshot avg_cxled_px must be 0, found {chore_snapshot.filled_qty}"
            assert chore_snapshot.fill_notional == 0, \
                f"Mismatched: ChoreSnapshot fill_notional must be 0, found {chore_snapshot.fill_notional}"
            assert chore_snapshot.avg_fill_px == 0, \
                f"Mismatched: ChoreSnapshot avg_fill_px must be 0, found {chore_snapshot.avg_fill_px}"

            symbol_side_snapshot_list = (
                executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                    latest_unack_obj.chore.security.sec_id, latest_unack_obj.chore.side))
            assert len(symbol_side_snapshot_list) == 1, \
                (f"found {len(symbol_side_snapshot_list) = }, must be exact 1 for symbol and side: "
                 f"{latest_unack_obj.chore.security.sec_id, latest_unack_obj.chore.side}")

            symbol_side_snapshot = symbol_side_snapshot_list[0]
            if side == Side.BUY:
                buy_symbol_side_snapshot = symbol_side_snapshot
            assert symbol_side_snapshot.total_qty == chore_snapshot.chore_brief.qty, \
                (f"Mismatched: expected symbol_side_snapshot.total_qty: {chore_snapshot.chore_brief.qty}, "
                 f"found {symbol_side_snapshot.total_qty = }")
            assert symbol_side_snapshot.avg_px == chore_snapshot.chore_brief.px, \
                (f"Mismatched: expected symbol_side_snapshot.avg_px: {chore_snapshot.chore_brief.px}, "
                 f"found {symbol_side_snapshot.avg_px = }")
            assert symbol_side_snapshot.total_filled_qty == 0, \
                (f"Mismatched: symbol_side_snapshot.total_filled_qty must be 0, found "
                 f"{symbol_side_snapshot.total_filled_qty = }")
            assert symbol_side_snapshot.total_fill_notional == 0, \
                (f"Mismatched: symbol_side_snapshot.total_fill_notional must be 0, found "
                 f"{symbol_side_snapshot.total_fill_notional = }")
            assert symbol_side_snapshot.avg_fill_px == 0, \
                (f"Mismatched: symbol_side_snapshot.avg_fill_px must be 0, found "
                 f"{symbol_side_snapshot.avg_fill_px = }")
            assert symbol_side_snapshot.total_cxled_qty == latest_unack_obj.chore.qty, \
                (f"Mismatched: symbol_side_snapshot.total_cxled_qty must be {latest_unack_obj.chore.qty}, found "
                 f"{symbol_side_snapshot.total_cxled_qty = }")
            assert (symbol_side_snapshot.total_cxled_notional ==
                    (latest_unack_obj.chore.qty * get_px_in_usd(latest_unack_obj.chore.px))), \
                (f"Mismatched: symbol_side_snapshot.total_cxled_notional must be "
                 f"{latest_unack_obj.chore.qty * get_px_in_usd(latest_unack_obj.chore.px)}, found "
                 f"{symbol_side_snapshot.total_cxled_notional = }")
            assert symbol_side_snapshot.avg_cxled_px == latest_unack_obj.chore.px, \
                (f"Mismatched: symbol_side_snapshot.avg_cxled_px must be {latest_unack_obj.chore.px}, found "
                 f"{symbol_side_snapshot.avg_cxled_px = }")
            assert symbol_side_snapshot.last_update_fill_px == 0, \
                (f"Mismatched: symbol_side_snapshot.last_update_fill_px must be 0, found "
                 f"{symbol_side_snapshot.last_update_fill_px = }")
            assert symbol_side_snapshot.last_update_fill_qty == 0, \
                (f"Mismatched: symbol_side_snapshot.last_update_fill_qty must be 0, found "
                 f"{symbol_side_snapshot.last_update_fill_qty = }")

            buy_last_barter_px, sell_last_barter_px = get_both_side_last_barter_px()
            plan_limits = executor_http_client.get_plan_limits_client(1)
            plan_brief = executor_http_client.get_plan_brief_client(active_pair_plan.id)
            if side == Side.BUY:
                plan_brief_bartering_brief = plan_brief.pair_buy_side_bartering_brief
                hedge_ratio = 1
            else:
                plan_brief_bartering_brief = plan_brief.pair_sell_side_bartering_brief
                hedge_ratio = active_pair_plan.pair_plan_params.hedge_ratio
            assert (plan_brief_bartering_brief.open_qty == 0), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_qty: "
                 f"0, found {plan_brief_bartering_brief.open_qty = }")
            assert (plan_brief_bartering_brief.open_notional == 0), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_notional: "
                 f"0, found {plan_brief_bartering_brief.open_notional = }")
            assert (plan_brief_bartering_brief.residual_qty == chore_snapshot.cxled_qty), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.residual_qty: "
                 f"{chore_snapshot.cxled_qty}, found {plan_brief_bartering_brief.open_notional = }")
            assert (plan_brief_bartering_brief.consumable_open_chores == 5), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_chores: "
                 f"5, found {plan_brief_bartering_brief.consumable_open_chores = }")
            assert (plan_brief_bartering_brief.all_bkr_cxlled_qty == chore_snapshot.cxled_qty), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.all_bkr_cxlled_qty: "
                 f"{chore_snapshot.cxled_qty}, found {plan_brief_bartering_brief.all_bkr_cxlled_qty = }")
            assert (plan_brief_bartering_brief.consumable_notional == (
                    (plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_notional: "
                 f"{(plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_notional = }")
            assert (plan_brief_bartering_brief.consumable_open_notional == plan_limits.max_open_single_leg_notional), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_notional: "
                 f"{plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_open_notional = }")
            total_security_size: int = \
                static_data.get_security_float_from_ticker(chore_snapshot.chore_brief.security.sec_id)
            assert (plan_brief_bartering_brief.consumable_concentration == (
                    (total_security_size / 100 * plan_limits.max_concentration) -
                    symbol_side_snapshot.total_filled_qty)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_concentration: "
                 f"{(total_security_size / 100 * plan_limits.max_concentration) - symbol_side_snapshot.total_filled_qty}, "
                 f"found {plan_brief_bartering_brief.consumable_concentration = }")
            assert (plan_brief_bartering_brief.consumable_cxl_qty == (
                    (((symbol_side_snapshot.total_filled_qty +
                       symbol_side_snapshot.total_cxled_qty) / 100) * plan_limits.cancel_rate.max_cancel_rate) -
                    symbol_side_snapshot.total_cxled_qty)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_cxl_qty: "
                 f"{plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_cxl_qty = }")
            other_side_residual_qty = 0
            if side == Side.BUY:
                current_last_barter_px = buy_last_barter_px
                other_last_barter_px = sell_last_barter_px
            else:
                current_last_barter_px = sell_last_barter_px
                other_last_barter_px = buy_last_barter_px
            assert (plan_brief_bartering_brief.indicative_consumable_residual == (
                    plan_limits.residual_restriction.max_residual -
                    ((plan_brief_bartering_brief.residual_qty *
                      get_px_in_usd(current_last_barter_px)) - (
                            other_side_residual_qty * get_px_in_usd(other_last_barter_px))))), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.indicative_consumable_residual: "
                 f"{plan_limits.residual_restriction.max_residual - ((plan_brief_bartering_brief.residual_qty * get_px_in_usd(current_last_barter_px)) - (other_side_residual_qty * get_px_in_usd(other_last_barter_px)))}, "
                 f"found {plan_brief_bartering_brief.indicative_consumable_residual = }")

            if side == Side.BUY:
                other_side_fill_notional = 0
            else:
                other_side_fill_notional = buy_symbol_side_snapshot.total_fill_notional
            assert (plan_brief.consumable_nett_filled_notional == (
                    plan_limits.max_net_filled_notional -
                    abs(symbol_side_snapshot.total_fill_notional - other_side_fill_notional))), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief."
                 f"consumable_nett_filled_notional: {plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief.consumable_nett_filled_notional=}")

            plan_status = executor_http_client.get_plan_status_client(active_pair_plan.id)
            if side == Side.BUY:
                total_qty = plan_status.total_buy_qty
                total_open_qty = plan_status.total_open_buy_qty
                total_open_notional = plan_status.total_open_buy_notional
                avg_open_px = plan_status.avg_open_buy_px
                total_fill_qty = plan_status.total_fill_buy_qty
                total_fill_notional = plan_status.total_fill_buy_notional
                avg_fill_px = plan_status.avg_fill_buy_px
                total_cxl_qty = plan_status.total_cxl_buy_qty
                total_cxl_notional = plan_status.total_cxl_buy_notional
                avg_cxl_px = plan_status.avg_cxl_buy_px
            else:
                total_qty = plan_status.total_sell_qty
                total_open_qty = plan_status.total_open_sell_qty
                total_open_notional = plan_status.total_open_sell_notional
                avg_open_px = plan_status.avg_open_sell_px
                total_fill_qty = plan_status.total_fill_sell_qty
                total_fill_notional = plan_status.total_fill_sell_notional
                avg_fill_px = plan_status.avg_fill_sell_px
                total_cxl_qty = plan_status.total_cxl_sell_qty
                total_cxl_notional = plan_status.total_cxl_sell_notional
                avg_cxl_px = plan_status.avg_cxl_sell_px

            total_open_exposure = plan_status.total_open_exposure
            total_fill_exposure = plan_status.total_fill_exposure
            total_cxl_exposure = plan_status.total_cxl_exposure
            assert total_qty == chore_snapshot.chore_brief.qty, \
                (f"Mismatched: expected plan_status.total_{side.lower()}_qty: "
                 f"{chore_snapshot.chore_brief.qty}, found {total_qty = }")
            assert total_open_qty == 0, \
                (f"Mismatched: expected plan_status total_open_{side.lower()}_qty: "
                 f"0, found {total_open_qty = }")
            assert (total_open_notional == 0), \
                (f"Mismatched: expected plan_status.total_open_{side.lower()}_notional: "
                 f"0, found {total_open_notional = }")
            assert (avg_open_px == 0), \
                (f"Mismatched: expected plan_status.avg_open_{side.lower()}_px: "
                 f"0, found {avg_open_px = }")
            assert (total_fill_qty == 0), \
                (f"Mismatched: expected plan_status.total_fill_{side.lower()}_qty: "
                 f"0, found {total_fill_qty = }")
            assert (total_fill_notional == 0), \
                (f"Mismatched: expected plan_status.total_fill_{side.lower()}_notional: "
                 f"0, found {total_fill_notional = }")
            assert (avg_fill_px == 0), \
                (f"Mismatched: expected plan_status.avg_fill_{side.lower()}_px: "
                 f"0, found {avg_fill_px = }")
            assert (total_cxl_qty == qty), \
                (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_qty: "
                 f"{qty}, found {total_cxl_qty = }")
            assert (total_cxl_notional == qty * get_px_in_usd(px)), \
                (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_notional: "
                 f"{qty * get_px_in_usd(px)}, found {total_cxl_notional = }")
            assert (avg_cxl_px == px), \
                (f"Mismatched: expected plan_status.avg_cxl_{side.lower()}_px: "
                 f"{px}, found {avg_cxl_px = }")
            if side == Side.BUY:
                assert (total_open_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_open_exposure: "
                     f"0, found {total_open_exposure = }")
                assert (total_fill_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_fill_exposure: "
                     f"0, found {total_fill_exposure = }")
                assert (total_cxl_exposure == qty * get_px_in_usd(px)), \
                    (f"Mismatched: expected plan_status.total_cxl_exposure: "
                     f"{qty * get_px_in_usd(px)}, found {total_cxl_exposure = }")
            else:
                assert (total_open_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_open_exposure: "
                     f"0, found {total_open_exposure = }")
                assert (total_fill_exposure == buy_overfill_qty * get_px_in_usd(buy_px)), \
                    (f"Mismatched: expected plan_status.total_fill_exposure: "
                     f"{buy_overfill_qty * get_px_in_usd(px)}, found {total_fill_exposure = }")
                assert (total_cxl_exposure == - qty * get_px_in_usd(px)), \
                    (f"Mismatched: expected plan_status.total_cxl_exposure: "
                     f"{- qty * get_px_in_usd(px)}, found {total_cxl_exposure = }")

            contact_status = email_book_service_native_web_client.get_contact_status_client(1)
            if side == Side.BUY:
                overall_notional = contact_status.overall_buy_notional
            else:
                overall_notional = contact_status.overall_sell_notional
            assert (overall_notional == 0), \
                (f"Mismatched: expected contact_status.overall_{side.lower()}_notional: "
                 f"0, found {overall_notional = }")

            # applying ack leading to overfill
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_unack_obj.chore.chore_id, latest_unack_obj.chore.px, overfill_qty,
                latest_unack_obj.chore.side, latest_unack_obj.chore.security.sec_id,
                latest_unack_obj.chore.underlying_account, use_exact_passed_qty=True)

            chore_snapshot = get_chore_snapshot_from_chore_id(latest_unack_obj.chore.chore_id,
                                                              executor_http_client)
            assert chore_snapshot.chore_status == ChoreStatusType.OE_OVER_FILLED, \
                f"Mismatched: Chore status must be OE_OVER_FILLED but found: {chore_snapshot.chore_status = }"
            assert chore_snapshot.cxled_qty == 0, \
                (f"Mismatched: ChoreSnapshot cxled_qty must be 0, found "
                 f"{chore_snapshot.cxled_qty}")
            assert chore_snapshot.cxled_notional == 0, \
                (f"Mismatched: ChoreSnapshot cxled_notional must be "
                 f"0, found {chore_snapshot.cxled_notional}")
            assert chore_snapshot.avg_cxled_px == 0, \
                (f"Mismatched: ChoreSnapshot avg_cxled_px must be "
                 f"0, found {chore_snapshot.avg_cxled_px}")
            assert chore_snapshot.filled_qty == overfill_qty, \
                f"Mismatched: ChoreSnapshot avg_cxled_px must be {overfill_qty}, found {chore_snapshot.filled_qty}"
            assert chore_snapshot.fill_notional == overfill_qty * get_px_in_usd(px), \
                (f"Mismatched: ChoreSnapshot fill_notional must be {overfill_qty * get_px_in_usd(px)}, "
                 f"found {chore_snapshot.fill_notional}")
            assert chore_snapshot.avg_fill_px == px, \
                f"Mismatched: ChoreSnapshot avg_fill_px must be {px}, found {chore_snapshot.avg_fill_px}"

            symbol_side_snapshot_list = (
                executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                    latest_unack_obj.chore.security.sec_id, latest_unack_obj.chore.side))
            assert len(symbol_side_snapshot_list) == 1, \
                (f"found {len(symbol_side_snapshot_list) = }, must be exact 1 for symbol and side: "
                 f"{latest_unack_obj.chore.security.sec_id, latest_unack_obj.chore.side}")

            symbol_side_snapshot = symbol_side_snapshot_list[0]
            if side == Side.BUY:
                buy_symbol_side_snapshot = symbol_side_snapshot
            assert symbol_side_snapshot.total_qty == qty, \
                (f"Mismatched: expected symbol_side_snapshot.total_qty: {qty}, "
                 f"found {symbol_side_snapshot.total_qty = }")
            assert symbol_side_snapshot.avg_px == px, \
                (f"Mismatched: expected symbol_side_snapshot.avg_px: {px}, "
                 f"found {symbol_side_snapshot.avg_px = }")
            assert symbol_side_snapshot.total_filled_qty == overfill_qty, \
                (f"Mismatched: symbol_side_snapshot.total_filled_qty must be {overfill_qty}, found "
                 f"{symbol_side_snapshot.total_filled_qty = }")
            assert symbol_side_snapshot.total_fill_notional == overfill_qty * get_px_in_usd(px), \
                (f"Mismatched: symbol_side_snapshot.total_fill_notional must be {overfill_qty * get_px_in_usd(px)}, "
                 f"found {symbol_side_snapshot.total_fill_notional = }")
            assert symbol_side_snapshot.avg_fill_px == px, \
                (f"Mismatched: symbol_side_snapshot.avg_fill_px must be {px}, found "
                 f"{symbol_side_snapshot.avg_fill_px = }")
            assert symbol_side_snapshot.total_cxled_qty == 0, \
                (f"Mismatched: symbol_side_snapshot.total_cxled_qty must be 0, found "
                 f"{symbol_side_snapshot.total_cxled_qty = }")
            assert (symbol_side_snapshot.total_cxled_notional == 0), \
                (f"Mismatched: symbol_side_snapshot.total_cxled_notional must be "
                 f"0, found {symbol_side_snapshot.total_cxled_notional = }")
            assert symbol_side_snapshot.avg_cxled_px == 0, \
                (f"Mismatched: symbol_side_snapshot.avg_cxled_px must be 0, found "
                 f"{symbol_side_snapshot.avg_cxled_px = }")
            assert symbol_side_snapshot.last_update_fill_px == px, \
                (f"Mismatched: symbol_side_snapshot.last_update_fill_px must be {px}, found "
                 f"{symbol_side_snapshot.last_update_fill_px = }")
            assert symbol_side_snapshot.last_update_fill_qty == overfill_qty, \
                (f"Mismatched: symbol_side_snapshot.last_update_fill_qty must be {overfill_qty}, found "
                 f"{symbol_side_snapshot.last_update_fill_qty = }")

            buy_last_barter_px, sell_last_barter_px = get_both_side_last_barter_px()
            plan_limits = executor_http_client.get_plan_limits_client(1)
            plan_brief = executor_http_client.get_plan_brief_client(active_pair_plan.id)
            if side == Side.BUY:
                plan_brief_bartering_brief = plan_brief.pair_buy_side_bartering_brief
            else:
                plan_brief_bartering_brief = plan_brief.pair_sell_side_bartering_brief
            assert (plan_brief_bartering_brief.open_qty == 0), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_qty: "
                 f"0, found {plan_brief_bartering_brief.open_qty = }")
            assert (plan_brief_bartering_brief.open_notional == 0), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_notional: "
                 f"0, found {plan_brief_bartering_brief.open_notional = }")
            assert (plan_brief_bartering_brief.residual_qty == 0), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.residual_qty: "
                 f"0, found {plan_brief_bartering_brief.residual_qty = }")
            assert (plan_brief_bartering_brief.consumable_open_chores == 5), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_chores: "
                 f"5, found {plan_brief_bartering_brief.consumable_open_chores = }")
            assert (plan_brief_bartering_brief.all_bkr_cxlled_qty == 0), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.all_bkr_cxlled_qty: "
                 f"0, found {plan_brief_bartering_brief.all_bkr_cxlled_qty = }")
            assert (plan_brief_bartering_brief.consumable_notional == (
                    (plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_notional: "
                 f"{(plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_notional = }")
            assert (plan_brief_bartering_brief.consumable_open_notional == plan_limits.max_open_single_leg_notional), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_notional: "
                 f"{plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_open_notional = }")
            total_security_size: int = \
                static_data.get_security_float_from_ticker(chore_snapshot.chore_brief.security.sec_id)
            assert (plan_brief_bartering_brief.consumable_concentration == (
                    (total_security_size / 100 * plan_limits.max_concentration) -
                    symbol_side_snapshot.total_filled_qty)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_concentration: "
                 f"{(total_security_size / 100 * plan_limits.max_concentration) - symbol_side_snapshot.total_filled_qty}, "
                 f"found {plan_brief_bartering_brief.consumable_concentration = }")
            assert (plan_brief_bartering_brief.consumable_cxl_qty == (
                    (((symbol_side_snapshot.total_filled_qty +
                       symbol_side_snapshot.total_cxled_qty) / 100) * plan_limits.cancel_rate.max_cancel_rate) -
                    symbol_side_snapshot.total_cxled_qty)), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_cxl_qty: "
                 f"{plan_limits.max_open_single_leg_notional}, "
                 f"found {plan_brief_bartering_brief.consumable_cxl_qty = }")
            other_side_residual_qty = 0
            assert (plan_brief_bartering_brief.indicative_consumable_residual == (
                    plan_limits.residual_restriction.max_residual -
                    ((plan_brief_bartering_brief.residual_qty *
                      get_px_in_usd(current_last_barter_px)) - (
                             other_side_residual_qty * get_px_in_usd(other_last_barter_px))))), \
                (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.indicative_consumable_residual: "
                 f"{plan_limits.residual_restriction.max_residual - ((plan_brief_bartering_brief.residual_qty * get_px_in_usd(current_last_barter_px)) - (other_side_residual_qty * get_px_in_usd(other_last_barter_px)))}, "
                 f"found {plan_brief_bartering_brief.indicative_consumable_residual = }")

            if side == Side.BUY:
                other_side_fill_notional = 0
            else:
                other_side_fill_notional = buy_symbol_side_snapshot.total_fill_notional
            assert (plan_brief.consumable_nett_filled_notional == (
                    plan_limits.max_net_filled_notional -
                    abs(symbol_side_snapshot.total_fill_notional - other_side_fill_notional))), \
                (
                    f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief."
                    f"consumable_nett_filled_notional: {plan_limits.max_open_single_leg_notional}, "
                    f"found {plan_brief.consumable_nett_filled_notional=}")

            plan_status = executor_http_client.get_plan_status_client(active_pair_plan.id)
            if side == Side.BUY:
                total_qty = plan_status.total_buy_qty
                total_open_qty = plan_status.total_open_buy_qty
                total_open_notional = plan_status.total_open_buy_notional
                avg_open_px = plan_status.avg_open_buy_px
                total_fill_qty = plan_status.total_fill_buy_qty
                total_fill_notional = plan_status.total_fill_buy_notional
                avg_fill_px = plan_status.avg_fill_buy_px
                total_cxl_qty = plan_status.total_cxl_buy_qty
                total_cxl_notional = plan_status.total_cxl_buy_notional
                avg_cxl_px = plan_status.avg_cxl_buy_px
            else:
                total_qty = plan_status.total_sell_qty
                total_open_qty = plan_status.total_open_sell_qty
                total_open_notional = plan_status.total_open_sell_notional
                avg_open_px = plan_status.avg_open_sell_px
                total_fill_qty = plan_status.total_fill_sell_qty
                total_fill_notional = plan_status.total_fill_sell_notional
                avg_fill_px = plan_status.avg_fill_sell_px
                total_cxl_qty = plan_status.total_cxl_sell_qty
                total_cxl_notional = plan_status.total_cxl_sell_notional
                avg_cxl_px = plan_status.avg_cxl_sell_px

            total_open_exposure = plan_status.total_open_exposure
            total_fill_exposure = plan_status.total_fill_exposure
            total_cxl_exposure = plan_status.total_cxl_exposure
            assert total_qty == qty, \
                (f"Mismatched: expected plan_status.total_{side.lower()}_qty: "
                 f"{qty}, found {total_qty = }")
            assert total_open_qty == 0, \
                (f"Mismatched: expected plan_status total_open_{side.lower()}_qty: "
                 f"0, found {total_open_qty = }")
            assert (total_open_notional == 0), \
                (f"Mismatched: expected plan_status.total_open_{side.lower()}_notional: "
                 f"0, found {total_open_notional = }")
            assert (avg_open_px == 0), \
                (f"Mismatched: expected plan_status.avg_open_{side.lower()}_px: "
                 f"0, found {avg_open_px = }")
            assert (total_fill_qty == overfill_qty), \
                (f"Mismatched: expected plan_status.total_fill_{side.lower()}_qty: "
                 f"{overfill_qty}, found {total_fill_qty = }")
            assert (total_fill_notional == overfill_qty * get_px_in_usd(px)), \
                (f"Mismatched: expected plan_status.total_fill_{side.lower()}_notional: "
                 f"{overfill_qty * get_px_in_usd(px)}, found {total_fill_notional = }")
            assert (avg_fill_px == px), \
                (f"Mismatched: expected plan_status.avg_fill_{side.lower()}_px: "
                 f"{px}, found {avg_fill_px = }")
            assert (total_cxl_qty == 0), \
                (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_qty: "
                 f"0, found {total_cxl_qty = }")
            assert (total_cxl_notional == 0), \
                (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_notional: "
                 f"0, found {total_cxl_notional = }")
            assert (avg_cxl_px == 0), \
                (f"Mismatched: expected plan_status.avg_cxl_{side.lower()}_px: "
                 f"0, found {avg_cxl_px = }")
            if side == Side.BUY:
                assert (total_open_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_open_exposure: "
                     f"0, found {total_open_exposure = }")
                assert (total_fill_exposure == overfill_qty * get_px_in_usd(px)), \
                    (f"Mismatched: expected plan_status.total_fill_exposure: "
                     f"{overfill_qty * get_px_in_usd(px)}, found {total_fill_exposure = }")
                assert (total_cxl_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_cxl_exposure: "
                     f"0, found {total_cxl_exposure = }")
            else:
                assert (total_open_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_open_exposure: "
                     f"0, found {total_open_exposure = }")
                assert (total_fill_exposure == (
                        buy_overfill_qty * get_px_in_usd(buy_px) - overfill_qty * get_px_in_usd(px))), \
                    (f"Mismatched: expected plan_status.total_fill_exposure: "
                     f"{buy_overfill_qty * get_px_in_usd(buy_px) - overfill_qty * get_px_in_usd(px)}, "
                     f"found {total_fill_exposure = }")
                assert (total_cxl_exposure == 0), \
                    (f"Mismatched: expected plan_status.total_cxl_exposure: "
                     f"0, found {total_cxl_exposure = }")

            contact_status = email_book_service_native_web_client.get_contact_status_client(1)
            if side == Side.BUY:
                overall_notional = contact_status.overall_buy_notional
            else:
                overall_notional = contact_status.overall_sell_notional
            assert (overall_notional == overfill_qty * get_px_in_usd(px)), \
                (f"Mismatched: expected contact_status.overall_{side.lower()}_notional: "
                 f"{overfill_qty * get_px_in_usd(px)}, found {overall_notional = }")

            # Checking alert in plan_alert
            check_str = "Unexpected: Received fill that will make chore_snapshot OVER_FILLED which is already OE_DOD"
            assert_fail_msg = f"Can't find alert of {check_str} in neither plan_alert nor contact_alert"
            time.sleep(5)
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            # forcefully turning plan to active again for checking sell chore
            if side == Side.BUY:
                pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
                pair_plan.plan_state = PlanState.PlanState_ACTIVE
                email_book_service_native_web_client.put_pair_plan_client(pair_plan)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_fill_pre_chore_ack(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["simulate_avoid_fill_after_ack"] = True
            config_dict["symbol_configs"][symbol]["simulate_fills_pre_chore_ack"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
        px = 100
        qty = 90
        place_new_chore(buy_symbol, Side.BUY, px, qty, executor_http_client, buy_inst_type)

        latest_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW, buy_symbol,
                                                                          executor_http_client)

        check_str = ("Received fill for chore that has status: ChoreStatusType.OE_UNACK, "
                     "putting chore to ChoreStatusType.OE_ACKED status and applying fill")
        assert_fail_msg = f"can't find alert saying {check_str!r}"
        time.sleep(5)
        check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

        fills_journal_list: List[FillsJournalBaseModel] = (
            get_fill_journals_for_chore_id(latest_unack_obj.chore.chore_id, executor_http_client))
        chore_snapshot = get_chore_snapshot_from_chore_id(latest_unack_obj.chore.chore_id,
                                                          executor_http_client)
        assert chore_snapshot.chore_status == ChoreStatusType.OE_ACKED, \
            f"Mismatched: Chore status must be OE_ACKED but found: {chore_snapshot.chore_status = }"
        assert chore_snapshot.filled_qty == fills_journal_list[0].fill_qty, \
            (f"Mismatch chore_snapshot.filled_qty, expected {fills_journal_list[0].fill_qty}, "
             f"received {chore_snapshot.filled_qty}")

        # applying ack post fills received
        executor_http_client.barter_simulator_process_chore_ack_query_client(
            latest_unack_obj.chore.chore_id,
            latest_unack_obj.chore.px,
            latest_unack_obj.chore.qty,
            latest_unack_obj.chore.side,
            latest_unack_obj.chore.security.sec_id,
            latest_unack_obj.chore.underlying_account)

        check_str = ("Unexpected: Received chore_journal of event: ChoreEventType.OE_ACK on chore of "
                     "chore_snapshot status: ChoreStatusType.OE_ACKED")
        assert_fail_msg = f"can't find alert saying {check_str!r}"
        time.sleep(5)
        check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_fulfill_pre_chore_ack(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["simulate_avoid_fill_after_ack"] = True
            config_dict["symbol_configs"][symbol]["simulate_fills_pre_chore_ack"] = True
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
        px = 100
        qty = 90
        place_new_chore(buy_symbol, Side.BUY, px, qty, executor_http_client, buy_inst_type)

        latest_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW, buy_symbol,
                                                                          executor_http_client)

        check_str = ("Received fill for chore that has status: ChoreStatusType.OE_UNACK that makes chore fulfilled, "
                     "putting chore to ChoreStatusType.OE_FILLED status and applying fill")
        assert_fail_msg = f"can't find alert saying {check_str!r}"
        time.sleep(5)
        check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

        fills_journal_list: List[FillsJournalBaseModel] = (
            get_fill_journals_for_chore_id(latest_unack_obj.chore.chore_id, executor_http_client))
        chore_snapshot = get_chore_snapshot_from_chore_id(latest_unack_obj.chore.chore_id,
                                                          executor_http_client)
        assert chore_snapshot.chore_status == ChoreStatusType.OE_FILLED, \
            f"Mismatched: Chore status must be OE_FILLED but found: {chore_snapshot.chore_status = }"
        assert chore_snapshot.filled_qty == fills_journal_list[0].fill_qty, \
            (f"Mismatch chore_snapshot.filled_qty, expected {fills_journal_list[0].fill_qty}, "
             f"received {chore_snapshot.filled_qty}")

        # applying ack post fills received
        executor_http_client.barter_simulator_process_chore_ack_query_client(
            latest_unack_obj.chore.chore_id,
            latest_unack_obj.chore.px,
            latest_unack_obj.chore.qty,
            latest_unack_obj.chore.side,
            latest_unack_obj.chore.security.sec_id,
            latest_unack_obj.chore.underlying_account)

        check_str = ("Unexpected: Received chore_journal of event: ChoreEventType.OE_ACK on chore of "
                     "chore_snapshot status: ChoreStatusType.OE_FILLED")
        assert_fail_msg = f"can't find alert saying {check_str!r}"
        time.sleep(5)
        check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_overfill_pre_chore_ack(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = False

        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
        px = 100
        qty = 90
        place_new_chore(buy_symbol, Side.BUY, px, qty, executor_http_client, buy_inst_type)

        latest_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW, buy_symbol,
                                                                          executor_http_client)
        overfill_qty = qty + 10
        executor_http_client.barter_simulator_process_fill_query_client(
            latest_unack_obj.chore.chore_id, latest_unack_obj.chore.px, overfill_qty, Side.BUY, buy_symbol,
            latest_unack_obj.chore.underlying_account, use_exact_passed_qty=True)

        fills_journal_list: List[FillsJournalBaseModel] = (
            get_fill_journals_for_chore_id(latest_unack_obj.chore.chore_id, executor_http_client))
        chore_snapshot = get_chore_snapshot_from_chore_id(latest_unack_obj.chore.chore_id,
                                                          executor_http_client)
        assert chore_snapshot.chore_status == ChoreStatusType.OE_OVER_FILLED, \
            f"Mismatched: Chore status must be OE_OVER_FILLED but found: {chore_snapshot.chore_status = }"
        assert chore_snapshot.filled_qty == overfill_qty, \
            (f"Mismatch chore_snapshot.filled_qty, expected {fills_journal_list[0].fill_qty}, "
             f"received {chore_snapshot.filled_qty}")

        pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
        assert pair_plan.plan_state == PlanState.PlanState_PAUSED, \
            f"Mismatched: pair_plan status must be PAUSED but found {pair_plan.plan_state}"

        check_str = ("Unexpected: Received fill that will make chore_snapshot OVER_FILLED to chore "
                     "which is still OE_UNACK")
        assert_fail_msg = f"can't find alert saying {check_str!r}"
        time.sleep(5)
        check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

        # applying ack post fills received
        executor_http_client.barter_simulator_process_chore_ack_query_client(
            latest_unack_obj.chore.chore_id,
            latest_unack_obj.chore.px,
            latest_unack_obj.chore.qty,
            latest_unack_obj.chore.side,
            latest_unack_obj.chore.security.sec_id,
            latest_unack_obj.chore.underlying_account)

        check_str = ("Unexpected: Received chore_journal of event: ChoreEventType.OE_ACK on chore of chore_snapshot "
                     "status: ChoreStatusType.OE_OVER_FILLED")
        assert_fail_msg = f"can't find alert saying {check_str!r}"
        time.sleep(5)
        check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


# plan pause tests
@pytest.mark.nightly
def test_plan_pause_on_residual_notional_breach(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                                                 pair_plan_, expected_plan_limits_,
                                                 expected_plan_status_, symbol_overview_obj_list,
                                                 last_barter_fixture_list, market_depth_basemodel_list,
                                                 buy_chore_, sell_chore_,
                                                 refresh_sec_update_fixture):

    expected_plan_limits_.residual_restriction.max_residual = 0
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    buy_symbol, sell_symbol, active_pair_plan, executor_http_client = (
        underlying_pre_requisites_for_limit_test(leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
                                                 expected_plan_status_, symbol_overview_obj_list,
                                                 last_barter_fixture_list, market_depth_basemodel_list))

    buy_inst_type: InstrumentType = get_inst_type(Side.BUY, active_pair_plan)
    sell_inst_type: InstrumentType = get_inst_type(Side.SELL, active_pair_plan)

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(active_pair_plan.id)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        residual_qty = 10
        executor_http_client.update_residuals_query_client(buy_symbol, Side.BUY, residual_qty)

        # placing new non-systematic new_chore
        px = 98
        qty = 90
        check_str = "residual_notional=.* > max_residual"
        assert_fail_message = "Could not find any alert containing message to block chores " \
                              "due to residual notional breach"
        # placing new non-systematic new_chore
        place_new_chore(buy_symbol, Side.BUY, px, qty, executor_http_client, buy_inst_type)
        print(f"symbol: {buy_symbol}, Created new_chore obj")

        new_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_NEW, buy_symbol,
                                                                           executor_http_client)
        time.sleep(5)
        check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_message)
    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


def _plan_pause_on_negative_consumable_cxl_qty_without_fill(leg1_leg2_symbol_list,
                                                             pair_plan_, expected_plan_limits_,
                                                             expected_plan_status_, symbol_overview_obj_list,
                                                             last_barter_fixture_list, market_depth_basemodel_list,
                                                             refresh_sec_update_fixture, check_side):
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]

    # explicitly setting waived_initial_chores to 10 for this test case
    expected_plan_limits_.cancel_rate.waived_initial_chores = 0
    expected_plan_limits_.cancel_rate.max_cancel_rate = 1
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    if check_side == Side.BUY:
        leg1_side = Side.BUY
        leg2_side = Side.SELL
        buy_symbol = leg1_symbol
        sell_symbol = leg2_symbol
        check_symbol = buy_symbol
    else:
        leg1_side = Side.SELL
        leg2_side = Side.BUY
        buy_symbol = leg2_symbol
        sell_symbol = leg1_symbol
        check_symbol = sell_symbol

    active_pair_plan, executor_http_client = (
        create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                           market_depth_basemodel_list, leg1_side=leg1_side, leg2_side=leg2_side))

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(active_pair_plan.id)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["simulate_ack_unsolicited_cxl_chores"] = True
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        handle_test_for_plan_pause_on_less_consumable_cxl_qty_without_fill(
            buy_symbol, sell_symbol, active_pair_plan, last_barter_fixture_list,
            check_side, executor_http_client)
    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


def _plan_pause_on_negative_consumable_cxl_qty_due_to_waived_min_rolling_notional_without_fill(
        leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list, refresh_sec_update_fixture, check_side):
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]

    # explicitly setting plan_limits.cancel_rate values for this test
    expected_plan_limits_.cancel_rate.waived_initial_chores = 0
    expected_plan_limits_.cancel_rate.max_cancel_rate = 1
    expected_plan_limits_.cancel_rate.waived_min_rolling_period_seconds = 100
    # one positive chore is placed making last 100 sec chore notional to 18000 (px=100, qty=90), next negative chore
    # will find that waived_min_rolling_notional < last 100 sec chore_notional (35000 < 36000) resulting trigger 
    # of plan pause since max_cancel_rate is very less
    expected_plan_limits_.cancel_rate.waived_min_rolling_notional = 35000
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    if check_side == Side.BUY:
        leg1_side = Side.BUY
        leg2_side = Side.SELL
        buy_symbol = leg1_symbol
        sell_symbol = leg2_symbol
        check_symbol = buy_symbol
    else:
        leg1_side = Side.SELL
        leg2_side = Side.BUY
        buy_symbol = leg2_symbol
        sell_symbol = leg1_symbol
        check_symbol = sell_symbol

    active_pair_plan, executor_http_client = (
        create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                           market_depth_basemodel_list, leg1_side=leg1_side, leg2_side=leg2_side))

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(active_pair_plan.id)

    buy_inst_type: InstrumentType = get_inst_type(Side.BUY, active_pair_plan)
    sell_inst_type: InstrumentType = get_inst_type(Side.SELL, active_pair_plan)
    inst_type: InstrumentType = buy_inst_type if check_side == Side.BUY else sell_inst_type

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["simulate_ack_unsolicited_cxl_chores"] = True
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 2
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # positive test - chore will be placed making last n sec chore notional 18000
        run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
        px = 100
        qty = 90
        # placing new non-systematic new_chore
        place_new_chore(check_symbol, check_side, px, qty, executor_http_client, inst_type)

        cxl_chore_journal = get_latest_chore_journal_with_events_and_symbol([ChoreEventType.OE_CXL_ACK,
                                                                             ChoreEventType.OE_UNSOL_CXL], check_symbol,
                                                                            executor_http_client)

        # checking plan pause
        pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
        assert pair_plan.plan_state == PlanState.PlanState_ACTIVE, \
            f"Mismatched plan state, expected: ACTIVE, found {pair_plan.plan_state}"

        handle_test_for_plan_pause_on_less_consumable_cxl_qty_without_fill(
            buy_symbol, sell_symbol, active_pair_plan, last_barter_fixture_list,
            check_side, executor_http_client, last_cxl_chore_id=cxl_chore_journal.chore.chore_id)
    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_plan_pause_on_negative_buy_consumable_cxl_qty_without_fill(static_data_, clean_and_set_limits,
                                                                     leg1_leg2_symbol_list,
                                                                     pair_plan_, expected_plan_limits_,
                                                                     expected_plan_status_, symbol_overview_obj_list,
                                                                     last_barter_fixture_list, market_depth_basemodel_list,
                                                                     refresh_sec_update_fixture):
    _plan_pause_on_negative_consumable_cxl_qty_without_fill(leg1_leg2_symbol_list,
                                                             pair_plan_, expected_plan_limits_,
                                                             expected_plan_status_, symbol_overview_obj_list,
                                                             last_barter_fixture_list, market_depth_basemodel_list,
                                                             refresh_sec_update_fixture, Side.BUY)


@pytest.mark.nightly
def test_plan_pause_on_negative_buy_consumable_cxl_qty_due_to_waived_min_rolling_notional_without_fill(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, refresh_sec_update_fixture):
    _plan_pause_on_negative_consumable_cxl_qty_due_to_waived_min_rolling_notional_without_fill(
        leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list, refresh_sec_update_fixture, Side.BUY)


@pytest.mark.nightly
def test_plan_pause_on_negative_sell_consumable_cxl_qty_without_fill(static_data_, clean_and_set_limits,
                                                                      leg1_leg2_symbol_list,
                                                                      pair_plan_, expected_plan_limits_,
                                                                      expected_plan_status_, symbol_overview_obj_list,
                                                                      last_barter_fixture_list, market_depth_basemodel_list,
                                                                      refresh_sec_update_fixture):
    _plan_pause_on_negative_consumable_cxl_qty_without_fill(leg1_leg2_symbol_list,
                                                             pair_plan_, expected_plan_limits_,
                                                             expected_plan_status_, symbol_overview_obj_list,
                                                             last_barter_fixture_list, market_depth_basemodel_list,
                                                             refresh_sec_update_fixture, Side.SELL)


@pytest.mark.nightly
def test_plan_pause_on_negative_sell_consumable_cxl_qty_due_to_waived_min_rolling_notional_without_fill(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, refresh_sec_update_fixture):
    _plan_pause_on_negative_consumable_cxl_qty_due_to_waived_min_rolling_notional_without_fill(
        leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list, refresh_sec_update_fixture, Side.SELL)


def _plan_pause_on_negative_consumable_cxl_qty_with_fill(leg1_leg2_symbol_list,
                                                          pair_plan_, expected_plan_limits_,
                                                          expected_plan_status_, symbol_overview_obj_list,
                                                          last_barter_fixture_list, market_depth_basemodel_list,
                                                          refresh_sec_update_fixture, check_side):
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]

    # explicitly setting waived_initial_chores to 10 for this test case
    expected_plan_limits_.cancel_rate.waived_initial_chores = 0
    expected_plan_limits_.cancel_rate.max_cancel_rate = 19
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture

    if check_side == Side.BUY:
        leg1_side = Side.BUY
        leg2_side = Side.SELL
        buy_symbol = leg1_symbol
        sell_symbol = leg2_symbol
        check_symbol = buy_symbol
    else:
        leg1_side = Side.SELL
        leg2_side = Side.BUY
        buy_symbol = leg2_symbol
        sell_symbol = leg1_symbol
        check_symbol = sell_symbol

    active_pair_plan, executor_http_client = (
        create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                           market_depth_basemodel_list, leg1_side=leg1_side,
                                           leg2_side=leg2_side))

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(active_pair_plan.id)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 80
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        handle_test_for_plan_pause_on_less_consumable_cxl_qty_with_fill(
            buy_symbol, sell_symbol, active_pair_plan, last_barter_fixture_list,
            check_side, executor_http_client)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


def _plan_pause_on_negative_consumable_cxl_qty_due_to_waived_min_rolling_notional_with_fill(
        leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list, refresh_sec_update_fixture, check_side):
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]

    # explicitly setting plan_limits.cancel_rate values for this test
    expected_plan_limits_.cancel_rate.waived_initial_chores = 0
    expected_plan_limits_.cancel_rate.max_cancel_rate = 19
    expected_plan_limits_.cancel_rate.waived_min_rolling_period_seconds = 100
    # one positive chore is placed making last 100 sec chore notional to 18000 (px=100, qty=90), next negative chore
    # will find that waived_min_rolling_notional < last 100 sec chore_notional (35000 < 36000) resulting trigger
    # of plan pause since max_cancel_rate is very less
    expected_plan_limits_.cancel_rate.waived_min_rolling_notional = 35000
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    if check_side == Side.BUY:
        leg1_side = Side.BUY
        leg2_side = Side.SELL
        buy_symbol = leg1_symbol
        sell_symbol = leg2_symbol
        check_symbol = buy_symbol
    else:
        leg1_side = Side.SELL
        leg2_side = Side.BUY
        buy_symbol = leg2_symbol
        sell_symbol = leg1_symbol
        check_symbol = sell_symbol

    active_pair_plan, executor_http_client = (
        create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                           market_depth_basemodel_list, leg1_side=leg1_side,
                                           leg2_side=leg2_side))

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(active_pair_plan.id)

    buy_inst_type: InstrumentType = get_inst_type(Side.BUY, active_pair_plan)
    sell_inst_type: InstrumentType = get_inst_type(Side.SELL, active_pair_plan)
    inst_type: InstrumentType = buy_inst_type if check_side == Side.BUY else sell_inst_type

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 80
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # positive test - chore will be placed making last n sec chore notional 18000
        run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)
        px = 100
        qty = 90
        # placing new non-systematic new_chore
        place_new_chore(check_symbol, check_side, px, qty, executor_http_client, inst_type)

        cxl_chore_journal = get_latest_chore_journal_with_events_and_symbol([ChoreEventType.OE_CXL_ACK,
                                                                             ChoreEventType.OE_UNSOL_CXL], check_symbol,
                                                                            executor_http_client)

        # checking plan pause
        pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
        assert pair_plan.plan_state == PlanState.PlanState_ACTIVE, \
            f"Mismatched plan state, expected: ACTIVE, found {pair_plan.plan_state}"

        handle_test_for_plan_pause_on_less_consumable_cxl_qty_with_fill(
            buy_symbol, sell_symbol, active_pair_plan, last_barter_fixture_list,
            check_side, executor_http_client, last_cxl_chore_id=cxl_chore_journal.chore.chore_id)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_plan_pause_on_negative_buy_consumable_cxl_qty_with_fill(static_data_, clean_and_set_limits, leg1_leg2_symbol_list,
                                                                  pair_plan_, expected_plan_limits_,
                                                                  expected_plan_status_, symbol_overview_obj_list,
                                                                  last_barter_fixture_list, market_depth_basemodel_list,
                                                                  buy_chore_, sell_chore_,
                                                                  refresh_sec_update_fixture):
    _plan_pause_on_negative_consumable_cxl_qty_with_fill(leg1_leg2_symbol_list,
                                                          pair_plan_, expected_plan_limits_,
                                                          expected_plan_status_, symbol_overview_obj_list,
                                                          last_barter_fixture_list, market_depth_basemodel_list,
                                                          refresh_sec_update_fixture, check_side=Side.BUY)


@pytest.mark.nightly1
def test_plan_pause_on_buy_negative_consumable_cxl_qty_due_to_waived_min_rolling_notional_with_fill(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        refresh_sec_update_fixture):
    _plan_pause_on_negative_consumable_cxl_qty_due_to_waived_min_rolling_notional_with_fill(
        leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list, refresh_sec_update_fixture, check_side=Side.BUY)


@pytest.mark.nightly
def test_plan_pause_on_negative_sell_consumable_cxl_qty_with_fill(static_data_, clean_and_set_limits,
                                                                   leg1_leg2_symbol_list,
                                                                   pair_plan_, expected_plan_limits_,
                                                                   expected_plan_status_, symbol_overview_obj_list,
                                                                   last_barter_fixture_list, market_depth_basemodel_list,
                                                                   buy_chore_, sell_chore_,
                                                                   refresh_sec_update_fixture):
    _plan_pause_on_negative_consumable_cxl_qty_with_fill(leg1_leg2_symbol_list,
                                                          pair_plan_, expected_plan_limits_,
                                                          expected_plan_status_, symbol_overview_obj_list,
                                                          last_barter_fixture_list, market_depth_basemodel_list,
                                                          refresh_sec_update_fixture, check_side=Side.SELL)


@pytest.mark.nightly
def test_plan_pause_on_sell_negative_consumable_cxl_qty_due_to_waived_min_rolling_notional_with_fill(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        refresh_sec_update_fixture):
    _plan_pause_on_negative_consumable_cxl_qty_due_to_waived_min_rolling_notional_with_fill(
        leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list, refresh_sec_update_fixture, check_side=Side.SELL)


@pytest.mark.nightly
def test_alert_agg_sequence_in_contact_alerts(clean_and_set_limits, sample_alert):
    contact_alerts = log_book_web_client.get_all_contact_alert_client()

    sev = [Severity.Severity_CRITICAL, Severity.Severity_ERROR, Severity.Severity_WARNING,
           Severity.Severity_INFO, Severity.Severity_DEBUG]
    level = ["CRITICAL", "ERROR", "WARNING", "INFO", "DEBUG"]
    counter = 0
    for i in range(5):
        alert = ContactAlertBaseModel()
        alert.last_update_analyzer_time = DateTime.utcnow()
        alert.alert_brief = f"Sample Alert: {i + 1}"
        alert.severity = sev[counter]
        payload = [{"message": f"{alert.alert_brief};;;Sample detail", "level": level[counter],
                    "source_file": str(PAIR_STRAT_ENGINE_DIR / "log" / "phone_book.log")}]
        counter += 1
        if counter > 4:
            counter = 0

        contact_alerts.append(alert)
        log_book_web_client.handle_contact_alerts_query_client(payload)

    # sorting alert list for this test comparison
    contact_alerts.sort(key=lambda x: x.last_update_analyzer_time, reverse=False)

    sorted_alert_list: List[ContactAlertBaseModel] = []
    for sev in Severity:
        if sev.value != Severity.Severity_UNSPECIFIED:
            for alert in contact_alerts:
                if alert.severity == sev.value:
                    sorted_alert_list.append(alert)
    time.sleep(5)
    agg_sorted_alerts: List[ContactAlertBaseModel] = log_book_web_client.get_all_contact_alert_client()
    for alert in agg_sorted_alerts:
        alert.last_update_analyzer_time = pendulum.parse(str(alert.last_update_analyzer_time)).in_timezone("utc")
    for alert in contact_alerts:
        alert.last_update_analyzer_time = \
            alert.last_update_analyzer_time.replace(microsecond=
                                                int(str(alert.last_update_analyzer_time.microsecond)[:3] + "000"))

    for sorted_alert, expected_alert in zip(agg_sorted_alerts, sorted_alert_list):
        assert sorted_alert.alert_brief == expected_alert.alert_brief, \
            (f"Alert ID mismatch: expected alert_brief {expected_alert.alert_brief!r}, "
             f"received {sorted_alert.alert_brief!r}")


@pytest.mark.nightly
def test_alert_agg_sequence_in_plan_alert(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                                           expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
                                           market_depth_basemodel_list, sample_alert):
    leg1_symbol, leg2_symbol = leg1_leg2_symbol_list[0]
    active_pair_plan, executor_http_client = (
        create_n_activate_plan(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                expected_plan_status_, symbol_overview_obj_list,
                                market_depth_basemodel_list))

    new_plan_alerts = []

    sev = [Severity.Severity_CRITICAL, Severity.Severity_ERROR, Severity.Severity_WARNING,
           Severity.Severity_INFO, Severity.Severity_DEBUG]
    level = ["CRITICAL", "ERROR", "WARNING", "INFO", "DEBUG"]
    counter = 0
    frmt_date = datetime.datetime.now().strftime("%Y%m%d")

    for i in range(5):
        alert = PlanAlertBaseModel()
        alert.last_update_analyzer_time = DateTime.utcnow()
        alert.alert_brief = f"Sample Alert: {i + 1}"
        alert.severity = sev[counter]
        payload = [{"message": f"{alert.alert_brief};;;Sample detail", "level": level[counter],
                    "source_file": str(STRAT_EXECUTOR / "log" / f"street_book_{active_pair_plan.id}_logs_{frmt_date}.log"), 
                    "file_name_regex": "street_book_(\d+)_logs_\d{8}\.log"}]
        counter += 1
        if counter > 4:
            counter = 0

        new_plan_alerts.append(alert)
        log_book_web_client.handle_plan_alerts_with_plan_id_query_client(payload)
    time.sleep(5)

    agg_sorted_alerts: List[PlanAlertBaseModel] = log_book_web_client.filtered_plan_alert_by_plan_id_query_client(active_pair_plan.id)

    # putting all alerts apart from newly added alerts
    already_existing_alerts = []
    for stored_alert in agg_sorted_alerts:
        for new_alert in new_plan_alerts:
            if stored_alert.alert_brief == new_alert.alert_brief:
                break
        else:
            already_existing_alerts.append(stored_alert)

    # putting already_existing_alerts with newly_added alerts before sorting
    new_plan_alerts.extend(already_existing_alerts)

    # sorting alert list for this test comparison
    new_plan_alerts.sort(key=lambda x: x.last_update_analyzer_time, reverse=False)

    sorted_alert_list: List[PlanAlertBaseModel] = []
    for sev in Severity:
        if sev.value != Severity.Severity_UNSPECIFIED:
            for alert in new_plan_alerts:
                if alert.severity == sev.value:
                    sorted_alert_list.append(alert)
    time.sleep(5)
    for alert in agg_sorted_alerts:
        alert.last_update_analyzer_time = pendulum.parse(str(alert.last_update_analyzer_time)).in_timezone("utc")
    for alert in new_plan_alerts:
        alert.last_update_analyzer_time = \
            alert.last_update_analyzer_time.replace(microsecond=
                                                int(str(alert.last_update_analyzer_time.microsecond)[:3] + "000"))

    for sorted_alert, expected_alert in zip(agg_sorted_alerts, sorted_alert_list):
        assert sorted_alert.alert_brief == expected_alert.alert_brief, \
            (f"Alert ID mismatch: expected alert_brief {expected_alert.alert_brief!r}, "
             f"received {sorted_alert.alert_brief!r}")


# def test_alert_id(clean_and_set_limits, sample_alert):
#     alert_list = []
#
#     for i in range(1000):
#         alert = copy.deepcopy(sample_alert)
#         alert.id = f"obj_{i}"
#         alert.last_update_date_time = DateTime.utcnow()
#
#         alert_list.append(alert)
#         contact_alert_basemodel = ContactAlertBaseModel(_id=1, alerts=[alert])
#         json_obj = jsonable_encoder(contact_alert_basemodel, by_alias=True, exclude_none=True)
#         updated_contact_alert = log_book_web_client.patch_contact_alert_client(json_obj)
#
#     contact_alert = log_book_web_client.get_contact_alert_client(contact_alert_id=1)
#     agg_sorted_alerts: List[Alert] = contact_alert.alerts
#     # for alert in agg_sorted_alerts:
#     #     alert.last_update_date_time = pendulum.parse(str(alert.last_update_date_time)).in_timezone("utc")
#     # for alert in alert_list:
#     #     alert.last_update_date_time = \
#     #         alert.last_update_date_time.replace(microsecond=
#     #                                             int(str(alert.last_update_date_time.microsecond)[:3] + "000"))
#     # for sorted_alert, expected_alert in zip(agg_sorted_alerts, list(reversed(sorted_alert_list))):
#     #     assert sorted_alert.id == expected_alert.id, \
#     #         f"Alert ID mismatch: expected Alert {expected_alert.id}, received {sorted_alert.id}"
#     #     assert sorted_alert.last_update_date_time == expected_alert.last_update_date_time, \
#     #         f"Alert Datetime mismatch: expected Alert {expected_alert}, received {sorted_alert}"
#
#     alert_id_dict = {}
#     for alert in agg_sorted_alerts:
#         if alert.id in alert_id_dict:
#             assert False, (f"alert id already exists in dict, existing obj: {alert_id_dict[alert.id]}, "
#                            f"new obj: {alert}")
#         alert_id_dict[alert.id] = alert



# @@@ Deprecated test function: Kept here for code sample for any future use-case
# def test_routes_performance():
#     latest_file_date_time_format = "YYYYMMDD"
#     older_file_date_time_format = "YYYYMMDD.HHmmss"
#     log_dir_path = PurePath(__file__).parent.parent.parent.parent.parent / "Flux" / \
#                    "CodeGenProjects" / "phone_book" / "log"
#     files_list = os.listdir(log_dir_path)
#
#     filtered_beanie_latest_log_file_list = []
#     filtered_beanie_older_log_file_list = []
#     for file in files_list:
#         if re.match(".*_beanie_logs_.*", file):
#             if re.match(".*log$", file):
#                 filtered_beanie_latest_log_file_list.append(file)
#             else:
#                 filtered_beanie_older_log_file_list.append(file)
#
#     # getting latest 2 logs
#     latest_file: str | None = None
#     sec_latest_file: str | None = None
#     for file in filtered_beanie_latest_log_file_list:
#         # First getting latest log
#         # Also setting last log other than latest as sec_latest_file
#         if latest_file is None:
#             latest_file = file
#         else:
#             latest_file_name = latest_file.split(".")[0]
#             latest_file_date_time = pendulum.from_format(
#                 latest_file_name[len(latest_file_name)-len(latest_file_date_time_format):],
#                 fmt=latest_file_date_time_format
#             )
#
#             current_file_name = file.split(".")[0]
#             current_file_date_time = pendulum.from_format(
#                 current_file_name[len(current_file_name) - len(latest_file_date_time_format):],
#                 fmt=latest_file_date_time_format
#             )
#
#             if current_file_date_time > latest_file_date_time:
#                 sec_latest_file = latest_file
#                 latest_file = file
#
#     # If other log is present having .log.YYYYMMDD.HHmmss format with same data then taking
#     # latest log in this category as sec_latest_file
#     if any(latest_file in older_file for older_file in filtered_beanie_older_log_file_list):
#         sec_latest_file = None
#         for file in filtered_beanie_older_log_file_list:
#             if sec_latest_file is None:
#                 sec_latest_file = file
#             else:
#                 sec_latest_file_date_time = pendulum.from_format(
#                     sec_latest_file[len(sec_latest_file) - len(older_file_date_time_format):],
#                     fmt=older_file_date_time_format
#                 )
#
#                 current_file_date_time = pendulum.from_format(
#                     file[len(file) - len(older_file_date_time_format):],
#                     fmt=older_file_date_time_format
#                 )
#
#                 if current_file_date_time > sec_latest_file_date_time:
#                     sec_latest_file = file
#
#     # taking all grep found statements in log matching pattern
#     pattern = "_Callable_"
#     latest_file_content_list: List[str] = []
#     # grep in latest file
#     if latest_file:
#         latest_file_path = log_dir_path / latest_file
#         grep_cmd = pexpect.spawn(f"grep {pattern} {latest_file_path}")
#         for line in grep_cmd:
#             latest_file_content_list.append(line.decode())
#
#     sec_latest_file_content_list: List[str] = []
#     # grep in sec_latest file if exists
#     if sec_latest_file:
#         sec_latest_file_path = log_dir_path / sec_latest_file
#         grep_cmd = pexpect.spawn(f"grep {pattern} {sec_latest_file_path}")
#         for line in grep_cmd:
#             sec_latest_file_content_list.append(line.decode())
#
#     # getting set of callables to be checked in latest and last log file
#     callable_name_set = set()
#     for line in latest_file_content_list:
#         line_space_separated = line.split(" ")
#         callable_name = line_space_separated[line_space_separated.index(pattern)+1]
#         callable_name_set.add(callable_name)
#
#     # processing statement found having particular callable and getting list of all callable
#     # durations and showing average of it in report
#     for callable_name in callable_name_set:
#         callable_time_delta_list = []
#         callable_pattern = f".*{pattern} {callable_name}.*"
#         for line in latest_file_content_list:
#             if re.match(callable_pattern, line):
#                 line_space_separated = line.split(" ")
#                 time_delta = line_space_separated[line_space_separated.index(pattern)+3]
#                 callable_time_delta_list.append(parse_to_float(time_delta))
#         latest_avg_delta = np.mean(callable_time_delta_list)
#         print(f"Avg duration of callable {callable_name} in latest run: {latest_avg_delta:.7f}")
#
#         # if sec_latest_file exists, processing statement found having particular callable and
#         # getting list of all callable durations and showing average of it in report and
#         # showing delta between latest and last callable duration average
#         callable_time_delta_list = []
#         for line in sec_latest_file_content_list:
#             if re.match(callable_pattern, line):
#                 line_space_separated = line.split(" ")
#                 time_delta = line_space_separated[line_space_separated.index(pattern) + 3]
#                 callable_time_delta_list.append(parse_to_float(time_delta))
#         if callable_time_delta_list:
#             sec_latest_avg_delta = np.mean(callable_time_delta_list)
#             print(f"Avg duration of callable {callable_name} in last run: {sec_latest_avg_delta:.7f}")
#             print(f"Delta between last run and latest run for callable {callable_name}: "
#                   f"{(sec_latest_avg_delta-latest_avg_delta):.7f}")


# @@@@ deprecated test: No use case for projection in street_book or phone_book
# def test_projection_http_query(clean_and_set_limits, bar_data_):
#     for index, symbol_n_exch_id_tuple in enumerate([("Type1_Sec_1", "Exch1"), ("Type1_Sec_2", "Exch2")]):
#         created_objs: List[BarDataBaseModel] = []
#         symbol, exch_id = symbol_n_exch_id_tuple
#         for i in range(5*index, 5*(index+1)):
#             bar_data = BarDataBaseModel(**bar_data_)
#             bar_data.symbol_n_exch_id.symbol = symbol
#             bar_data.symbol_n_exch_id.exch_id = exch_id
#             time.sleep(1)
#             bar_data.start_time = DateTime.utcnow()
#             bar_data.id = i
#
#             created_obj = mobile_book_web_client.create_bar_data_client(bar_data)
#             created_objs.append(created_obj)
#
#         # checking query with diff params
#         received_container_obj_list: List[BarDataProjectionContainerForVwap]
#
#         # when no start and end time
#         for start_time, end_time in [(None, None), (created_objs[0].start_time, None),
#                                      (None, created_objs[-1].start_time),
#                                      (created_objs[0].start_time, created_objs[-1].start_time)]:
#             received_container_obj_list = (
#                 mobile_book_web_client.get_vwap_projection_from_bar_data_query_client(symbol, exch_id,
#                                                                                       start_time, end_time))
#             container_obj = received_container_obj_list[0]
#
#             # meta data field
#             assert container_obj.symbol_n_exch_id.symbol == symbol, \
#                 (f"Mismatched: nested meta field value, expected: {symbol}, "
#                  f"original: {container_obj.symbol_n_exch_id.symbol}")
#             assert container_obj.symbol_n_exch_id.exch_id == exch_id, \
#                 (f"Mismatched: nested meta field value, expected: {exch_id}, "
#                  f"original: {container_obj.symbol_n_exch_id.exch_id}")
#
#             # projection models
#             if not start_time and not end_time:
#                 assert len(container_obj.projection_models) == len(created_objs), \
#                     (f"Mismatched: Expected len of projection_models in container mismatched from original, "
#                      f"expected: {len(created_objs)}, original: {len(received_container_obj_list)}")
#             elif start_time and end_time:
#                 assert len(container_obj.projection_models) == len(created_objs)-2, \
#                     (f"Mismatched: Expected len of projection_models in container mismatched from original, "
#                      f"expected: {len(created_objs)-2}, original: {len(received_container_obj_list)}")
#                 for projection_model in container_obj.projection_models:
#                     assert (projection_model.start_time > start_time)
#                     assert (projection_model.start_time < end_time)
#             else:
#                 assert len(container_obj.projection_models) == len(created_objs) - 1, \
#                     (f"Mismatched: Expected len of projection_models in container mismatched from original, "
#                      f"expected: {len(created_objs) - 1}, original: {len(received_container_obj_list)}")
#                 for projection_model in container_obj.projection_models:
#                     if start_time and not end_time:
#                         assert (projection_model.start_time > start_time)
#                     else:
#                         assert (projection_model.start_time < end_time)


@pytest.mark.nightly
def test_get_max_id_query(clean_and_set_limits):
    chore_limits_max_id = email_book_service_native_web_client.get_chore_limits_max_id_client()
    assert chore_limits_max_id.max_id_val == 1, f"max_id mismatch, expected 1 received {chore_limits_max_id.max_id_val}"

    chore_limits_basemodel = ChoreLimitsBaseModel(id=2)
    created_chore_limits_obj = email_book_service_native_web_client.create_chore_limits_client(chore_limits_basemodel)

    chore_limits_max_id = email_book_service_native_web_client.get_chore_limits_max_id_client()
    assert chore_limits_max_id.max_id_val == created_chore_limits_obj.id, \
        f"max_id mismatch, expected {created_chore_limits_obj.id} received {chore_limits_max_id.max_id_val}"


@pytest.mark.nightly
def test_get_market_depths_query(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        market_depth_basemodel_list, last_barter_fixture_list, refresh_sec_update_fixture):
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:2]

    pair_plan_n_http_client_tuple_list = []
    for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list:
        expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
        activated_pair_start, executor_http_client = (
            create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list,
                                               last_barter_fixture_list,
                                               market_depth_basemodel_list))

        pair_plan_n_http_client_tuple_list.append((activated_pair_start, executor_http_client))

    bid_pos_to_market_depth_dict = {}
    ask_pos_to_market_depth_dict = {}
    for market_depth_ in market_depth_basemodel_list:
        if market_depth_.side == TickType.BID:
            bid_pos_to_market_depth_dict[market_depth_.position] = market_depth_
        else:
            ask_pos_to_market_depth_dict[market_depth_.position] = market_depth_

    for market_depth_dict in [bid_pos_to_market_depth_dict, ask_pos_to_market_depth_dict]:
        cum_qty = 0
        cum_notional = 0
        cum_avg_px = 0
        for pos, market_depth_ in market_depth_dict.items():
            cum_qty += market_depth_.qty
            market_depth_.cumulative_qty = cum_qty

            cum_notional += (market_depth_.px * market_depth_.qty)
            market_depth_.cumulative_notional = cum_notional

            market_depth_.cumulative_avg_px = cum_notional / cum_qty

    for pair_plan_n_http_client_tuple in pair_plan_n_http_client_tuple_list:
        pair_plan, executor_http_client = pair_plan_n_http_client_tuple

        query_symbol_side_list = [(pair_plan.pair_plan_params.plan_leg1.sec.sec_id, TickType.BID),
                                  (pair_plan.pair_plan_params.plan_leg2.sec.sec_id, TickType.ASK)]

        market_depth_list: List[MarketDepthBaseModel] = (
            executor_http_client.get_market_depths_query_client(query_symbol_side_list))

        last_px = None
        for market_depth_obj in market_depth_list:
            # Checking symbol side
            for query_symbol_side in query_symbol_side_list:
                symbol, side = query_symbol_side
                if market_depth_obj.symbol == symbol and market_depth_obj.side == side:
                    break
            else:
                assert False, ("Unexpected: Found symbol or side not matching from any passed query symbol or side"
                               "in received market_depth list")

            # Checking Sort
            if last_px is None:
                last_px = market_depth_obj.px
            else:
                assert last_px > market_depth_obj.px, \
                    (f"Unexpected: market_depth_list must be sorted in terms of decreasing px, "
                     f"market_depth_list: {market_depth_list}")

            # checking cumulative fields
            if market_depth_obj.side == TickType.BID:
                expected_market_depth = bid_pos_to_market_depth_dict.get(market_depth_obj.position)
            else:
                expected_market_depth = ask_pos_to_market_depth_dict.get(market_depth_obj.position)

            assert expected_market_depth.cumulative_qty == market_depth_obj.cumulative_qty, \
                (f"Mismatched cumulative_qty: expected: {expected_market_depth.cumulative_qty} "
                 f"received: {market_depth_obj.cumulative_qty}")
            assert expected_market_depth.cumulative_notional == market_depth_obj.cumulative_notional, \
                (f"Mismatched cumulative_notional: expected: {expected_market_depth.cumulative_notional} "
                 f"received: {market_depth_obj.cumulative_notional}")
            assert expected_market_depth.cumulative_avg_px == market_depth_obj.cumulative_avg_px, \
                (f"Mismatched cumulative_avg_px: expected: {expected_market_depth.cumulative_avg_px} "
                 f"received: {market_depth_obj.cumulative_avg_px}")


@pytest.mark.nightly
def test_fills_after_cxl_request(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                                 expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
                                 last_barter_fixture_list, market_depth_basemodel_list,
                                 buy_chore_, sell_chore_, max_loop_count_per_side,
                                 buy_fill_journal_, sell_fill_journal_, expected_plan_brief_,
                                 refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (created_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["avoid_cxl_ack_after_cxl_req"] = True
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        executor_http_client.barter_simulator_reload_config_query_client()

        for symbol, side in [(buy_symbol, Side.BUY), (sell_symbol, Side.SELL)]:
            # Placing buy chores
            run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, created_pair_plan.cpp_port)
            if symbol == buy_symbol:
                px = 100
                qty = 90
                place_new_chore(buy_symbol, Side.BUY, px, qty, executor_http_client, buy_inst_type)
            else:
                px = 110
                qty = 94
                place_new_chore(sell_symbol, Side.SELL, px, qty, executor_http_client, sell_inst_type)

            ack_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK,
                                                                               symbol, executor_http_client)
            ack_chore_id = ack_chore_journal.chore.chore_id

            executor_http_client.barter_simulator_place_cxl_chore_query_client(
                ack_chore_id, side, symbol, symbol, ack_chore_journal.chore.underlying_account)
            time.sleep(2)

            executor_http_client.barter_simulator_process_fill_query_client(
                ack_chore_journal.chore.chore_id, ack_chore_journal.chore.px, ack_chore_journal.chore.qty,
                side, symbol, ack_chore_journal.chore.underlying_account)
            time.sleep(2)

            chore_snapshot = get_chore_snapshot_from_chore_id(ack_chore_id, executor_http_client)
            assert chore_snapshot.chore_status == ChoreStatusType.OE_FILLED, \
                (f"Mismatched: ChoreStatus must be OE_FILLED, found: {chore_snapshot.chore_status}, "
                 f"chore_snapshot: {chore_snapshot}")

            # Sending CXL_ACk after chore is fully filled

            cxl_ack_chore_journal = ChoreJournalBaseModel.from_kwargs(chore=ack_chore_journal.chore,
                                                          chore_event_date_time=DateTime.utcnow(),
                                                          chore_event=ChoreEventType.OE_CXL_ACK)
            executor_http_client.create_chore_journal_client(cxl_ack_chore_journal)
            time.sleep(2)

            # This must not impact any change in chore states, checking that
            chore_snapshot = get_chore_snapshot_from_chore_id(cxl_ack_chore_journal.chore.chore_id,
                                                              executor_http_client)

            assert chore_snapshot.chore_status == ChoreStatusType.OE_FILLED, \
                (f"Mismatched: ChoreStatus must be OE_FILLED, found: {chore_snapshot.chore_status}, "
                 f"chore_snapshot: {chore_snapshot}")

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        print(f"Some Error Occurred: exception: {e}, "
              f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        raise Exception(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


def _verify_server_ready_state_in_reloaded_plan(pair_plan_id: int, existing_executor_port: int, 
                                                 residual_wait_sec: int, buy_symbol: str, sell_symbol: str):
    # no need to verify server_ready_state == 1 - executor db still contains symbol overview of before unload 
    # so when plan reloads init checks passes to init symbol overview cache and marks plan ready 

    loaded_pair_plan = email_book_service_native_web_client.get_pair_plan_client(pair_plan_id)
    executor_http_client = StreetBookServiceHttpClient.set_or_get_if_instance_exists(loaded_pair_plan.host,
                                                                                        loaded_pair_plan.port)
    assert loaded_pair_plan.server_ready_state == 2, \
        ("Unexpected: After plan is loaded by this point since all service up check is done server_ready_state "
         f"must be 2, found {loaded_pair_plan.server_ready_state}, pair_plan: {loaded_pair_plan}")
    assert loaded_pair_plan.plan_state == PlanState.PlanState_READY, \
        (f"Unexpected, PlanState must be READY but found state: {loaded_pair_plan.plan_state}, "
         f"pair_plan: {loaded_pair_plan}")

    pair_plan = PairPlanBaseModel.from_kwargs(_id=pair_plan_id, plan_state=PlanState.PlanState_ACTIVE)
    activated_pair_plan = email_book_service_native_web_client.patch_pair_plan_client(
        pair_plan.to_dict(exclude_none=True))
    assert activated_pair_plan.plan_state == PlanState.PlanState_ACTIVE, \
        (f"PlanState Mismatched, expected PlanState: {PlanState.PlanState_ACTIVE}, "
         f"received pair_plan's plan_state: {activated_pair_plan.plan_state}")
    print(f"PlanStatus updated to Active state, buy_symbol: {buy_symbol}, sell_symbol: {sell_symbol}")
    time.sleep(10)
    loaded_pair_plan = email_book_service_native_web_client.get_pair_plan_client(pair_plan_id)
    assert loaded_pair_plan.server_ready_state == 3, \
        ("Unexpected: After plan is loaded by this point, since plan is activated, server_ready_state "
         f"must be 3, found {loaded_pair_plan.server_ready_state}, pair_plan: {loaded_pair_plan}")
    return executor_http_client, activated_pair_plan


@pytest.mark.nightly
def test_unload_reload_plan_from_collection(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    created_pair_plan, executor_web_client = (
        create_pre_chore_test_requirements(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                           market_depth_basemodel_list))

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(created_pair_plan.id)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        executor_web_client.barter_simulator_reload_config_query_client()

        total_chore_count_for_each_side = 1
        place_sanity_chores_for_executor(
            buy_symbol, sell_symbol, created_pair_plan, total_chore_count_for_each_side, last_barter_fixture_list,
            residual_wait_sec, executor_web_client)
        executor_port = created_pair_plan.port

        # Unloading Plan
        # making this plan DONE
        email_book_service_native_web_client.patch_pair_plan_client(
            PairPlanBaseModel.from_kwargs(_id=created_pair_plan.id,
                                           plan_state=PlanState.PlanState_DONE).to_dict(exclude_none=True))

        plan_key = get_plan_key_from_pair_plan(created_pair_plan)

        plan_collection = email_book_service_native_web_client.get_plan_collection_client(1)
        plan_collection.loaded_plan_keys.remove(plan_key)
        plan_collection.buffered_plan_keys.append(plan_key)

        email_book_service_native_web_client.put_plan_collection_client(plan_collection)

        time.sleep(5)

        pair_plan = email_book_service_native_web_client.get_pair_plan_client(created_pair_plan.id)
        assert pair_plan.server_ready_state == 0, \
            "Mismatch: server_ready_state must be 0 after plan unload"

        # Reloading plan
        plan_collection = email_book_service_native_web_client.get_plan_collection_client(1)
        plan_collection.buffered_plan_keys.remove(plan_key)
        plan_collection.loaded_plan_keys.append(plan_key)
        email_book_service_native_web_client.put_plan_collection_client(plan_collection)

        time.sleep(residual_wait_sec)   # waiting for plan to get loaded completely

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        print(f"Some Error Occurred: exception: {e}, "
              f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        raise Exception(e)
    # Since config file is removed while unloading - no need to revert changes

    executor_http_client, activated_pair_plan = (
        _verify_server_ready_state_in_reloaded_plan(created_pair_plan.id, executor_port,
                                                     residual_wait_sec, buy_symbol, sell_symbol))

    time.sleep(5)
    config_dict: Dict = YAMLConfigurationManager.load_yaml_configurations(config_file_path)
    config_dict_str = YAMLConfigurationManager.load_yaml_configurations(config_file_path, load_as_str=True)
    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        executor_http_client.barter_simulator_reload_config_query_client()

        # updating market_depth to update shm cache in reloaded plan with existing data
        update_market_depth(activated_pair_plan.cpp_port)

        total_chore_count_for_each_side = 2
        place_sanity_chores_for_executor(
            buy_symbol, sell_symbol, activated_pair_plan, total_chore_count_for_each_side, last_barter_fixture_list,
            residual_wait_sec, executor_http_client, True)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        print(f"Some Error Occurred: exception: {e}, "
              f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        raise Exception(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_unload_plan_from_plan_view_unload_ui_button(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    created_pair_plan, executor_web_client = (
        create_pre_chore_test_requirements(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                           market_depth_basemodel_list))

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(created_pair_plan.id)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        executor_web_client.barter_simulator_reload_config_query_client()

        total_chore_count_for_each_side = 1
        place_sanity_chores_for_executor(
            buy_symbol, sell_symbol, created_pair_plan, total_chore_count_for_each_side, last_barter_fixture_list,
            residual_wait_sec, executor_web_client)

        # Unloading Plan
        plan_view_obj = photo_book_web_client.get_plan_view_client(created_pair_plan.id)
        # simulating ui button update - making unload_plan True
        plan_view_obj.unload_plan = True
        update_plan_view = photo_book_web_client.put_plan_view_client(plan_view_obj)
        assert update_plan_view == plan_view_obj, \
            f"Mismatched plan_view: expected {plan_view_obj}, updated {update_plan_view}"

        time.sleep(20)

        # verifying pair_plan
        pair_plan = email_book_service_native_web_client.get_pair_plan_client(created_pair_plan.id)
        assert pair_plan.server_ready_state == 0, \
            "Mismatch: server_ready_state must be 0 after plan unload"

        # verifying plan_collection
        plan_key = get_plan_key_from_pair_plan(created_pair_plan)
        plan_collection = email_book_service_native_web_client.get_plan_collection_client(1)
        assert plan_key in plan_collection.buffered_plan_keys, \
            f"Not Found: expected {plan_key=} in {plan_collection.buffered_plan_keys=}"

        # verifying unload_plan is updated back to default state
        time.sleep(2)
        update_plan_view = photo_book_web_client.get_plan_view_client(plan_view_obj.id)
        assert not update_plan_view.unload_plan, \
            f"Mismatched plan_view.unload_plan: expected False, found True"

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        print(f"Some Error Occurred: exception: {e}, "
              f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        raise Exception(e)
    # Since config file is removed while unloading - no need to revert changes


@pytest.mark.nightly
def test_unload_multiple_plans_from_plan_view_unload_ui_button(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list, refresh_sec_update_fixture):
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:10]
    with concurrent.futures.ThreadPoolExecutor(max_workers=len(leg1_leg2_symbol_list)) as executor:
        results = [executor.submit(create_n_activate_plan, leg1_symbol, leg2_symbol, copy.deepcopy(pair_plan_),
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), None, None, None)
                   for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())

    pair_plans = email_book_service_beanie_web_client.get_all_pair_plan_client()
    for pair_plan in pair_plans:
        plan_view_dict = {'_id': pair_plan.id, 'unload_plan': True}
        plan_view = photo_book_web_client.patch_plan_view_client(plan_view_dict)
        
    time.sleep(20)
    # checking if all plans are shifted to unloaded keys in plan_collection and are not active anymore
    plan_collection = email_book_service_native_web_client.get_plan_collection_client(plan_collection_id=1)
    pair_plans = email_book_service_beanie_web_client.get_all_pair_plan_client()
    for pair_plan in pair_plans:
        plan_key = get_plan_key_from_pair_plan(pair_plan)
        assert plan_key not in plan_collection.loaded_plan_keys, \
            f"Mismatch: {plan_key=} must not be in {plan_collection.loaded_plan_keys=}"
        assert plan_key in plan_collection.buffered_plan_keys, \
            f"Mismatch: {plan_key=} must be in {plan_collection.buffered_plan_keys=}"
        assert pair_plan.plan_state == PlanState.PlanState_SNOOZED, \
            f"Mismatch: plan_state must be {PlanState.PlanState_SNOOZED}, found {pair_plan.plan_state=}"
        assert pair_plan.port is None, \
            f"Mismatch: pair_plan.port must be None, found {pair_plan.port=}"
    

@pytest.mark.nightly
def test_recycle_plan_from_plan_view_recycle_ui_button(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    created_pair_plan, executor_web_client = (
        create_pre_chore_test_requirements(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                           market_depth_basemodel_list))

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(created_pair_plan.id)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        executor_web_client.barter_simulator_reload_config_query_client()

        total_chore_count_for_each_side = 1
        place_sanity_chores_for_executor(
            buy_symbol, sell_symbol, created_pair_plan, total_chore_count_for_each_side, last_barter_fixture_list,
            residual_wait_sec, executor_web_client)

        executor_port = created_pair_plan.port

        # Recycling Plan
        plan_view_obj = photo_book_web_client.get_plan_view_client(created_pair_plan.id)
        # simulating ui button update - making recycle_plan True
        plan_view_obj.recycle_plan = True
        update_plan_view = photo_book_web_client.put_plan_view_client(plan_view_obj)
        assert update_plan_view == plan_view_obj, \
            f"Mismatched plan_view: expected {plan_view_obj}, updated {update_plan_view}"

        time.sleep(2*residual_wait_sec)   # waiting for plan to get loaded completely

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        print(f"Some Error Occurred: exception: {e}, "
              f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        raise Exception(e)
    # Since config file is removed while unloading - no need to revert changes

    # verifying recycle_plan is updated back to default state
    update_plan_view = photo_book_web_client.get_plan_view_client(plan_view_obj.id)
    assert not update_plan_view.recycle_plan, \
        f"Mismatched plan_view.unload_plan: expected False, found True"

    executor_http_client, activated_pair_plan = (
        _verify_server_ready_state_in_reloaded_plan(created_pair_plan.id, executor_port,
                                                     residual_wait_sec, buy_symbol, sell_symbol))

    time.sleep(5)
    config_dict: Dict = YAMLConfigurationManager.load_yaml_configurations(config_file_path)
    config_dict_str = YAMLConfigurationManager.load_yaml_configurations(config_file_path, load_as_str=True)
    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        executor_http_client.barter_simulator_reload_config_query_client()

        # updating market_depth to update cache in reloaded plan
        update_market_depth(activated_pair_plan.cpp_port)

        total_chore_count_for_each_side = 2
        place_sanity_chores_for_executor(
            buy_symbol, sell_symbol, activated_pair_plan, total_chore_count_for_each_side, last_barter_fixture_list,
            residual_wait_sec, executor_http_client, True)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        print(f"Some Error Occurred: exception: {e}, "
              f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        raise Exception(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_recycle_multiple_plans_from_plan_view_recycle_ui_button(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list, refresh_sec_update_fixture):
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:10]
    with concurrent.futures.ThreadPoolExecutor(max_workers=len(leg1_leg2_symbol_list)) as executor:
        results = [executor.submit(create_n_activate_plan, leg1_symbol, leg2_symbol, copy.deepcopy(pair_plan_),
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(market_depth_basemodel_list), None, None, None)
                   for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())

    pair_plans = email_book_service_beanie_web_client.get_all_pair_plan_client()
    for pair_plan in pair_plans:
        plan_view_dict = {'_id': pair_plan.id, 'recycle_plan': True}
        plan_view = photo_book_web_client.patch_plan_view_client(plan_view_dict)

    time.sleep(10 * refresh_sec_update_fixture)  # waiting for plan to get loaded completely

    # checking if all plans are shifted to unloaded keys in plan_collection and are not active anymore
    plan_collection = email_book_service_native_web_client.get_plan_collection_client(plan_collection_id=1)
    pair_plans = email_book_service_beanie_web_client.get_all_pair_plan_client()
    for pair_plan in pair_plans:
        plan_key = get_plan_key_from_pair_plan(pair_plan)
        assert plan_key in plan_collection.loaded_plan_keys, \
            f"Mismatch: {plan_key=} must be in {plan_collection.loaded_plan_keys=}"
        assert plan_key not in plan_collection.buffered_plan_keys, \
            f"Mismatch: {plan_key=} must not be in {plan_collection.buffered_plan_keys=}"
        assert pair_plan.plan_state == PlanState.PlanState_READY, \
            f"Mismatch: plan_state must be {PlanState.PlanState_READY}, found {pair_plan.plan_state=}"
        assert pair_plan.port is not None, \
            f"Mismatch: pair_plan.port must not be None, found {pair_plan.port=}"


def _check_all_plan_pause_by_system_control_ui_button_update(
        leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        max_loop_count_per_side, refresh_sec_update_fixture, update_type: str):
    max_loop_count_per_side = 2
    leg1_leg2_symbol_list = leg1_leg2_symbol_list[:10]
    result_list: List[Tuple[str, str, PairPlanBaseModel, StreetBookServiceHttpClient]] = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=len(leg1_leg2_symbol_list)) as executor:
        results = [executor.submit(place_sanity_chores, leg1_symbol, leg2_symbol, copy.deepcopy(pair_plan_),
                                   copy.deepcopy(expected_plan_limits_),
                                   copy.deepcopy(expected_plan_status_), copy.deepcopy(symbol_overview_obj_list),
                                   copy.deepcopy(last_barter_fixture_list), copy.deepcopy(market_depth_basemodel_list),
                                   max_loop_count_per_side, refresh_sec_update_fixture)
                   for leg1_symbol, leg2_symbol in leg1_leg2_symbol_list]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())
            else:
                buy_symbol, sell_symbol, created_pair_plan, executor_web_client = future.result()
                result_list.append((buy_symbol, sell_symbol, created_pair_plan, executor_web_client))

    # Simulating all plan pause - initiating all start pause using pause_all_plans field update in system_control
    if update_type.lower() == "patch":
        system_control_obj = SystemControlBaseModel(id=1, kill_switch=False, pause_all_plans=True, 
                                                    load_buffer_plans=False, cxl_baskets=False)
        updated_system_control = email_book_service_native_web_client.patch_system_control_client(
            system_control_obj.to_json_dict(exclude_none=True))
        assert updated_system_control == system_control_obj, \
            f"Mismatch system_control: expected: {system_control_obj}, updated: {updated_system_control}"
    else:
        system_control_obj = email_book_service_native_web_client.get_system_control_client(system_control_id=1)
        system_control_obj.pause_all_plans = True
        updated_system_control = email_book_service_native_web_client.put_system_control_client(
            system_control_obj)
        assert updated_system_control == system_control_obj, \
            f"Mismatch system_control: expected: {system_control_obj}, updated: {updated_system_control}"

    time.sleep(5)

    # checking alert
    check_str = "Triggered pause_all_plan event at"
    assert_fail_msg = f"Can't find alert of {check_str!r} in contact_alert"
    check_alert_str_in_contact_alert(check_str, assert_fail_msg)

    # verifying all plan pause
    pair_plan_list = email_book_service_beanie_web_client.get_all_pair_plan_client()
    for pair_plan_ in pair_plan_list:
        assert pair_plan_.plan_state == PlanState.PlanState_PAUSED, \
            f"Mismatched pair_plan.plan_state: expected: {pair_plan_.plan_state}, updated {PlanState.PlanState_PAUSED}"


@pytest.mark.nightly
def test_all_plan_pause_by_system_control_ui_button_though_patch(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, refresh_sec_update_fixture):
    _check_all_plan_pause_by_system_control_ui_button_update(
        leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        max_loop_count_per_side, refresh_sec_update_fixture, "patch")


@pytest.mark.nightly
def test_all_plan_pause_by_system_control_ui_button_though_put(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, refresh_sec_update_fixture):
    _check_all_plan_pause_by_system_control_ui_button_update(
        leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        max_loop_count_per_side, refresh_sec_update_fixture, "put")


@pytest.mark.nightly
def test_sequenced_active_plans_with_same_symbol_side_block_with_leg1_buy(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side,
        expected_chore_limits_, refresh_sec_update_fixture):
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]

    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    created_pair_plan, executor_http_client = (
        create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                           market_depth_basemodel_list))

    # First created plan is already active, checking if next plan, if tries to get activated with same symbol-side
    # gets exception

    try:
        created_pair_plan, executor_http_client = (
            create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list,
                                               last_barter_fixture_list,
                                               market_depth_basemodel_list))
    except Exception as e:
        err_str_ = "Ongoing plan already exists with same symbol-side pair legs"
        assert err_str_ in str(e), \
            (f"Plan tring to be activated with same symbol-side must raise exception with description: "
             f"{err_str_} but can't find this description, exception: {e}")
    else:
        assert False, ("Plan with same symbol-side must raise exception while another plan is already ongoing, "
                       "but got activated likely because of some bug")


@pytest.mark.nightly
def test_sequenced_active_plans_with_same_symbol_side_block_with_leg1_sell(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side,
        expected_chore_limits_, refresh_sec_update_fixture):
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]

    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    created_pair_plan, executor_http_client = (
        create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                           expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                           market_depth_basemodel_list, leg1_side=Side.SELL,
                                           leg2_side=Side.BUY))

    # First created plan is already active, checking if next plan, if tries to get activated with same symbol-side
    # gets exception

    try:
        created_pair_plan, executor_http_client = (
            create_pre_chore_test_requirements(leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list,
                                               last_barter_fixture_list,
                                               market_depth_basemodel_list, leg1_side=Side.SELL,
                                               leg2_side=Side.BUY))
    except Exception as e:
        err_str_ = "Ongoing plan already exists with same symbol-side pair legs"
        assert err_str_ in str(e), \
            (f"Plan tring to be activated with same symbol-side must raise exception with description: "
             f"{err_str_} but can't find this description, exception: {e}")
    else:
        assert False, ("Plan with same symbol-side must raise exception while another plan is already ongoing, "
                       "but got activated likely because of some bug")


# @@@ failing since plan is now paused instead of DONE once completed and 2 plans can't be ongoing
@pytest.mark.nightly
def _test_sequenced_fully_consume_same_symbol_plans(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, expected_chore_limits_, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]

    expected_plan_limits_.max_single_leg_notional = 18000
    expected_plan_limits_.max_open_single_leg_notional = 18000
    expected_plan_limits_.max_net_filled_notional = 18000
    expected_plan_limits_.min_chore_notional = 15000
    plan_done_after_exhausted_consumable_notional(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_, expected_plan_status_,
        symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        refresh_sec_update_fixture, Side.BUY)

    plan_done_after_exhausted_consumable_notional(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_, expected_plan_status_,
        symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        refresh_sec_update_fixture, Side.BUY)


# fixme: log file generation logic is disabled
@pytest.mark.nightly2
def test_opp_symbol_plan_activate_block_in_single_day_with_buy_first(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, expected_chore_limits_,
        refresh_sec_update_fixture):
    barter_data_file_path = PAIR_STRAT_ENGINE_DIR / "data" / "barter_ready_records.csv"
    csv_data_df = pd.read_csv(barter_data_file_path)
    recovery_df = copy.deepcopy(csv_data_df)

    try:
        leg1_symbol = leg1_leg2_symbol_list[0][0]
        leg2_symbol = leg1_leg2_symbol_list[0][1]

        # updated values to enable lock file generation when plan is activated
        csv_data_df.loc[csv_data_df['ticker'] == leg1_symbol, 'settled_tradable'] = False
        csv_data_df.loc[csv_data_df['ticker'] == leg1_symbol, 'executed_tradable'] = False
        csv_data_df.loc[csv_data_df['ticker'] == leg2_symbol, 'settled_tradable'] = False
        csv_data_df.loc[csv_data_df['ticker'] == leg2_symbol, 'executed_tradable'] = False
        csv_data_df.to_csv(barter_data_file_path, index=False)

        # updating static data in pair-plan engine service
        email_book_service_native_web_client.reload_bartering_data_query_client()

        expected_plan_limits_1 = copy.deepcopy(expected_plan_limits_)
        expected_plan_limits_1.max_single_leg_notional = 18000
        expected_plan_limits_1.max_open_single_leg_notional = 18000
        expected_plan_limits_1.max_net_filled_notional = 18000
        expected_plan_limits_1.min_chore_notional = 15000
        plan_done_after_exhausted_consumable_notional(
            leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_1, expected_plan_status_,
            symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
            refresh_sec_update_fixture, Side.BUY)

        try:
            plan_done_after_exhausted_consumable_notional(
                leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_, expected_plan_status_,
                symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
                refresh_sec_update_fixture, Side.BUY, leg_1_side=Side.SELL, leg_2_side=Side.BUY)
        except Exception as e:
            err_str_ = ("Found plan activated today with symbols of this plan being used in opposite sides - "
                        "can't activate this plan today")
            if err_str_ not in str(e):
                raise e
        else:
            assert False, ("Plan with opposite symbol-side must raise exception while activating in same day of "
                           "other plan activated, but got activated likely because of some bug")
    except Exception as e:
        raise e
    finally:
        # reverting file changes
        recovery_df.to_csv(barter_data_file_path, index=False)
        # updating static data in pair-plan engine service
        email_book_service_native_web_client.reload_bartering_data_query_client()


# fixme: log file generation logic is disabled
@pytest.mark.nightly2
def test_opp_symbol_plan_activate_block_in_single_day_with_sell_first(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, expected_chore_limits_,
        refresh_sec_update_fixture):
    barter_data_file_path = PAIR_STRAT_ENGINE_DIR / "data" / "barter_ready_records.csv"
    csv_data_df = pd.read_csv(barter_data_file_path)
    recovery_df = copy.deepcopy(csv_data_df)

    try:
        leg1_symbol = leg1_leg2_symbol_list[0][0]
        leg2_symbol = leg1_leg2_symbol_list[0][1]

        # updated values to enable lock file generation when plan is activated
        csv_data_df.loc[csv_data_df['ticker'] == leg1_symbol, 'settled_tradable'] = False
        csv_data_df.loc[csv_data_df['ticker'] == leg1_symbol, 'executed_tradable'] = False
        csv_data_df.loc[csv_data_df['ticker'] == leg2_symbol, 'settled_tradable'] = False
        csv_data_df.loc[csv_data_df['ticker'] == leg2_symbol, 'executed_tradable'] = False
        csv_data_df.to_csv(barter_data_file_path)

        # updating static data in pair-plan engine service
        email_book_service_native_web_client.reload_bartering_data_query_client()

        expected_plan_limits_.max_single_leg_notional = 21000
        expected_plan_limits_.max_open_single_leg_notional = 21000
        expected_plan_limits_.max_net_filled_notional = 21000
        expected_plan_limits_.min_chore_notional = 15000
        plan_done_after_exhausted_consumable_notional(
            leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_, expected_plan_status_,
            symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
            refresh_sec_update_fixture, Side.SELL, leg_1_side=Side.SELL, leg_2_side=Side.BUY)

        try:
            plan_done_after_exhausted_consumable_notional(
                leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_, expected_plan_status_,
                symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
                refresh_sec_update_fixture, Side.SELL)
        except Exception as e:
            err_str_ = ("Found plan activated today with symbols of this plan being used in opposite sides - "
                        "can't activate this plan today")
            assert err_str_ in str(e), \
                (f"Plan created with opposite symbol-side must raise exception with description: {err_str_} but "
                 f"can't find this description, exception: {e}")
        else:
            assert False, ("Plan with opposite symbol-side must raise exception while activating in same day of "
                           "other plan activated, but got activated likely because of some bug")
    except Exception as e:
        raise e
    finally:
        # reverting file changes
        recovery_df.to_csv(barter_data_file_path)
        # updating static data in pair-plan engine service
        email_book_service_native_web_client.reload_bartering_data_query_client()


@pytest.mark.nightly
def test_sequenced_fully_consume_diff_symbol_plans(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        buy_chore_, sell_chore_, max_loop_count_per_side, expected_chore_limits_,
        refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]

    expected_plan_limits_.max_single_leg_notional = 18000
    expected_plan_limits_.max_open_single_leg_notional = 18000
    expected_plan_limits_.max_net_filled_notional = 18000
    expected_plan_limits_.min_chore_notional = 15000
    plan_done_after_exhausted_consumable_notional(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_, expected_plan_status_,
        symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        refresh_sec_update_fixture, Side.BUY)

    buy_symbol = leg1_leg2_symbol_list[1][0]
    sell_symbol = leg1_leg2_symbol_list[1][1]
    plan_done_after_exhausted_consumable_notional(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_, expected_plan_status_,
        symbol_overview_obj_list, last_barter_fixture_list, market_depth_basemodel_list,
        refresh_sec_update_fixture, Side.BUY)


@pytest.mark.nightly
def test_reactivate_after_pause_plan(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        market_depth_basemodel_list, last_barter_fixture_list,
        refresh_sec_update_fixture):
    # creates and activates multiple pair_plans
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    activated_pair_plan, executor_http_client = (
        create_n_activate_plan(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
                                expected_plan_status_, symbol_overview_obj_list,
                                market_depth_basemodel_list))

    config_file_path, config_dict, config_dict_str = get_config_file_path_n_config_dict(activated_pair_plan.id)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        executor_http_client.barter_simulator_reload_config_query_client()

        time.sleep(2)
        pause_pair_plan = PairPlanBaseModel.from_kwargs(_id=activated_pair_plan.id,
                                              plan_state=PlanState.PlanState_PAUSED)
        email_book_service_native_web_client.patch_pair_plan_client(
            pause_pair_plan.to_dict(exclude_none=True))

        time.sleep(2)
        reactivate_pair_plan = PairPlanBaseModel.from_kwargs(_id=activated_pair_plan.id,
                                                   plan_state=PlanState.PlanState_ACTIVE)
        email_book_service_native_web_client.patch_pair_plan_client(
            reactivate_pair_plan.to_dict(exclude_none=True))

        time.sleep(2)
        total_chore_count_for_each_side = 2
        place_sanity_chores_for_executor(
            buy_symbol, sell_symbol, activated_pair_plan, total_chore_count_for_each_side, last_barter_fixture_list,
            residual_wait_sec, executor_http_client)
    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        print(f"Some Error Occurred: exception: {e}, "
              f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        raise Exception(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_pause_done_n_unload_plan(static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
                                   expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
                                   market_depth_basemodel_list, last_barter_fixture_list,
                                   refresh_sec_update_fixture):
    # making limits suitable for this test
    expected_plan_limits_.max_open_chores_per_side = 10
    expected_plan_limits_.residual_restriction.max_residual = 105000
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    active_plan_list: List[PairPlanBaseModel] = []
    for buy_symbol, sell_symbol in leg1_leg2_symbol_list[:2]:
        activated_pair_plan, executor_web_client = (
            create_pre_chore_test_requirements(buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
                                               expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
                                               market_depth_basemodel_list))
        active_plan_list.append(activated_pair_plan)

    email_book_service_native_web_client.patch_pair_plan_client(
        PairPlanBaseModel.from_kwargs(_id=active_plan_list[-1].id,
                                       plan_state=PlanState.PlanState_READY).to_dict(exclude_none=True))

    time.sleep(5)

    for active_plan in active_plan_list:

        if active_plan != active_plan_list[-1]:
            email_book_service_native_web_client.patch_pair_plan_client(
                PairPlanBaseModel.from_kwargs(_id=active_plan.id,
                                               plan_state=PlanState.PlanState_PAUSED).to_dict(exclude_none=True))

            time.sleep(5)
            email_book_service_native_web_client.patch_pair_plan_client(
                PairPlanBaseModel.from_kwargs(_id=active_plan.id,
                                               plan_state=PlanState.PlanState_DONE).to_dict(exclude_none=True))

            time.sleep(5)
        plan_key = get_plan_key_from_pair_plan(active_plan)
        plan_collection = email_book_service_native_web_client.get_plan_collection_client(1)
        plan_collection.loaded_plan_keys.remove(plan_key)
        plan_collection.buffered_plan_keys.append(plan_key)

        email_book_service_native_web_client.put_plan_collection_client(plan_collection)
        time.sleep(2)

        pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_plan.id)
        assert pair_plan.server_ready_state == 0, \
            "Mismatch: server_ready_state must be 0 after plan unload"

    # loading plan to get it deleted by clean_n_set_limits of another tests
    for index, active_plan in enumerate(active_plan_list):
        plan_key = get_plan_key_from_pair_plan(active_plan)
        plan_collection = email_book_service_native_web_client.get_plan_collection_client(1)
        plan_collection.loaded_plan_keys.append(plan_key)
        plan_collection.buffered_plan_keys.remove(plan_key)

        email_book_service_native_web_client.put_plan_collection_client(plan_collection)
        time.sleep(residual_wait_sec)   # waiting for plan to get loaded completely

        pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_plan.id)
        executor_http_client = StreetBookServiceHttpClient.set_or_get_if_instance_exists(
            pair_plan.host, pair_plan.port)
        buy_symbol = active_plan.pair_plan_params.plan_leg1.sec.sec_id
        sell_symbol = active_plan.pair_plan_params.plan_leg2.sec.sec_id
        run_symbol_overview(buy_symbol, sell_symbol, symbol_overview_obj_list, executor_http_client)
    time.sleep(residual_wait_sec)


def _frequent_update_plan_view_in_plan(buy_symbol, sell_symbol, pair_plan_,
        expected_plan_limits_, expected_start_status_, symbol_overview_obj_list,
        last_barter_fixture_list, market_depth_basemodel_list,
        refresh_sec):
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec
    residual_wait_sec = 4 * refresh_sec

    created_pair_plan, executor_web_client = (
        move_snoozed_pair_plan_to_ready_n_then_active(pair_plan_, market_depth_basemodel_list,
                                                       symbol_overview_obj_list, expected_plan_limits_,
                                                       expected_start_status_))

    loop_count = 2000
    for i in range(loop_count):
        if i % 2 == 0:
            plan_view_obj = PlanViewBaseModel.from_kwargs(_id=created_pair_plan.id, market_premium=i)
        else:
            plan_view_obj = PlanViewBaseModel.from_kwargs(_id=created_pair_plan.id, balance_notional=i)
        photo_book_web_client.patch_plan_view_client(plan_view_obj.to_dict(exclude_none=True))

    updated_plan_view = photo_book_web_client.get_plan_view_client(created_pair_plan.id)
    assert updated_plan_view.market_premium == loop_count-2, \
        (f"Mismatched: market_premium must be {loop_count-2} but found {updated_plan_view.market_premium}, "
         f"_id: {created_pair_plan.id}")
    assert updated_plan_view.balance_notional == loop_count-1, \
        (f"Mismatched: balance_notional must be {loop_count-1} but found {updated_plan_view.balance_notional}, "
         f"_id: {created_pair_plan.id}")


@pytest.mark.nightly
def test_log_book_frequent_pair_plan_updates(
        static_data_, clean_and_set_limits, leg1_leg2_symbol_list, pair_plan_,
        expected_plan_limits_, expected_plan_status_, symbol_overview_obj_list,
        market_depth_basemodel_list, last_barter_fixture_list,
        refresh_sec_update_fixture):

    leg1_leg2_symbol_list = []
    total_plans = 10
    pair_plan_list = []
    for i in range(1, total_plans + 1):
        leg1_symbol = f"Type1_Sec_{i}"
        leg2_symbol = f"Type2_Sec_{i}"
        leg1_leg2_symbol_list.append((leg1_symbol, leg2_symbol))

        stored_pair_plan_basemodel = create_plan(leg1_symbol, leg2_symbol, pair_plan_)
        pair_plan_list.append(stored_pair_plan_basemodel)
        time.sleep(2)

    with concurrent.futures.ThreadPoolExecutor(max_workers=len(leg1_leg2_symbol_list)) as executor:
        results = [executor.submit(_frequent_update_plan_view_in_plan, buy_sell_symbol[0], buy_sell_symbol[1],
                                   pair_plan_list[idx],
                                   deepcopy(expected_plan_limits_), deepcopy(expected_plan_status_),
                                   deepcopy(symbol_overview_obj_list),
                                   deepcopy(last_barter_fixture_list), deepcopy(market_depth_basemodel_list),
                                   refresh_sec_update_fixture)
                   for idx, buy_sell_symbol in enumerate(leg1_leg2_symbol_list)]

        for future in concurrent.futures.as_completed(results):
            if future.exception() is not None:
                raise Exception(future.exception())


def _check_all_computes_in_models_other_than_chore_snapshot(
        active_pair_plan: PairPlanBaseModel, symbol, side, executor_http_client, chore_snapshot,
        new_qty, new_px, chore_status, open_qty, open_notional, open_px, filled_qty,
        filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px, other_side_residual_qty,
        other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
        residual_qty: int | None = None, is_sell_buy_plan: bool = False):
    symbol_side_snapshot_list = (
        executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(symbol, side))
    assert len(symbol_side_snapshot_list) == 1, \
        (f"found {len(symbol_side_snapshot_list) = }, must be exact 1 for symbol and side: "
         f"{symbol, side}")

    symbol_side_snapshot = symbol_side_snapshot_list[0]
    assert symbol_side_snapshot.total_qty == new_qty, \
        (f"Mismatched: expected symbol_side_snapshot.total_qty: {new_qty}, "
         f"found {symbol_side_snapshot.total_qty = }")
    assert symbol_side_snapshot.avg_px == new_px, \
        (f"Mismatched: expected symbol_side_snapshot.avg_px: {new_px}, "
         f"found {symbol_side_snapshot.avg_px = }")
    assert symbol_side_snapshot.total_filled_qty == filled_qty, \
        (f"Mismatched: symbol_side_snapshot.total_filled_qty must be {filled_qty}, found "
         f"{symbol_side_snapshot.total_filled_qty = }")
    assert symbol_side_snapshot.total_fill_notional == filled_notional, \
        (f"Mismatched: symbol_side_snapshot.total_fill_notional must be {filled_notional}, "
         f"found {symbol_side_snapshot.total_fill_notional = }")
    assert symbol_side_snapshot.avg_fill_px == filled_px, \
        (f"Mismatched: symbol_side_snapshot.avg_fill_px must be {filled_px}, found "
         f"{symbol_side_snapshot.avg_fill_px = }")
    assert symbol_side_snapshot.total_cxled_qty == cxled_qty, \
        (f"Mismatched: symbol_side_snapshot.total_cxled_qty must be {cxled_qty}, found "
         f"{symbol_side_snapshot.total_cxled_qty = }")
    assert (symbol_side_snapshot.total_cxled_notional == cxled_notional), \
        (f"Mismatched: symbol_side_snapshot.total_cxled_notional must be "
         f"{cxled_notional}, found {symbol_side_snapshot.total_cxled_notional = }")
    assert symbol_side_snapshot.avg_cxled_px == cxled_px, \
        (f"Mismatched: symbol_side_snapshot.avg_cxled_px must be {cxled_px}, found "
         f"{symbol_side_snapshot.avg_cxled_px = }")
    assert symbol_side_snapshot.last_update_fill_px == filled_px, \
        (f"Mismatched: symbol_side_snapshot.last_update_fill_px must be {filled_px}, found "
         f"{symbol_side_snapshot.last_update_fill_px = }")
    assert symbol_side_snapshot.last_update_fill_qty == last_filled_qty, \
        (f"Mismatched: symbol_side_snapshot.last_update_fill_qty must be {last_filled_qty}, found "
         f"{symbol_side_snapshot.last_update_fill_qty = }")

    leg1_last_barter_px, leg2_last_barter_px = get_both_side_last_barter_px()
    plan_limits = executor_http_client.get_plan_limits_client(active_pair_plan.id)
    plan_brief = executor_http_client.get_plan_brief_client(active_pair_plan.id)
    hedge_ratio = 1.0
    if side == Side.BUY:
        plan_brief_bartering_brief = plan_brief.pair_buy_side_bartering_brief
        if is_sell_buy_plan:
            hedge_ratio = active_pair_plan.pair_plan_params.hedge_ratio
    else:
        plan_brief_bartering_brief = plan_brief.pair_sell_side_bartering_brief
        if not is_sell_buy_plan:   # is buy-sell plan
            hedge_ratio = active_pair_plan.pair_plan_params.hedge_ratio
        
    assert (plan_brief_bartering_brief.open_qty == open_qty), \
        (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_qty: "
         f"{open_qty}, found {plan_brief_bartering_brief.open_qty = }")
    assert (plan_brief_bartering_brief.open_notional == open_notional), \
        (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.open_notional: "
         f"{open_notional}, found {plan_brief_bartering_brief.open_notional = }")
    assert (plan_brief_bartering_brief.residual_qty == residual_qty), \
        (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.residual_qty: "
         f"{residual_qty}, found {plan_brief_bartering_brief.residual_qty = }")
    if chore_status in [ChoreStatusType.OE_DOD, ChoreStatusType.OE_FILLED,
                        ChoreStatusType.OE_OVER_FILLED, ChoreStatusType.OE_OVER_CXLED]:
        consumable_open_chores = 5
    else:
        consumable_open_chores = 4
    assert (plan_brief_bartering_brief.consumable_open_chores == consumable_open_chores), \
        (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_chores: "
         f"{consumable_open_chores}, found {plan_brief_bartering_brief.consumable_open_chores = }")
    assert (plan_brief_bartering_brief.all_bkr_cxlled_qty == cxled_qty), \
        (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.all_bkr_cxlled_qty: "
         f"{cxled_qty}, found {plan_brief_bartering_brief.all_bkr_cxlled_qty = }")
    assert (plan_brief_bartering_brief.consumable_notional == (
            (plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional - open_notional)), \
        (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_notional: "
         f"{(plan_limits.max_single_leg_notional * hedge_ratio) - symbol_side_snapshot.total_fill_notional - open_notional}, "
         f"found {plan_brief_bartering_brief.consumable_notional=}")
    assert (plan_brief_bartering_brief.consumable_open_notional ==
            plan_limits.max_open_single_leg_notional - open_notional), \
        (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_open_notional: "
         f"{plan_limits.max_open_single_leg_notional - open_notional}, "
         f"found {plan_brief_bartering_brief.consumable_open_notional = }")
    total_security_size: int = \
        static_data.get_security_float_from_ticker(chore_snapshot.chore_brief.security.sec_id)
    assert (plan_brief_bartering_brief.consumable_concentration == (
            (total_security_size / 100 * plan_limits.max_concentration) -
            (open_qty + symbol_side_snapshot.total_filled_qty))), \
        (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_concentration: "
         f"{(total_security_size / 100 * plan_limits.max_concentration) - (open_qty + symbol_side_snapshot.total_filled_qty)}, "
         f"found {plan_brief_bartering_brief.consumable_concentration = }")
    assert (plan_brief_bartering_brief.consumable_cxl_qty == (
            (((open_qty + symbol_side_snapshot.total_filled_qty +
               symbol_side_snapshot.total_cxled_qty) / 100) * plan_limits.cancel_rate.max_cancel_rate) -
            symbol_side_snapshot.total_cxled_qty)), \
        (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_cxl_qty: "
         f"{(((open_qty + symbol_side_snapshot.total_filled_qty + symbol_side_snapshot.total_cxled_qty) / 100) * plan_limits.cancel_rate.max_cancel_rate) - symbol_side_snapshot.total_cxled_qty}, "
         f"found {plan_brief_bartering_brief.consumable_cxl_qty = }")
    if not is_sell_buy_plan:
        if side == Side.BUY:
            current_last_barter_px = leg1_last_barter_px
            other_last_barter_px = leg2_last_barter_px
        else:
            current_last_barter_px = leg2_last_barter_px
            other_last_barter_px = leg1_last_barter_px
    else:
        if side == Side.SELL:
            current_last_barter_px = leg1_last_barter_px
            other_last_barter_px = leg2_last_barter_px
        else:
            current_last_barter_px = leg2_last_barter_px
            other_last_barter_px = leg1_last_barter_px

    assert (plan_brief_bartering_brief.indicative_consumable_residual == (
            plan_limits.residual_restriction.max_residual -
            ((plan_brief_bartering_brief.residual_qty *
              get_px_in_usd(current_last_barter_px)) - (
                     other_side_residual_qty * get_px_in_usd(other_last_barter_px))))), \
        (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.indicative_consumable_residual: "
         f"{plan_limits.residual_restriction.max_residual - ((plan_brief_bartering_brief.residual_qty * get_px_in_usd(current_last_barter_px)) - (other_side_residual_qty * get_px_in_usd(other_last_barter_px)))}, "
         f"found {plan_brief_bartering_brief.indicative_consumable_residual = }")
    assert (plan_brief.consumable_nett_filled_notional == (
            plan_limits.max_net_filled_notional -
            abs(symbol_side_snapshot.total_fill_notional - other_side_fill_notional))), \
        (f"Mismatched: expected plan_brief.pair_{side.lower()}_side_bartering_brief.consumable_nett_filled_notional: "
         f"{plan_limits.max_open_single_leg_notional}, "
         f"found {plan_brief_bartering_brief.consumable_nett_filled_notional = }")

    plan_status = executor_http_client.get_plan_status_client(active_pair_plan.id)
    if side == Side.BUY:
        total_qty = plan_status.total_buy_qty
        total_open_qty = plan_status.total_open_buy_qty
        total_open_notional = plan_status.total_open_buy_notional
        avg_open_px = plan_status.avg_open_buy_px
        total_fill_qty = plan_status.total_fill_buy_qty
        total_fill_notional = plan_status.total_fill_buy_notional
        avg_fill_px = plan_status.avg_fill_buy_px
        total_cxl_qty = plan_status.total_cxl_buy_qty
        total_cxl_notional = plan_status.total_cxl_buy_notional
        avg_cxl_px = plan_status.avg_cxl_buy_px
    else:
        total_qty = plan_status.total_sell_qty
        total_open_qty = plan_status.total_open_sell_qty
        total_open_notional = plan_status.total_open_sell_notional
        avg_open_px = plan_status.avg_open_sell_px
        total_fill_qty = plan_status.total_fill_sell_qty
        total_fill_notional = plan_status.total_fill_sell_notional
        avg_fill_px = plan_status.avg_fill_sell_px
        total_cxl_qty = plan_status.total_cxl_sell_qty
        total_cxl_notional = plan_status.total_cxl_sell_notional
        avg_cxl_px = plan_status.avg_cxl_sell_px

    total_open_exposure = plan_status.total_open_exposure
    total_fill_exposure = plan_status.total_fill_exposure
    total_cxl_exposure = plan_status.total_cxl_exposure
    assert total_qty == new_qty, \
        (f"Mismatched: expected plan_status.total_{side.lower()}_qty: "
         f"{new_qty}, found {total_qty = }")
    assert total_open_qty == open_qty, \
        (f"Mismatched: expected plan_status total_open_{side.lower()}_qty: "
         f"{open_qty}, found {total_open_qty = }")
    assert (total_open_notional == open_notional), \
        (f"Mismatched: expected plan_status.total_open_{side.lower()}_notional: "
         f"{open_notional}, found {total_open_notional = }")
    assert (avg_open_px == open_px), \
        (f"Mismatched: expected plan_status.avg_open_{side.lower()}_px: "
         f"{open_px}, found {avg_open_px = }")
    assert (total_fill_qty == filled_qty), \
        (f"Mismatched: expected plan_status.total_fill_{side.lower()}_qty: "
         f"{filled_qty}, found {total_fill_qty = }")
    assert (total_fill_notional == filled_notional), \
        (f"Mismatched: expected plan_status.total_fill_{side.lower()}_notional: "
         f"{filled_notional}, found {total_fill_notional = }")
    assert (avg_fill_px == filled_px), \
        (f"Mismatched: expected plan_status.avg_fill_{side.lower()}_px: "
         f"{filled_px}, found {avg_fill_px = }")
    assert (total_cxl_qty == cxled_qty), \
        (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_qty: "
         f"{cxled_qty}, found {total_cxl_qty = }")
    assert (total_cxl_notional == cxled_notional), \
        (f"Mismatched: expected plan_status.total_cxl_{side.lower()}_notional: "
         f"{cxled_notional}, found {total_cxl_notional = }")
    assert (avg_cxl_px == cxled_px), \
        (f"Mismatched: expected plan_status.avg_cxl_{side.lower()}_px: "
         f"{cxled_px}, found {avg_cxl_px = }")
    assert (total_open_exposure == open_exposure), \
        (f"Mismatched: expected plan_status.total_open_exposure: "
         f"{open_exposure}, found {total_open_exposure = }")
    assert (total_fill_exposure == filled_exposure), \
        (f"Mismatched: expected plan_status.total_fill_exposure: "
         f"{filled_exposure}, found {total_fill_exposure = }")
    assert (total_cxl_exposure == cxled_exposure), \
        (f"Mismatched: expected plan_status.total_cxl_exposure: "
         f"{cxled_exposure}, found {total_cxl_exposure = }")

    contact_status = email_book_service_native_web_client.get_contact_status_client(1)
    if side == Side.BUY:
        overall_notional = contact_status.overall_buy_notional
        overall_fill_notional = contact_status.overall_buy_fill_notional
    else:
        overall_notional = contact_status.overall_sell_notional
        overall_fill_notional = contact_status.overall_sell_fill_notional
    assert (overall_notional == open_notional + filled_notional), \
        (f"Mismatched: expected contact_status.overall_{side.lower()}_notional: "
         f"{open_notional + filled_notional}, found {overall_notional = }")
    assert (overall_fill_notional == filled_notional), \
        (f"Mismatched: expected contact_status.overall_{side.lower()}_fill_notional: "
         f"{filled_notional}, found {overall_fill_notional = }")


def check_all_computes_for_amend(
        active_pair_plan, symbol, side, chore_id, executor_http_client,
        new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
        pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty,
        open_qty, open_notional, open_px, filled_qty,
        filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px, other_side_residual_qty,
        other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
        residual_qty: int | None = None, is_sell_buy_plan: bool = False, total_lapsed_post_unack_amend: int = 0,
        total_lapsed_qty: int = 0):
    chore_snapshot = get_chore_snapshot_from_chore_id(chore_id,
                                                      executor_http_client)
    assert chore_snapshot.chore_status == chore_status, \
        f"Mismatched: Chore status must be {chore_status} but found: {chore_snapshot.chore_status = }"
    assert chore_snapshot.chore_brief.qty == new_qty, \
        f"Mismatched: expected chore_snapshot qty: {new_qty} found: {chore_snapshot.chore_brief.qty = }"
    assert chore_snapshot.chore_brief.px == new_px, \
        f"Mismatched: expected chore_snapshot px: {new_px} found: {chore_snapshot.chore_brief.px = }"
    expected_chore_notional = new_qty * get_px_in_usd(new_px)
    assert chore_snapshot.chore_brief.chore_notional == expected_chore_notional, \
        (f"Mismatched: expected chore_snapshot expected_chore_notional: {expected_chore_notional} "
         f"found: {chore_snapshot.chore_brief.chore_notional = }")
    assert chore_snapshot.total_amend_dn_qty == total_amend_dn_qty, \
        (f"Mismatched: expected chore_snapshot total_amend_dn_qty: {total_amend_dn_qty} "
         f"found: {chore_snapshot.total_amend_dn_qty= }")
    assert chore_snapshot.total_amend_up_qty == total_amend_up_qty, \
        (f"Mismatched: expected chore_snapshot total_amend_up_qty: {total_amend_up_qty} "
         f"found: {chore_snapshot.total_amend_up_qty= }")
    assert chore_snapshot.cxled_qty == cxled_qty, \
        f"Mismatched: ChoreSnapshot cxled_qty must be {cxled_qty}, found {chore_snapshot.cxled_qty}"
    assert chore_snapshot.cxled_notional == cxled_notional, \
        (f"Mismatched: ChoreSnapshot cxled_notional must be {cxled_notional}, "
         f"found {chore_snapshot.cxled_notional}")
    assert chore_snapshot.avg_cxled_px == cxled_px, \
        (f"Mismatched: ChoreSnapshot avg_cxled_px must be "
         f"{cxled_px}, found {chore_snapshot.avg_cxled_px}")
    assert chore_snapshot.filled_qty == filled_qty, \
        f"Mismatched: ChoreSnapshot filled_qty must be {filled_qty}, found {chore_snapshot.filled_qty}"
    assert chore_snapshot.fill_notional == filled_notional, \
        (f"Mismatched: ChoreSnapshot fill_notional must be {filled_notional}, "
         f"found {chore_snapshot.fill_notional}")
    assert chore_snapshot.pending_amend_dn_px == pending_amend_dn_px, \
        (f"Mismatched: ChoreSnapshot pending_amend_dn_px must be {pending_amend_dn_px}, "
         f"found {chore_snapshot.pending_amend_dn_px}")
    assert chore_snapshot.pending_amend_dn_qty == pending_amend_dn_qty, \
        (f"Mismatched: ChoreSnapshot pending_amend_dn_qty must be {pending_amend_dn_qty}, "
         f"found {chore_snapshot.pending_amend_dn_qty}")
    assert chore_snapshot.pending_amend_up_px == pending_amend_up_px, \
        (f"Mismatched: ChoreSnapshot pending_amend_up_px must be {pending_amend_up_px}, "
         f"found {chore_snapshot.pending_amend_up_px}")
    assert chore_snapshot.pending_amend_up_qty == pending_amend_up_qty, \
        (f"Mismatched: ChoreSnapshot pending_amend_up_qty must be {pending_amend_up_qty}, "
         f"found {chore_snapshot.pending_amend_up_qty}")
    assert chore_snapshot.avg_fill_px == filled_px, \
        f"Mismatched: ChoreSnapshot avg_fill_px must be {filled_px}, found {chore_snapshot.avg_fill_px}"
    assert chore_snapshot.total_lapsed_qty == total_lapsed_qty, \
        (f"Mismatched: ChoreSnapshot total_lapsed_qty must be {total_lapsed_qty}, "
         f"found {chore_snapshot.total_lapsed_qty}")
    if total_lapsed_post_unack_amend:
        assert chore_snapshot.total_lapsed_post_unack_amend == total_lapsed_post_unack_amend, \
            (f"Mismatched: ChoreSnapshot total_lapsed_post_unack_amend must be {total_lapsed_post_unack_amend}, "
             f"found {chore_snapshot.total_lapsed_post_unack_amend}")

    _check_all_computes_in_models_other_than_chore_snapshot(
        active_pair_plan, symbol, side, executor_http_client, chore_snapshot,
        new_qty, new_px, chore_status, open_qty, open_notional, open_px, filled_qty,
        filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px, other_side_residual_qty,
        other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
        residual_qty, is_sell_buy_plan)


@pytest.mark.nightly
def test_simple_non_risky_amend_based_on_qty(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = buy_filled_notional - filled_qty * get_px_in_usd(px)
                cxled_exposure = buy_cxl_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_qty = 10
                pending_amend_dn_px = 0
                pending_amend_dn_qty = amend_qty
                pending_amend_up_px = 0
                pending_amend_up_qty = 0
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_qty = 10
                pending_amend_dn_px = 0
                pending_amend_dn_qty = 0
                pending_amend_up_px = 0
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event, qty=amend_qty)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            amend_px = None
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = buy_filled_notional - filled_qty * get_px_in_usd(px)
                cxled_exposure = buy_cxl_notional
            last_filled_qty = filled_qty
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK, chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                total_amend_dn_qty = 10
                total_amend_up_qty = 0
            else:
                new_qty = qty + amend_qty
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = 10

            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            last_original_qty = qty
            last_original_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            if side == Side.BUY:
                cxled_qty = open_qty + amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                total_amend_dn_qty = 10
                total_amend_up_qty = 0
            else:
                cxled_qty = open_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = 0
                total_amend_up_qty = 10

            new_px = px
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_filled_notional = filled_notional
                buy_cxl_notional = cxled_notional
                residual_qty = cxled_qty - amend_qty
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
                residual_qty = cxled_qty
            last_filled_qty = filled_qty
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)
    except AssertionError as e:
        print(e)
        raise e
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_simple_risky_amend_based_on_qty(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side in [(100, 90, buy_symbol, Side.BUY), (95, 110, sell_symbol, Side.SELL)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, buy_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            if side == Side.BUY:
                buy_filled_qty = filled_qty

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_qty = 10
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_qty = 10
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            if side == Side.BUY:
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                new_qty = qty + amend_qty
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                new_qty = qty
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0

            new_px = px
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)

            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_qty = 0
            pending_amend_up_qty = 0
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)

            if side == Side.BUY:
                cxled_qty = open_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
            else:
                cxled_qty = open_qty + amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
            residual_qty = open_qty
            new_px = px
            chore_status = ChoreStatusType.OE_DOD
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_residual_qty = cxled_qty
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

    except AssertionError as e:
        print(e)
        raise e
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_simple_non_risky_amend_based_on_px(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            if side == Side.BUY:
                buy_filled_qty = filled_qty

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = buy_filled_notional - filled_qty * get_px_in_usd(px)
                cxled_exposure = buy_cxl_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                pending_amend_dn_px = amend_px
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                pending_amend_up_px = amend_px
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = buy_filled_notional - filled_qty * get_px_in_usd(px)
                cxled_exposure = buy_cxl_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                new_px = px - amend_px
            else:
                new_px = px + amend_px
            chore_status = ChoreStatusType.OE_ACKED
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = qty - filled_qty
            cxled_px = new_px
            cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_residual_qty = cxled_qty
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

    except AssertionError as e:
        print(e)
        raise e
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_simple_risky_amend_based_on_px(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                new_px = px + amend_px
                pending_amend_up_px = amend_px
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                new_px = px - amend_px
                pending_amend_dn_px = amend_px
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            last_filled_qty = filled_qty
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_up_px = 0
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = qty - filled_qty
            cxled_px = new_px
            cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_residual_qty = residual_qty
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

    except AssertionError as e:
        print(e)
        raise e
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_simple_non_risky_amend_based_on_qty_and_px(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):

    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = 10
                total_amend_up_qty = 0
            else:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = 10

            chore_status = ChoreStatusType.OE_ACKED
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

    except AssertionError as e:
        print(e)
        raise e
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_simple_risky_amend_based_on_px_and_qty(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_qty = amend_qty
                pending_amend_up_px = amend_px
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_qty = amend_qty
                pending_amend_dn_px = amend_px
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = 10
            else:
                new_qty = qty
                new_px = px - amend_px
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = 10
                total_amend_up_qty = 0

            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)

            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_filled_notional = filled_notional
                buy_cxl_notional = cxled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

    except AssertionError as e:
        print(e)
        raise e
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_non_risky_amend_based_on_qty_and_px_with_fill_before_amd_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 20
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # placing fills before receiving AMD_ACK
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account)

            last_filled_qty = filled_qty
            filled_qty = filled_qty * 2

            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = 10
                total_amend_up_qty = 0
            else:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = 10

            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_filled_notional = filled_notional
                buy_cxl_notional = cxled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

    except AssertionError as e:
        print(e)
        raise e
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_non_risky_amend_based_on_qty_and_px_with_fulfill_before_amd_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side in [(100, 90, buy_symbol, Side.BUY), (95, 110, sell_symbol, Side.SELL)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, buy_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # placing fills before receiving AMD_ACK - makes chore filled
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account)

            last_filled_qty = filled_qty
            filled_qty = filled_qty * 2

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_FILLED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0
                chore_status = ChoreStatusType.OE_OVER_CXLED
                open_qty = 0
                open_notional = 0
                open_px = 0
            else:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
                chore_status = ChoreStatusType.OE_ACKED
                open_qty = amend_qty
                open_notional = open_qty * get_px_in_usd(new_px)
                open_px = new_px

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            if side == Side.BUY:
                paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
                assert paused_pair_plan.plan_state == PlanState.PlanState_PAUSED, \
                    f"Mismatched: plan state must be PAUSED, found: {paused_pair_plan.plan_state}"

                # Checking alert in plan_alert
                time.sleep(5)
                check_str = ("Received ChoreEventType.OE_AMD_ACK for amend qty which makes chore OVER_CXLED to chore "
                             "which was ChoreStatusType.OE_FILLED before")
                assert_fail_msg = f"Can't find alert of {check_str!r} in neither plan_alert nor contact_alert"
                check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

                # forcefully turning plan to active again for checking sell chore
                pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
                pair_plan.plan_state = PlanState.PlanState_ACTIVE
                email_book_service_native_web_client.put_pair_plan_client(pair_plan)
                time.sleep(5)
            else:
                time.sleep(5)
                check_str = ("Received ChoreEventType.OE_AMD_ACK for amend qty which makes chore back to ACKED "
                             "which was FILLED before amend")
                assert_fail_msg = f"Can't find alert: {check_str!r}"
                check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

                time.sleep(residual_wait_sec)

                cxled_qty = open_qty
                cxled_px = open_px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
                chore_status = ChoreStatusType.OE_DOD
                residual_qty = open_qty
                open_qty = 0
                open_notional = 0
                open_px = 0
                filled_notional = filled_qty * get_px_in_usd(px)
                filled_px = px
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)

    except AssertionError as e:
        print(e)
        raise AssertionError(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))



@pytest.mark.nightly
def test_non_risky_amend_based_on_qty_and_px_with_overfill_before_amd_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 60
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # placing fills before receiving AMD_ACK - makes chore filled
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account)

            last_filled_qty = filled_qty
            filled_qty = filled_qty * 2

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_OVER_FILLED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
            assert paused_pair_plan.plan_state == PlanState.PlanState_PAUSED, \
                f"Mismatched: plan state must be PAUSED, found: {paused_pair_plan.plan_state}"

            time.sleep(5)
            check_str = "Unexpected: Received fill that will make chore_snapshot OVER_FILLED"
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0
                chore_status = ChoreStatusType.OE_OVER_CXLED
                open_qty = 0
                open_notional = 0
                open_px = 0
            else:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
                chore_status = ChoreStatusType.OE_OVER_FILLED
                open_qty = 0
                open_notional = 0
                open_px = 0

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Checking alert in plan_alert
            time.sleep(5)
            check_str = ("Received ChoreEventType.OE_AMD_ACK for amend qty which makes chore OVER_CXLED to "
                         "chore which was ChoreStatusType.OE_OVER_FILLED before")
            assert_fail_msg = f"Can't find alert of {check_str!r} in neither plan_alert nor contact_alert"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            if side == Side.BUY:
                # forcefully turning plan to active again for checking sell chore
                pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
                pair_plan.plan_state = PlanState.PlanState_ACTIVE
                email_book_service_native_web_client.put_pair_plan_client(pair_plan)

    except AssertionError as e:
        print(e)
        raise AssertionError(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_non_risky_amend_up_based_on_qty_and_px_with_overfill_before_n_filled_post_amd_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    Amend Up is non-risky on sell side so using sell side only in this test
    """
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list, leg1_side=Side.SELL, leg2_side=Side.BUY)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 60
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(95, 110, leg1_symbol, Side.SELL)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, sell_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty, is_sell_buy_plan=True)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            amend_px = 1
            amend_qty = 22
            pending_amend_up_px = amend_px
            pending_amend_up_qty = amend_qty
            chore_event = ChoreEventType.OE_AMD_UP_UNACK
            chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional

            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty, is_sell_buy_plan=True)

            # placing fills before receiving AMD_ACK - makes chore filled
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account)

            last_filled_qty = filled_qty
            filled_qty = filled_qty * 2

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_OVER_FILLED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty, is_sell_buy_plan=True)

            paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
            assert paused_pair_plan.plan_state == PlanState.PlanState_PAUSED, \
                f"Mismatched: plan state must be PAUSED, found: {paused_pair_plan.plan_state}"

            time.sleep(5)
            check_str = "Unexpected: Received fill that will make chore_snapshot OVER_FILLED"
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty + amend_qty
            new_px = px + amend_px
            cxled_qty = 0
            cxled_px = 0
            cxled_notional = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = amend_qty
            chore_status = ChoreStatusType.OE_FILLED
            open_qty = 0
            open_notional = 0
            open_px = 0

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional

            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty, is_sell_buy_plan=True)

            # Checking alert in plan_alert
            time.sleep(5)
            check_str = ("Received ChoreEventType.OE_AMD_ACK for amend qty which makes chore FILLED "
                         "which was OVER_FILLED before amend")
            assert_fail_msg = f"Can't find alert of {check_str!r} in neither plan_alert nor contact_alert"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
            assert paused_pair_plan.plan_state == PlanState.PlanState_ACTIVE, \
                f"Mismatched: plan state must be ACTIVE, found: {paused_pair_plan.plan_state}"

    except AssertionError as e:
        print(e)
        raise AssertionError(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_non_risky_amend_up_based_on_qty_and_px_with_overfill_before_n_acked_post_amd_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    Amend Up is non-risky on sell side so using sell side only in this test
    """
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list, leg1_side=Side.SELL, leg2_side=Side.BUY)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 60
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(95, 110, leg1_symbol, Side.SELL)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, sell_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty, is_sell_buy_plan=True)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            amend_px = 1
            amend_qty = 30
            pending_amend_up_px = amend_px
            pending_amend_up_qty = amend_qty
            chore_event = ChoreEventType.OE_AMD_UP_UNACK
            chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional

            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty, is_sell_buy_plan=True)

            # placing fills before receiving AMD_ACK - makes chore filled
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account)

            last_filled_qty = filled_qty
            filled_qty = filled_qty * 2

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_OVER_FILLED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty, is_sell_buy_plan=True)

            paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
            assert paused_pair_plan.plan_state == PlanState.PlanState_PAUSED, \
                f"Mismatched: plan state must be PAUSED, found: {paused_pair_plan.plan_state}"

            time.sleep(5)
            check_str = "Unexpected: Received fill that will make chore_snapshot OVER_FILLED"
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty + amend_qty
            new_px = px + amend_px
            cxled_qty = 0
            cxled_px = 0
            cxled_notional = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = amend_qty
            chore_status = ChoreStatusType.OE_ACKED
            open_qty = new_qty - filled_qty
            open_px = new_px
            open_notional = open_qty * get_px_in_usd(open_px)

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional

            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty, is_sell_buy_plan=True)

            # Checking alert in plan_alert
            time.sleep(5)
            check_str = ("Received ChoreEventType.OE_AMD_ACK for amend qty which makes chore back to ACKED "
                         "which was OVER_FILLED before amend")
            assert_fail_msg = f"Can't find alert of {check_str!r} in neither plan_alert nor contact_alert"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
            assert paused_pair_plan.plan_state == PlanState.PlanState_ACTIVE, \
                f"Mismatched: plan state must be ACTIVE, found: {paused_pair_plan.plan_state}"

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional

            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty, is_sell_buy_plan=True)

    except AssertionError as e:
        print(e)
        raise AssertionError(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_based_on_px_and_qty_with_fill_before_amd_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 20
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = 10
            else:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = 10
                total_amend_up_qty = 0

            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # placing fills before receiving AMD_ACK
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account)

            last_filled_qty = filled_qty
            filled_qty = filled_qty * 2

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)

            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            residual_qty = open_qty
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_residual_qty = residual_qty
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

    except AssertionError as e:
        print(e)
        raise e
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_based_on_px_and_qty_with_fulfill_before_amd_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0

            open_qty = new_qty - filled_qty - cxled_qty
            open_px = new_px
            open_notional = open_qty * get_px_in_usd(new_px)
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # placing fills before receiving AMD_ACK - makes chore filled
            last_filled_qty = open_qty
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, last_filled_qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account, use_exact_passed_qty=True)

            filled_qty = new_qty - cxled_qty

            open_qty = 0
            open_notional = 0
            open_px = 0
            chore_status = ChoreStatusType.OE_FILLED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            chore_status = ChoreStatusType.OE_FILLED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

    except AssertionError as e:
        print(e)
        raise e
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_based_on_px_and_qty_with_overfill_before_amd_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 60
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                            (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0

            open_qty = new_qty - filled_qty - cxled_qty
            open_px = new_px
            open_notional = open_qty * get_px_in_usd(open_px)
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # placing fills before receiving AMD_ACK - makes chore filled
            last_filled_qty = open_qty + 20
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, last_filled_qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account, use_exact_passed_qty=True)

            filled_qty += last_filled_qty

            open_qty = 0
            open_notional = 0
            open_px = 0
            chore_status = ChoreStatusType.OE_OVER_FILLED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
            assert paused_pair_plan.plan_state == PlanState.PlanState_PAUSED, \
                f"Mismatched: plan state must be PAUSED, found: {paused_pair_plan.plan_state}"

            time.sleep(5)
            check_str = "Unexpected: Received fill that will make chore_snapshot OVER_FILLED"
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            chore_status = ChoreStatusType.OE_OVER_FILLED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            if side == Side.BUY:
                # forcefully turning plan to active again for checking sell chore
                pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
                pair_plan.plan_state = PlanState.PlanState_ACTIVE
                email_book_service_native_web_client.put_pair_plan_client(pair_plan)

    except AssertionError as e:
        print(e)
        raise e
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_non_risky_amend_based_on_px_and_qty_with_more_filled_qty_than_amend_qty(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    # IMPO: amending dn to qty less than open qty in non-risky case can only be possible in buy side since,
    # amend dn is non-risky in buy, sell side if amend_dn is done then it will be risky and amending up is not for
    # this test

    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 90
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(100, 90, buy_symbol, Side.BUY)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, buy_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            last_filled_qty = filled_qty

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            residual_qty = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = (qty - filled_qty) * get_px_in_usd(px)
            filled_exposure = filled_qty * get_px_in_usd(px)
            cxled_exposure = 0
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            amend_px = 1
            amend_qty = 10
            chore_event = ChoreEventType.OE_AMD_DN_UNACK

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            # not updating any value since this amend req should get rejected and values should stay unchanged
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            time.sleep(5)
            check_str = "Unexpected: Amend qty is higher than open qty - ignoring is amend request"
            assert_fail_msg = f"Couldn't find any alert saying: {check_str}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_based_on_px_and_qty_with_more_filled_qty_than_amend_qty(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    # IMPO: amending dn to qty less than open qty in risky case can only be possible in sell side since,
    # amend dn is risky in sell, buy side if amend_dn is done then it will be non-risky and amending up is not for
    # this test

    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list, leg1_side=Side.SELL, leg2_side=Side.BUY)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 95
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(110, 95, leg1_symbol, Side.SELL)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, sell_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            last_filled_qty = filled_qty

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            residual_qty = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - (qty - filled_qty) * get_px_in_usd(px)
            filled_exposure = - filled_qty * get_px_in_usd(px)
            cxled_exposure = 0
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend req chore and checking computes
            amend_px = 1
            amend_qty = 10
            chore_event = ChoreEventType.OE_AMD_DN_UNACK

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            # not updating any value since this amend req should get rejected and values should stay unchanged
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            time.sleep(5)
            check_str = "Unexpected: Amend qty is higher than open qty - ignoring is amend request"
            assert_fail_msg = f"Couldn't find any alert saying: {check_str}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_non_risky_amend_dn_based_on_px_and_qty_with_chore_making_dod(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    # IMPO: amending dn to qty less than already filled qty in non-risky case can only be possible in buy side since,
    # amend dn is non-risky in buy, sell side if amend_dn is done then it will be risky and amending up is not for
    # this test

    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(100, 90, buy_symbol, Side.BUY)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, buy_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            last_filled_qty = filled_qty

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            residual_qty = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = (qty - filled_qty) * get_px_in_usd(px)
            filled_exposure = filled_qty * get_px_in_usd(px)
            cxled_exposure = 0
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            amend_px = 1
            amend_qty = open_qty
            chore_event = ChoreEventType.OE_AMD_DN_UNACK
            chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            pending_amend_dn_px = amend_px
            pending_amend_dn_qty = amend_qty

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = (qty - filled_qty) * get_px_in_usd(px)
            filled_exposure = filled_qty * get_px_in_usd(px)
            cxled_exposure = 0

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            cxled_qty = open_qty
            cxled_px = px
            cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
            new_qty = qty
            total_amend_dn_qty = amend_qty
            total_amend_up_qty = 0
            chore_status = ChoreStatusType.OE_DOD
            open_qty = 0
            open_notional = 0
            open_px = 0
            new_px = px - amend_px
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = open_notional
            filled_exposure = filled_notional
            cxled_exposure = cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Checking alert in plan_alert
            time.sleep(5)
            check_str = "Received ChoreEventType.OE_AMD_ACK for amend qty which makes chore DOD"
            assert_fail_msg = f"Can't find alert of {check_str!r} in neither plan_alert nor contact_alert"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_dn_based_on_px_and_qty_with_amend_making_filled(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    # IMPO: amending dn to qty less than already filled qty in risky case can only be possible in sell side since,
    # amend dn is risky in sell, buy side if amend_dn is done then it will be non-risky and amending up is not for
    # this test

    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list, leg1_side=Side.SELL, leg2_side=Side.BUY)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(110, 95, leg1_symbol, Side.SELL)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, sell_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            last_filled_qty = filled_qty

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            residual_qty = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = 0
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            amend_px = 1
            amend_qty = open_qty
            chore_event = ChoreEventType.OE_AMD_DN_UNACK
            pending_amend_dn_px = amend_px
            pending_amend_dn_qty = amend_qty

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            cxled_qty = open_qty
            cxled_px = px
            cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
            new_qty = qty
            total_amend_dn_qty = open_qty  # removing whatever is open
            total_amend_up_qty = 0
            chore_status = ChoreStatusType.OE_DOD
            open_qty = 0
            open_notional = 0
            open_px = 0
            new_px = px - amend_px
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Checking alert in plan_alert
            time.sleep(5)
            check_str = "Received ChoreEventType.OE_AMD_DN_UNACK for amend qty which makes chore DOD"

            assert_fail_msg = f"Can't find alert of {check_str} in neither plan_alert nor contact_alert"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)

            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_non_risky_amend_based_on_px_and_qty_with_cxl_req_n_cxl_ack_before_amend_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 20
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            last_filled_qty = filled_qty

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                pending_amend_up_px = 0
                pending_amend_up_qty = 0
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                pending_amend_dn_px = 0
                pending_amend_dn_qty = 0
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # applying cxl req and cxl ack
            executor_http_client.barter_simulator_place_cxl_chore_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.side, latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.security.sec_id, latest_ack_obj.chore.underlying_account)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                new_qty = qty
                new_px = px - amend_px
                cxled_qty = amend_qty + (qty - filled_qty)
                cxled_notional = (amend_qty * get_px_in_usd(px) +
                                  (new_qty - filled_qty) * get_px_in_usd(px))
                total_amend_dn_qty = 10
                total_amend_up_qty = 0
                chore_status = ChoreStatusType.OE_OVER_CXLED
            else:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = new_qty - filled_qty
                cxled_notional = (((qty - filled_qty) * get_px_in_usd(px)) +
                                  (amend_qty * get_px_in_usd(px)))
                total_amend_dn_qty = 0
                total_amend_up_qty = 10
                chore_status = ChoreStatusType.OE_DOD
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                residual_qty = new_qty - filled_qty
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                residual_qty = new_qty - filled_qty - amend_qty
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            if side == Side.BUY:
                paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
                assert paused_pair_plan.plan_state == PlanState.PlanState_PAUSED, \
                    f"Mismatched: plan state must be PAUSED, found: {paused_pair_plan.plan_state}"

                time.sleep(5)
                check_str = ("Received ChoreEventType.OE_AMD_ACK for amend qty which makes chore OVER_CXLED to chore "
                             "which was ChoreStatusType.OE_DOD before")
                assert_fail_msg = f"Can't find alert of {check_str!r} in neither plan_alert nor contact_alert"
                check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id,
                                                                   check_str, assert_fail_msg)
            else:
                time.sleep(5)
                check_str = ("Received ChoreEventType.OE_AMD_ACK for amend qty which makes chore DOD, before status "
                             "was ChoreStatusType.OE_DOD - applying amend and putting chore as DOD")
                assert_fail_msg = f"Can't find alert of {check_str!r} in neither plan_alert nor contact_alert"
                check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id,
                                                                   check_str, assert_fail_msg)

            if side == Side.BUY:
                # forcefully turning plan to active again for checking sell chore
                pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
                pair_plan.plan_state = PlanState.PlanState_ACTIVE
                email_book_service_native_web_client.put_pair_plan_client(pair_plan)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_based_on_px_and_qty_with_cxl_req_n_cxl_ack_before_amend_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 20
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            last_filled_qty = filled_qty

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                pending_amend_dn_px = 0
                pending_amend_dn_qty = 0
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                pending_amend_up_px = 0
                pending_amend_up_qty = 0
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0
            residual_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # applying cxl req and cxl ack
            executor_http_client.barter_simulator_place_cxl_chore_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.side, latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.security.sec_id, latest_ack_obj.chore.underlying_account)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                cxled_qty += new_qty - filled_qty
                cxled_notional += (new_qty - filled_qty) * get_px_in_usd(new_px)
                cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
                residual_qty = (qty + amend_qty) - filled_qty
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                cxled_qty += (qty - amend_qty) - filled_qty
                cxled_notional += ((qty - amend_qty) - filled_qty) * get_px_in_usd(new_px)
                cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
                residual_qty = (qty - amend_qty) - filled_qty
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_non_risky_amend_based_on_px_and_qty_with_cxl_req_after_amend_req_n_cxl_ack_post_amend(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 20
            config_dict["symbol_configs"][symbol]["avoid_cxl_ack_after_cxl_req"] = True
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            last_filled_qty = filled_qty

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                pending_amend_up_px = 0
                pending_amend_up_qty = 0
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                pending_amend_dn_px = 0
                pending_amend_dn_qty = 0
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # applying cxl req
            executor_http_client.barter_simulator_place_cxl_chore_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.side, latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.security.sec_id, latest_ack_obj.chore.underlying_account)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                cxled_qty = amend_qty
                cxled_notional = amend_qty * get_px_in_usd(px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = 10
                total_amend_up_qty = 0
                cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            else:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = 10
                cxled_px = 0

            chore_status = ChoreStatusType.OE_CXL_UNACK
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # placing CXL ACK
            cxl_ack_chore_journal = copy.deepcopy(latest_ack_obj)
            cxl_ack_chore_journal.chore_event = ChoreEventType.OE_CXL_ACK
            cxl_ack_chore_journal.chore_event_date_time = DateTime.utcnow()
            cxl_ack_chore_journal.id = None
            executor_http_client.create_chore_journal_client(cxl_ack_chore_journal)

            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            residual_qty = open_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            last_original_qty = qty
            last_original_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_based_on_px_and_qty_with_cxl_req_after_amend_req_n_cxl_ack_post_amend(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 20
            config_dict["symbol_configs"][symbol]["avoid_cxl_ack_after_cxl_req"] = True
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            last_filled_qty = filled_qty

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                pending_amend_dn_px = 0
                pending_amend_dn_qty = 0
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                pending_amend_up_px = 0
                pending_amend_up_qty = 0
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0
            residual_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # applying cxl req
            executor_http_client.barter_simulator_place_cxl_chore_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.side, latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.security.sec_id, latest_ack_obj.chore.underlying_account)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            chore_status = ChoreStatusType.OE_CXL_UNACK
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # placing CXL ACK
            cxl_ack_chore_journal = copy.deepcopy(latest_ack_obj)
            cxl_ack_chore_journal.chore_event = ChoreEventType.OE_CXL_ACK
            cxl_ack_chore_journal.chore_event_date_time = DateTime.utcnow()
            cxl_ack_chore_journal.id = None
            executor_http_client.create_chore_journal_client(cxl_ack_chore_journal)

            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            residual_qty = open_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            last_original_qty = qty
            last_original_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_non_risky_amend_rej_based_on_px_and_qty(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                pending_amend_up_px = 0
                pending_amend_up_qty = 0
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                pending_amend_dn_px = 0
                pending_amend_dn_qty = 0
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend REJ chore
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            cxled_qty = qty - filled_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_rej_based_on_px_and_qty(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            # Placing Amend req chore and checking computes
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                pending_amend_dn_px = 0
                pending_amend_dn_qty = 0
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                pending_amend_up_px = 0
                pending_amend_up_qty = 0
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)
            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                new_qty = qty
                new_px = px - amend_px
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0

            residual_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend REJ
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            cxled_qty = open_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))
        
        
@pytest.mark.nightly
def test_risky_amend_rej_based_on_px_and_qty_with_overfill_post_rej(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    First buy chore is placed for 90 qty then amend req is placed for 100 qty since amend up is
    risky in buy side amend will be applied, then fulfill comes and then rej comes, removing
    amended up qty and making chore over filled
    """

    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 0
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(100, 90, buy_symbol, Side.BUY)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, buy_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            expected_chore_notional = qty * get_px_in_usd(px)
            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            amend_px = 1
            amend_qty = 10
            pending_amend_up_px = amend_px
            pending_amend_up_qty = amend_qty
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            chore_event = ChoreEventType.OE_AMD_UP_UNACK
            chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            new_qty = qty + amend_qty
            new_px = px + amend_px

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)

            # placing fills before receiving AMD_ACK - makes chore filled
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, new_qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account, use_exact_passed_qty=True)

            filled_qty = new_qty
            cxled_qty = 0
            cxled_px = 0
            cxled_notional = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 10
            chore_status = ChoreStatusType.OE_FILLED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = 0
            open_qty = 0
            open_notional = 0
            open_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = open_notional
            filled_exposure = filled_notional
            cxled_exposure = cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend REJ
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_OVER_FILLED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(filled_px)
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = open_notional
            filled_exposure = filled_notional
            cxled_exposure = 0
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
            assert paused_pair_plan.plan_state == PlanState.PlanState_PAUSED, \
                f"Mismatched: plan state must be PAUSED, found: {paused_pair_plan.plan_state}"

            time.sleep(5)
            check_str = ("Reverted amend changes post receiving OE_AMD_REJ on chore that had status .* "
                         "- putting plan to pause and applying amend rollback")
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_rej_based_on_px_and_qty_making_chore_filled_post_rej(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    First buy chore is placed for 90 qty then amend req is placed for 100 qty since amend up is
    risky in buy side amend will be applied, then 90 fills come and then rej comes, removing
    amended up qty and making chore filled
    """

    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 0
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(100, 90, buy_symbol, Side.BUY)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, buy_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            expected_chore_notional = qty * get_px_in_usd(px)
            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            amend_px = 1
            amend_qty = 10
            pending_amend_up_px = amend_px
            pending_amend_up_qty = amend_qty
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            chore_event = ChoreEventType.OE_AMD_UP_UNACK
            chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            new_qty = qty + amend_qty
            new_px = px + amend_px

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)

            # placing fills before receiving AMD_ACK
            filled_qty = qty
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, filled_qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account, use_exact_passed_qty=True)

            cxled_qty = 0
            cxled_px = 0
            cxled_notional = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = amend_qty
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = open_notional
            filled_exposure = filled_notional
            cxled_exposure = cxled_notional
            residual_qty = 0
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend REJ
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_FILLED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(filled_px)
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = open_notional
            filled_exposure = filled_notional
            cxled_exposure = 0
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            time.sleep(5)
            check_str = ("Reverted amend changes post receiving OE_AMD_REJ on chore that had status "
                         "ChoreStatusType.OE_AMD_UP_UNACKED before amend applied - "
                         "status post amd_rej applied: ChoreStatusType.OE_FILLED")
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_rej_based_on_px_and_qty_with_overfill_post_amd_req_n_ack_post_amd_rej(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    First sell chore is placed for 110 qty then amend req is placed for 100 qty since amend dn is
    risky in sell side, amend will be applied, then overfill comes with 105 qty and
    then rej comes, removing amended up qty and making chore acked again
    """
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list, leg1_side=Side.SELL, leg2_side=Side.BUY)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 0
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(95, 110, leg1_symbol, Side.SELL)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, sell_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            
            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            # Placing Amend req chore and checking computes
            amend_px = 1
            amend_qty = 10
            chore_event = ChoreEventType.OE_AMD_DN_UNACK
            pending_amend_dn_px = amend_px
            pending_amend_dn_qty = amend_qty
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            new_qty = qty
            new_px = px - amend_px
            
            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            # placing fills before receiving AMD_ACK - makes chore filled
            filled_qty = (qty - amend_qty) + 5
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, filled_qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account, use_exact_passed_qty=True)

            cxled_qty = amend_qty
            cxled_px = px
            cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
            total_amend_dn_qty = amend_qty
            total_amend_up_qty = 0
            chore_status = ChoreStatusType.OE_OVER_FILLED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = 0
            open_qty = 0
            open_notional = 0
            open_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
            assert paused_pair_plan.plan_state == PlanState.PlanState_PAUSED, \
                f"Mismatched: plan state must be PAUSED, found: {paused_pair_plan.plan_state}"

            time.sleep(5)
            check_str = "Unexpected: Received fill that will make chore_snapshot OVER_FILLED"
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            # Placing Amend REJ
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
            assert paused_pair_plan.plan_state == PlanState.PlanState_ACTIVE, \
                f"Mismatched: plan state must be ACTIVE, found: {paused_pair_plan.plan_state}"

            time.sleep(5)
            check_str = ("Reverted amend changes post receiving OE_AMD_REJ on chore that had status .* "
                         "- UNPAUSING plan and applying amend rollback")
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = qty - filled_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_rej_based_on_px_and_qty_with_overfill_post_amd_req_n_filled_post_amd_rej(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    First sell chore is placed for 110 qty then amend req is placed for 100 qty since amend dn is
    risky in sell side, amend will be applied, then overfill comes with 110 qty and
    then rej comes, removing amended up qty and checking chore state must be FILLED
    """
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list, leg1_side=Side.SELL, leg2_side=Side.BUY)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 0
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(95, 110, leg1_symbol, Side.SELL)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, sell_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            # Placing Amend req chore and checking computes
            amend_px = 1
            amend_qty = 10
            chore_event = ChoreEventType.OE_AMD_DN_UNACK
            pending_amend_dn_px = amend_px
            pending_amend_dn_qty = amend_qty
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            new_qty = qty
            new_px = px - amend_px

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            # placing fills before receiving AMD_ACK - makes chore filled
            filled_qty = qty
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, filled_qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account, use_exact_passed_qty=True)

            cxled_qty = amend_qty
            cxled_px = px
            cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
            total_amend_dn_qty = amend_qty
            total_amend_up_qty = 0
            chore_status = ChoreStatusType.OE_OVER_FILLED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = 0
            open_qty = 0
            open_notional = 0
            open_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
            assert paused_pair_plan.plan_state == PlanState.PlanState_PAUSED, \
                f"Mismatched: plan state must be PAUSED, found: {paused_pair_plan.plan_state}"

            time.sleep(5)
            check_str = "Unexpected: Received fill that will make chore_snapshot OVER_FILLED"
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            # Placing Amend REJ
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_FILLED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
            assert paused_pair_plan.plan_state == PlanState.PlanState_ACTIVE, \
                f"Mismatched: plan state must be ACTIVE, found: {paused_pair_plan.plan_state}"

            time.sleep(5)
            check_str = ("Reverted amend changes post receiving OE_AMD_REJ on chore that had status .* "
                         "- UNPAUSING plan and applying amend rollback")
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_rej_based_on_px_and_qty_with_filled_post_amd_req_n_acked_post_amd_rej(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    First sell chore is placed for 110 qty then amend req is placed for 100 qty since amend dn is
    risky in sell side, amend will be applied, then fill comes with 100 qty and
    then rej comes, removing amended up qty and checking chore state must be ACK
    """
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list, leg1_side=Side.SELL, leg2_side=Side.BUY)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 0
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(95, 110, leg1_symbol, Side.SELL)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, sell_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            # Placing Amend req chore and checking computes
            amend_px = 1
            amend_qty = 10
            chore_event = ChoreEventType.OE_AMD_DN_UNACK
            pending_amend_dn_px = amend_px
            pending_amend_dn_qty = amend_qty
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            new_qty = qty
            new_px = px - amend_px

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            # placing fills before receiving AMD_ACK - makes chore filled
            filled_qty = qty - amend_qty
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, filled_qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account, use_exact_passed_qty=True)

            cxled_qty = amend_qty
            cxled_px = px
            cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
            total_amend_dn_qty = amend_qty
            total_amend_up_qty = 0
            chore_status = ChoreStatusType.OE_FILLED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = 0
            open_qty = 0
            open_notional = 0
            open_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend REJ
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            time.sleep(5)
            check_str = ("Reverted amend changes post receiving OE_AMD_REJ on chore that had status "
                         "ChoreStatusType.OE_FILLED before amend applied - status post amd_rej applied: "
                         "ChoreStatusType.OE_ACKED")
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_DOD
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = qty - filled_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_non_risky_amend_rej_based_on_px_and_qty_with_cxl_unack_pre_amd_rej(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["avoid_cxl_ack_after_cxl_req"] = True
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_filled_notional = None
        buy_cxl_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:

            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            if side == Side.BUY:
                buy_filled_qty = filled_qty

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                pending_amend_up_px = 0
                pending_amend_up_qty = 0
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                pending_amend_dn_px = 0
                pending_amend_dn_qty = 0
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # applying cxl req
            executor_http_client.barter_simulator_place_cxl_chore_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.side, latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.security.sec_id, latest_ack_obj.chore.underlying_account)

            chore_status = ChoreStatusType.OE_CXL_UNACK
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend REJ chore
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            chore_status = ChoreStatusType.OE_CXL_UNACK
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # placing CXL ACK
            cxl_ack_chore_journal = copy.deepcopy(latest_ack_obj)
            cxl_ack_chore_journal.chore_event = ChoreEventType.OE_CXL_ACK
            cxl_ack_chore_journal.chore_event_date_time = DateTime.utcnow()
            cxl_ack_chore_journal.id = None
            executor_http_client.create_chore_journal_client(cxl_ack_chore_journal)

            cxled_qty = open_qty
            cxled_notional = open_notional
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_residual_qty = residual_qty
                buy_filled_notional = filled_notional
                buy_cxl_notional = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_amend_rej_based_on_px_and_qty_with_cxl_unack_pre_amd_rej(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["avoid_cxl_ack_after_cxl_req"] = True
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            # Placing Amend req chore and checking computes
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                pending_amend_dn_px = 0
                pending_amend_dn_qty = 0
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                pending_amend_up_px = 0
                pending_amend_up_qty = 0
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)
            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                new_qty = qty
                new_px = px - amend_px
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0

            residual_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # applying cxl req
            executor_http_client.barter_simulator_place_cxl_chore_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.side, latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.security.sec_id, latest_ack_obj.chore.underlying_account)

            chore_status = ChoreStatusType.OE_CXL_UNACK
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend REJ
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_CXL_UNACK
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # placing CXL ACK
            cxl_ack_chore_journal = copy.deepcopy(latest_ack_obj)
            cxl_ack_chore_journal.chore_event = ChoreEventType.OE_CXL_ACK
            cxl_ack_chore_journal.chore_event_date_time = DateTime.utcnow()
            cxl_ack_chore_journal.id = None
            executor_http_client.create_chore_journal_client(cxl_ack_chore_journal)
            
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_DOD
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = qty - filled_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_non_risky_amend_rej_based_on_px_and_qty_cxl_ack_pre_amd_rej(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_filled_notional = None
        buy_cxl_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:

            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                pending_amend_up_px = 0
                pending_amend_up_qty = 0
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                pending_amend_dn_px = 0
                pending_amend_dn_qty = 0
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # applying cxl req and cxl ack
            executor_http_client.barter_simulator_place_cxl_chore_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.side, latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.security.sec_id, latest_ack_obj.chore.underlying_account)

            cxled_qty = open_qty
            cxled_notional = open_notional
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend REJ chore
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            time.sleep(5)
            check_str = (f"Received AMD_REJ post chore DOD on chore_id: "
                         f".* - ignoring this amend chore_journal and chore will stay unchanged")
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))
        
        
@pytest.mark.nightly
def test_risky_amend_rej_based_on_px_and_qty_cxl_ack_pre_amd_rej(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            # Placing Amend req chore and checking computes
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                pending_amend_dn_px = 0
                pending_amend_dn_qty = 0
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                pending_amend_up_px = 0
                pending_amend_up_qty = 0
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)
            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                new_qty = qty
                new_px = px - amend_px
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0

            residual_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # applying cxl req and cxl ack
            executor_http_client.barter_simulator_place_cxl_chore_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.side, latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.security.sec_id, latest_ack_obj.chore.underlying_account)

            if side == Side.BUY:
                cxled_qty = open_qty
                cxled_notional = open_notional
            else:
                cxled_qty += open_qty
                cxled_notional += open_notional
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend REJ chore
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            time.sleep(5)
            check_str = (f"Received AMD_REJ post chore DOD on chore_id: "
                         f".* - ignoring this amend chore_journal and chore will stay unchanged")
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_non_risky_multi_amend_based_on_qty_and_px(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):

    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            for i in range(3):
                print(f"{i+1}th amend for side {side}")

                # Placing Amend req chore and checking computes should stay same since it is non-risky amend
                if side == Side.BUY:
                    amend_px = 1
                    amend_qty = 10
                    chore_event = ChoreEventType.OE_AMD_DN_UNACK
                    chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
                    pending_amend_dn_px = amend_px
                    pending_amend_dn_qty = amend_qty
                else:
                    amend_px = 1
                    amend_qty = 10
                    chore_event = ChoreEventType.OE_AMD_UP_UNACK
                    chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
                    pending_amend_up_px = amend_px
                    pending_amend_up_qty = amend_qty

                executor_http_client.barter_simulator_process_amend_req_query_client(
                    latest_ack_obj.chore.chore_id,
                    latest_ack_obj.chore.side,
                    latest_ack_obj.chore.security.sec_id,
                    latest_ack_obj.chore.underlying_account,
                    chore_event=chore_event,
                    qty=amend_qty, px=amend_px)

                latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                        chore_symbol,
                                                                                        executor_http_client)
                filled_notional = filled_qty * get_px_in_usd(px)
                filled_px = px
                open_qty = new_qty - filled_qty - cxled_qty
                open_px = new_px
                open_notional = open_qty * get_px_in_usd(open_px)
                if side == Side.BUY:
                    other_side_residual_qty = 0
                    other_side_fill_notional = 0
                    open_exposure = open_notional
                    filled_exposure = filled_notional
                    cxled_exposure = cxled_notional
                else:
                    other_side_residual_qty = buy_residual_qty
                    buy_symbol_side_snapshot_list = (
                        executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                            buy_symbol, Side.BUY))
                    other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                    open_exposure = - open_notional
                    filled_exposure = buy_filled_notional - filled_notional
                    cxled_exposure = buy_cxl_notional - cxled_notional
                try:
                    check_all_computes_for_amend(
                        active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                        new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                        pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                        filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                        other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                        cxled_exposure,
                        residual_qty=residual_qty)
                except AssertionError as ass_e:
                    print("ASSERT", ass_e)
                    raise AssertionError(ass_e)
                except Exception as e:
                    print("Exception", e)
                    raise Exception(e)

                # Placing Amend ACK chore and checking amend should be applied on ack
                executor_http_client.barter_simulator_process_amend_ack_query_client(
                    latest_ack_obj.chore.chore_id,
                    latest_ack_obj.chore.side,
                    latest_ack_obj.chore.security.sec_id,
                    latest_ack_obj.chore.underlying_account)

                latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                      chore_symbol,
                                                                                      executor_http_client)
                if side == Side.BUY:
                    cxled_qty += amend_qty
                    cxled_notional += amend_qty * get_px_in_usd(new_px)
                    cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
                    total_amend_dn_qty += amend_qty
                    total_amend_up_qty = 0
                    new_qty = qty
                    new_px -= amend_px
                else:
                    new_qty += amend_qty
                    new_px += amend_px
                    cxled_qty = 0
                    cxled_px = 0
                    cxled_notional = 0
                    total_amend_dn_qty = 0
                    total_amend_up_qty += amend_qty

                chore_status = ChoreStatusType.OE_ACKED
                filled_notional = filled_qty * get_px_in_usd(px)
                filled_px = px
                open_qty = new_qty - filled_qty - cxled_qty
                open_px = new_px
                open_notional = open_qty * get_px_in_usd(open_px)
                if side == Side.BUY:
                    other_side_residual_qty = 0
                    other_side_fill_notional = 0
                    open_exposure = open_notional
                    filled_exposure = filled_notional
                    cxled_exposure = cxled_notional
                else:
                    other_side_residual_qty = buy_residual_qty
                    buy_symbol_side_snapshot_list = (
                        executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                            buy_symbol, Side.BUY))
                    other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                    open_exposure = - open_notional
                    filled_exposure = buy_filled_notional - filled_notional
                    cxled_exposure = buy_cxl_notional - cxled_notional
                try:
                    check_all_computes_for_amend(
                        active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                        new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                        pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                        filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                        other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                        cxled_exposure,
                        residual_qty=residual_qty)
                except AssertionError as ass_e:
                    print("ASSERT", ass_e)
                    raise AssertionError(ass_e)
                except Exception as e:
                    print("Exception", e)
                    raise Exception(e)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)

            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_risky_multi_amend_based_on_px_and_qty(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            for i in range(3):
                print(f"{i+1}th amend for side {side}")

                # Placing Amend req chore and checking computes should stay same since it is non-risky amend
                if side == Side.BUY:
                    amend_px = 1
                    amend_qty = 10
                    chore_event = ChoreEventType.OE_AMD_UP_UNACK
                    chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
                else:
                    amend_px = 1
                    amend_qty = 10
                    chore_event = ChoreEventType.OE_AMD_DN_UNACK
                    chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

                executor_http_client.barter_simulator_process_amend_req_query_client(
                    latest_ack_obj.chore.chore_id,
                    latest_ack_obj.chore.side,
                    latest_ack_obj.chore.security.sec_id,
                    latest_ack_obj.chore.underlying_account,
                    chore_event=chore_event,
                    qty=amend_qty, px=amend_px)

                latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                        chore_symbol,
                                                                                        executor_http_client)

                if side == Side.BUY:
                    new_qty += amend_qty
                    new_px += amend_px
                    cxled_qty = 0
                    cxled_px = 0
                    cxled_notional = 0
                    total_amend_dn_qty = 0
                    total_amend_up_qty += amend_qty
                    pending_amend_up_px = amend_px
                    pending_amend_up_qty = amend_qty
                else:
                    cxled_qty += amend_qty
                    cxled_notional += amend_qty * get_px_in_usd(new_px)
                    cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
                    new_qty = qty
                    new_px -= amend_px
                    total_amend_dn_qty += amend_qty
                    total_amend_up_qty = 0
                    pending_amend_dn_px = amend_px
                    pending_amend_dn_qty = amend_qty

                filled_notional = filled_qty * get_px_in_usd(px)
                filled_px = px
                open_qty = new_qty - filled_qty - cxled_qty
                open_notional = open_qty * get_px_in_usd(new_px)
                open_px = new_px
                if side == Side.BUY:
                    other_side_residual_qty = 0
                    other_side_fill_notional = 0
                    open_exposure = open_notional
                    filled_exposure = filled_notional
                    cxled_exposure = cxled_notional
                else:
                    other_side_residual_qty = buy_residual_qty
                    buy_symbol_side_snapshot_list = (
                        executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                            buy_symbol, Side.BUY))
                    other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                    open_exposure = - open_notional
                    filled_exposure = buy_filled_notional - filled_notional
                    cxled_exposure = buy_cxl_notional - cxled_notional
                try:
                    check_all_computes_for_amend(
                        active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                        new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                        pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                        filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                        other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                        cxled_exposure,
                        residual_qty=residual_qty)
                except AssertionError as ass_e:
                    print("ASSERT", ass_e)
                    raise AssertionError(ass_e)
                except Exception as e:
                    print("Exception", e)
                    raise Exception(e)

                # Placing Amend ACK chore and checking amend should be applied on ack
                executor_http_client.barter_simulator_process_amend_ack_query_client(
                    latest_ack_obj.chore.chore_id,
                    latest_ack_obj.chore.side,
                    latest_ack_obj.chore.security.sec_id,
                    latest_ack_obj.chore.underlying_account)

                latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                      chore_symbol,
                                                                                      executor_http_client)
                chore_status = ChoreStatusType.OE_ACKED
                pending_amend_dn_px = 0
                pending_amend_dn_qty = 0
                pending_amend_up_px = 0
                pending_amend_up_qty = 0
                try:
                    check_all_computes_for_amend(
                        active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                        new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                        pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                        filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                        other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                        cxled_exposure,
                        residual_qty=residual_qty)
                except AssertionError as ass_e:
                    print("ASSERT", ass_e)
                    raise AssertionError(ass_e)
                except Exception as e:
                    print("Exception", e)
                    raise Exception(e)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_residual_qty = residual_qty
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_multi_amends_based_on_qty_n_then_px(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    Does multi-amend test - first amends non-risky qty to +-10 based on side, then risky qty to +-10, 
    then non-risky +-1 based on px and at last risky +-1 based on px
    """
    
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_cxled_notional = None
        buy_residual_qty = None
        buy_fill_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:

            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            # First Handling Non-Risky amend Case for qty
            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                amend_qty = 10
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
                pending_amend_dn_qty = amend_qty
            else:
                amend_qty = 10
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
                pending_amend_up_qty = amend_qty

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            residual_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_notional
                cxled_exposure = 0
                buy_fill_notional = filled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = buy_fill_notional - filled_qty * get_px_in_usd(px)
                cxled_exposure = buy_cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol, executor_http_client)
            if side == Side.BUY:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0
            else:
                new_qty = qty + amend_qty
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty

            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Next, Handling Risky amend Case for qty
            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            # qty = new_qty
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
                pending_amend_up_qty = amend_qty
            else:
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
                pending_amend_dn_qty = amend_qty

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)
            last_qty = new_qty
            if side == Side.BUY:
                new_qty = new_qty + amend_qty
                total_amend_dn_qty = 10
                total_amend_up_qty = 10
            else:
                new_qty = new_qty
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = 10
                total_amend_up_qty = 10

            new_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0

            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Next, Handling Non-Risky amend Case for px
            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                amend_px = 1
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
                pending_amend_dn_px = amend_px
            else:
                amend_px = 1
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
                pending_amend_up_px = amend_px

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)
            new_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(open_px)
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = buy_fill_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                new_px = px - amend_px
            else:
                new_px = px + amend_px
            chore_status = ChoreStatusType.OE_ACKED
            open_qty = new_qty - filled_qty - cxled_qty
            open_px = new_px
            open_notional = open_qty * get_px_in_usd(open_px)
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = buy_fill_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Next, Handling Risky amend Case for px
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
                pending_amend_up_px = amend_px
            else:
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
                pending_amend_dn_px = amend_px
                
            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)
            if side == Side.BUY:
                new_px += amend_px
            else:
                new_px -= amend_px
            open_qty = new_qty - filled_qty - cxled_qty
            open_px = new_px
            open_notional = open_qty * get_px_in_usd(open_px)
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = buy_fill_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = buy_fill_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            cxled_notional += open_qty * get_px_in_usd(new_px)
            cxled_qty += open_qty
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional / cxled_qty)
            residual_qty = open_qty
            chore_status = ChoreStatusType.OE_DOD
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = buy_fill_notional
                cxled_exposure = cxled_notional
                buy_cxled_notional = cxled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_multi_amends_based_on_qty_n_px1(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    Does multi-amend test - first does non-risky amends on qty and px and then does risky amend
    """

    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_cxled_notional = None
        buy_residual_qty = None
        buy_fill_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:

            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            # First Handling Non-Risky amend Case for qty
            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
            else:
                amend_px = 1
                amend_qty = 10
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = 0
            if side == Side.BUY:
                buy_fill_notional = filled_notional
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = (qty - filled_qty) * get_px_in_usd(px)
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = 10
                total_amend_up_qty = 0
            else:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = 10

            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Next, Handling Risky amend Case for qty
            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            # qty = new_qty
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
            else:
                amend_px = 1
                amend_qty = 10
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            if side == Side.BUY:
                new_qty += amend_qty
                new_px += amend_px
                total_amend_dn_qty = 10
                total_amend_up_qty = 10
            else:
                cxled_qty = amend_qty
                cxled_px = new_px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_px -= amend_px
                total_amend_dn_qty = 10
                total_amend_up_qty = 10

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)

            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            cxled_notional += open_qty * get_px_in_usd(new_px)
            cxled_qty += open_qty
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional / cxled_qty)
            residual_qty = open_qty
            chore_status = ChoreStatusType.OE_DOD
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = buy_fill_notional
                cxled_exposure = cxled_notional
                buy_cxled_notional = cxled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_multi_amends_based_on_qty_n_px2(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    Does multi-amend test - first does risky amends on qty and px and then does non-risky amend
    """

    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_cxled_notional = None
        buy_residual_qty = None
        buy_fill_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:

            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            # First Handling Risky amend Case for qty
            # Placing Amend req chore and checking computes
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
            else:
                amend_px = 1
                amend_qty = 10
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                total_amend_dn_qty = 0
                total_amend_up_qty = 10
                cxled_qty = 0
                cxled_px = 0
            else:
                cxled_qty = amend_qty
                cxled_px = px
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = 10
                total_amend_up_qty = 0

            residual_qty = 0
            cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)

            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Next, Handling Non-Risky amend Case for qty
            # Placing Amend req chore and checking computes
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
            else:
                amend_px = 1
                amend_qty = 10
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol,
                                                                                    executor_http_client)
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty = 0
            if side == Side.BUY:
                buy_fill_notional = filled_notional
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                cxled_qty = amend_qty
                cxled_px = new_px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_px -= amend_px
                total_amend_dn_qty = 10
                total_amend_up_qty = 10
            else:
                new_qty += amend_qty
                new_px += amend_px
                total_amend_dn_qty = 10
                total_amend_up_qty = 10

            chore_status = ChoreStatusType.OE_ACKED
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            cxled_notional += open_qty * get_px_in_usd(new_px)
            cxled_qty += open_qty
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional / cxled_qty)
            residual_qty = open_qty
            chore_status = ChoreStatusType.OE_DOD
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = buy_fill_notional
                cxled_exposure = cxled_notional
                buy_cxled_notional = cxled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_fill_notional - filled_notional
                cxled_exposure = buy_cxled_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


# todo - currently not working since partial_amend is rolled-back
# @pytest.mark.nightly
def test_partial_non_risky_amend(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):

    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend ACK chore and checking amend should be applied on ack
            partial_amd_qty = 6
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                amend_qty=partial_amd_qty)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                cxled_qty = amend_qty
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = partial_amd_qty
                total_amend_up_qty = 0
            else:
                new_qty = qty + partial_amd_qty
                new_px = px + amend_px
                cxled_qty = amend_qty - partial_amd_qty
                total_amend_dn_qty = 0
                total_amend_up_qty = partial_amd_qty

            residual_qty = amend_qty - partial_amd_qty
            cxled_px = px
            cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
            chore_status = ChoreStatusType.OE_ACKED
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty += open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

    except AssertionError as e:
        print(e)
        raise AssertionError(e)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


# todo - currently not working since partial_amend is rolled-back
# @pytest.mark.nightly
def test_partial_risky_amend(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_qty = amend_qty
                pending_amend_up_px = amend_px
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_qty = amend_qty
                pending_amend_dn_px = amend_px
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = 10
            else:
                new_qty = qty
                new_px = px - amend_px
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = 10
                total_amend_up_qty = 0

            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # Placing Amend ACK chore and checking amend should be applied on ack
            amend_ack_qty = 6
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                amend_qty=amend_ack_qty)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)

            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            residual_qty = open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_filled_notional = filled_notional
                buy_cxl_notional = cxled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            check_all_computes_for_amend(
                active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                residual_qty=residual_qty)

    except AssertionError as e:
        print(e)
        raise e
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


def check_all_computes_for_lapse(
        active_pair_plan, symbol, side, chore_id, executor_http_client,
        chore_qty, chore_px, chore_status, open_qty, open_notional, open_px, filled_qty,
        filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px, other_side_residual_qty,
        other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure, last_lapsed_qty, total_lapsed_qty,
        residual_qty: int = 0, is_sell_buy_plan: bool = False):
    chore_snapshot = get_chore_snapshot_from_chore_id(chore_id,
                                                      executor_http_client)
    assert chore_snapshot.chore_status == chore_status, \
        f"Mismatched: Chore status must be {chore_status} but found: {chore_snapshot.chore_status=}"
    assert chore_snapshot.chore_brief.qty == chore_qty, \
        f"Mismatched: expected chore_snapshot qty: {chore_qty} found: {chore_snapshot.chore_brief.qty=}"
    assert chore_snapshot.chore_brief.px == chore_px, \
        f"Mismatched: expected chore_snapshot px: {chore_px} found: {chore_snapshot.chore_brief.px=}"
    expected_chore_notional = chore_px * get_px_in_usd(chore_qty)
    assert chore_snapshot.chore_brief.chore_notional == expected_chore_notional, \
        (f"Mismatched: expected chore_snapshot expected_chore_notional: {expected_chore_notional} "
         f"found: {chore_snapshot.chore_brief.chore_notional=}")
    assert chore_snapshot.cxled_qty == cxled_qty, \
        f"Mismatched: ChoreSnapshot cxled_qty must be {cxled_qty}, found {chore_snapshot.cxled_qty}"
    assert chore_snapshot.cxled_notional == cxled_notional, \
        (f"Mismatched: ChoreSnapshot cxled_notional must be {cxled_notional}, "
         f"found {chore_snapshot.cxled_notional}")
    assert chore_snapshot.avg_cxled_px == cxled_px, \
        (f"Mismatched: ChoreSnapshot avg_cxled_px must be "
         f"{cxled_px}, found {chore_snapshot.avg_cxled_px}")
    assert chore_snapshot.filled_qty == filled_qty, \
        f"Mismatched: ChoreSnapshot filled_qty must be {filled_qty}, found {chore_snapshot.filled_qty}"
    assert chore_snapshot.fill_notional == filled_notional, \
        (f"Mismatched: ChoreSnapshot fill_notional must be {filled_notional}, "
         f"found {chore_snapshot.fill_notional}")
    assert chore_snapshot.avg_fill_px == filled_px, \
        f"Mismatched: ChoreSnapshot avg_fill_px must be {filled_px}, found {chore_snapshot.avg_fill_px}"
    assert chore_snapshot.last_lapsed_qty == last_lapsed_qty, \
        f"Mismatched: ChoreSnapshot last_lapsed_qty must be {cxled_qty}, found {chore_snapshot.last_lapsed_qty}"
    assert chore_snapshot.total_lapsed_qty == total_lapsed_qty, \
        (f"Mismatched: ChoreSnapshot total_lapsed_qty must be {cxled_qty}, "
         f"found {chore_snapshot.total_lapsed_qty}")

    _check_all_computes_in_models_other_than_chore_snapshot(
        active_pair_plan, symbol, side, executor_http_client, chore_snapshot,
        chore_qty, chore_px, chore_status, open_qty, open_notional, open_px, filled_qty,
        filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px, other_side_residual_qty,
        other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
        residual_qty, is_sell_buy_plan)


@pytest.mark.nightly
def test_lapse_partial_qty_in_chore(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_symbol_side_snapshot = None
        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:

            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_filled_notional = filled_notional

            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            lapse_qty = 20
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_LAPSE,
                                                                                    chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty - lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure, 
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            cxled_qty = lapse_qty + open_qty
            residual_qty = lapse_qty + open_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_cxl_notional = cxled_notional
            cxled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = buy_cxl_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise e
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_complete_qty_in_chore_with_none_qty(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_symbol_side_snapshot = None
        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:

            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_filled_notional = filled_notional

            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=None)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_LAPSE,
                                                                                    chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            cxled_qty = open_qty
            residual_qty = open_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_cxl_notional = cxled_notional
            cxled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = buy_cxl_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise e
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_complete_qty_in_chore_with_providing_qty(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_symbol_side_snapshot = None
        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:

            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_filled_notional = filled_notional

            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            lapsed_qty = open_qty
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapsed_qty)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_LAPSE,
                                                                                    chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            cxled_qty = lapsed_qty
            residual_qty = lapsed_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_cxl_notional = cxled_notional
            cxled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            lapsed_qty = lapsed_qty
            total_lapsed_qty = lapsed_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = buy_cxl_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise e
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


def _handle_test_for_more_than_expected_lapse_qty(
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, leg1_leg2_symbol_list,
        refresh_sec_update_fixture, check_greater_than_chore_qty: bool, check_alert_str: str):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_symbol_side_snapshot = None
        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:

            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_filled_notional = filled_notional

            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            if check_greater_than_chore_qty:
                lapse_qty = qty + 10
            else:
                lapse_qty = open_qty + 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_LAPSE,
                                                                                    chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            cxled_qty = open_qty
            residual_qty = open_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_cxl_notional = cxled_notional
            cxled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = buy_cxl_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            time.sleep(5)
            # Checking alert for rejected chore_journal
            assert_fail_msg = f"Couldn't find any alert saying: {check_alert_str}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_alert_str, assert_fail_msg)

    except AssertionError as e:
        raise e
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_qty_more_than_unfilled_qty(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):

    check_str = "Unexpected: Lapse qty can't be greater than unfilled qty - putting plan to DOD state"
    _handle_test_for_more_than_expected_lapse_qty(pair_plan_, expected_plan_limits_, expected_plan_status_,
                                                  last_barter_fixture_list, symbol_overview_obj_list,
                                                  market_depth_basemodel_list, leg1_leg2_symbol_list,
                                                  refresh_sec_update_fixture,
                                                  check_greater_than_chore_qty=False, check_alert_str=check_str)


@pytest.mark.nightly
def test_lapse_check_reject_when_lapse_qty_gt_chore_qty(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    check_str = "Unexpected: Lapse qty can't be greater than chore_qty - putting plan to DOD state"
    _handle_test_for_more_than_expected_lapse_qty(pair_plan_, expected_plan_limits_, expected_plan_status_,
                                                  last_barter_fixture_list, symbol_overview_obj_list,
                                                  market_depth_basemodel_list, leg1_leg2_symbol_list,
                                                  refresh_sec_update_fixture,
                                                  check_greater_than_chore_qty=True, check_alert_str=check_str)


@pytest.mark.nightly
def test_lapse_post_cxl_req_pre_cxl_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["avoid_cxl_ack_after_cxl_req"] = True
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_symbol_side_snapshot = None
        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_filled_notional = filled_notional

            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            # applying cxl req
            executor_http_client.barter_simulator_place_cxl_chore_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.side, latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.security.sec_id, latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL,
                                                                                  chore_symbol, executor_http_client)
            
            # putting lapse before cxl_ack
            chore_status = ChoreStatusType.OE_CXL_UNACK
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty - lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # placing CXL ACK
            cxl_ack_chore_journal = copy.deepcopy(latest_ack_obj)
            cxl_ack_chore_journal.chore_event = ChoreEventType.OE_CXL_ACK
            cxl_ack_chore_journal.chore_event_date_time = DateTime.utcnow()
            cxl_ack_chore_journal.id = None
            executor_http_client.create_chore_journal_client(cxl_ack_chore_journal)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            cxled_qty = lapse_qty + open_qty
            residual_qty = lapse_qty + open_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_cxl_notional = cxled_notional
            cxled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = buy_cxl_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise e
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_in_btw_multi_fills(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 20
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_symbol_side_snapshot = None
        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)

            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            lapse_qty = 20
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_LAPSE,
                                                                                    chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty - lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # placing fills after LAPSE
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, latest_ack_obj.chore.qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account)
            last_fill_qty = filled_qty
            open_qty -= filled_qty
            filled_qty = filled_qty * 2

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_filled_notional = filled_notional
            filled_px = px
            cxled_qty = lapse_qty + open_qty
            residual_qty = lapse_qty + open_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_cxl_notional = cxled_notional
            cxled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = buy_cxl_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, last_fill_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_pre_fill_making_chore_filled(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 20
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_symbol_side_snapshot = None
        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)

            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            lapse_qty = 20
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_LAPSE,
                                                                                    chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty - lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # placing fills after LAPSE
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, open_qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account, use_exact_passed_qty=True)
            last_fill_qty = open_qty
            filled_qty = filled_qty + open_qty
            open_qty = 0

            chore_status = ChoreStatusType.OE_FILLED
            filled_notional = filled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_filled_notional = filled_notional
            filled_px = px
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_cxl_notional = cxled_notional
            cxled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = buy_cxl_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, last_fill_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_pre_fill_making_chore_over_filled(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 20
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_symbol_side_snapshot = None
        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)

            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            lapse_qty = 20
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_LAPSE,
                                                                                    chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty - lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # placing fills after LAPSE
            fill_qty = open_qty + 10
            executor_http_client.barter_simulator_process_fill_query_client(
                latest_ack_obj.chore.chore_id, latest_ack_obj.chore.px, fill_qty, side, chore_symbol,
                latest_ack_obj.chore.underlying_account, use_exact_passed_qty=True)
            last_fill_qty = fill_qty
            filled_qty = filled_qty + fill_qty
            open_qty = 0

            chore_status = ChoreStatusType.OE_OVER_FILLED
            filled_notional = filled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_filled_notional = filled_notional
            filled_px = px
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_cxl_notional = cxled_notional
            cxled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = buy_cxl_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, last_fill_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
            assert paused_pair_plan.plan_state == PlanState.PlanState_PAUSED, \
                f"Mismatched: plan state must be PAUSED, found: {paused_pair_plan.plan_state}"

            time.sleep(5)
            check_str = "Unexpected: Received fill that will make chore_snapshot OVER_FILLED"
            assert_fail_msg = f"Couldn't find any alert saying: {check_str}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

            if side == Side.BUY:
                # forcefully turning plan to active again for checking sell chore
                pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
                pair_plan.plan_state = PlanState.PlanState_ACTIVE
                email_book_service_native_web_client.put_pair_plan_client(pair_plan)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_multi_partial_lapse_till_chore_dod(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 20
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            chore_status = ChoreStatusType.OE_ACKED
            filled_notional = filled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_filled_notional = filled_notional

            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # putting 20% qty to lapse in each loop - 4 loops = 72 (18 is already filled by this point)
            lapse_qty = filled_qty
            for i in range(4):
                executor_http_client.barter_simulator_process_lapse_query_client(
                    latest_ack_obj.chore.chore_id,
                    latest_ack_obj.chore.side,
                    latest_ack_obj.chore.security.sec_id,
                    latest_ack_obj.chore.underlying_account,
                    qty=lapse_qty)
                total_lapsed_qty += lapse_qty

                latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_LAPSE,
                                                                                        chore_symbol, executor_http_client)
                if i == 3:
                    chore_status = ChoreStatusType.OE_DOD
                    open_qty = 0
                    open_notional = 0
                    open_px = 0
                else:
                    chore_status = ChoreStatusType.OE_ACKED
                    open_qty = qty - filled_qty - total_lapsed_qty
                    open_notional = open_qty * get_px_in_usd(px)
                    open_px = px
                filled_notional = filled_qty * get_px_in_usd(px)
                filled_px = px
                cxled_qty = total_lapsed_qty
                residual_qty = total_lapsed_qty
                cxled_notional = cxled_qty * get_px_in_usd(px)
                if side == Side.BUY:
                    buy_cxl_notional = cxled_notional
                    buy_residual_qty = residual_qty
                cxled_px = px
                lapsed_qty = lapse_qty
                if side == Side.BUY:
                    other_side_residual_qty = 0
                    other_side_fill_notional = 0
                    open_exposure = open_notional
                    filled_exposure = filled_notional
                    cxled_exposure = cxled_notional
                else:
                    other_side_residual_qty = buy_residual_qty
                    buy_symbol_side_snapshot_list = (
                        executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                            buy_symbol, Side.BUY))
                    other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                    open_exposure = - open_notional
                    filled_exposure = buy_filled_notional - filled_notional
                    cxled_exposure = buy_cxl_notional - cxled_notional
                last_filled_qty = filled_qty
                try:
                    check_all_computes_for_lapse(
                        active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                        qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                        filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                        other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                        lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
                except AssertionError as ass_e:
                    print("ASSERT", ass_e)
                    raise ass_e
                except Exception as e:
                    print("Exception", e)
                    raise e

    except AssertionError as e:
        raise e
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_pre_non_risky_amend_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            # putting lapse before cxl_ack
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            print("Checking chore post OE_AMD_ACK")
            if side == Side.BUY:
                cxled_qty += amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0
            else:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            chore_status = ChoreStatusType.OE_ACKED
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(new_px)
            residual_qty = open_qty + lapsed_qty
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
                buy_cxl_notional = cxled_notional
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))
        
        
@pytest.mark.nightly
def test_full_lapse_pre_non_risky_amend_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 90, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # putting lapse qty before amend ack comes
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=None)
            lapse_qty = open_qty

            # putting lapse before cxl_ack
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = 10
                total_amend_up_qty = 0
                chore_status = ChoreStatusType.OE_OVER_CXLED
            else:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                total_amend_dn_qty = 0
                total_amend_up_qty = 10
                chore_status = ChoreStatusType.OE_DOD
            cxled_qty += amend_qty
            cxled_notional += amend_qty * get_px_in_usd(px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                residual_qty = new_qty - filled_qty
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                residual_qty = new_qty - filled_qty - amend_qty
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            if side == Side.BUY:
                paused_pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
                assert paused_pair_plan.plan_state == PlanState.PlanState_PAUSED, \
                    f"Mismatched: plan state must be PAUSED, found: {paused_pair_plan.plan_state}"

                time.sleep(5)
                check_str = ("Received ChoreEventType.OE_AMD_ACK for amend qty which makes chore OVER_CXLED to chore "
                             "which was ChoreStatusType.OE_DOD before")
                assert_fail_msg = f"Can't find alert of {check_str!r} in neither plan_alert nor contact_alert"
                check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id,
                                                                   check_str, assert_fail_msg)
            else:
                check_str = ("Received ChoreEventType.OE_AMD_ACK for amend qty which makes chore DOD, before status "
                             "was ChoreStatusType.OE_DOD - applying amend and putting chore as DOD")
                time.sleep(5)

                assert_fail_msg = f"Can't find alert of {check_str!r} in neither plan_alert nor contact_alert"
                check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id,
                                                                   check_str, assert_fail_msg)

            if side == Side.BUY:
                # forcefully turning plan to active again for checking sell chore
                pair_plan = email_book_service_native_web_client.get_pair_plan_client(active_pair_plan.id)
                pair_plan.plan_state = PlanState.PlanState_ACTIVE
                email_book_service_native_web_client.put_pair_plan_client(pair_plan)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))
        
        
@pytest.mark.nightly
def test_lapse_pre_non_risky_amend_req(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            print("Checking chore post OE_ACK")
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            print("Checking chore post LAPSE")
            chore_status = ChoreStatusType.OE_ACKED
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            print("Checking chore post OE_AMD_UNACK")
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            print("Checking chore post OE_AMD_ACK")
            if side == Side.BUY:
                cxled_qty += amend_qty
                new_px = px - amend_px
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0
            else:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            chore_status = ChoreStatusType.OE_ACKED
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            print("Checking chore cxled post residual time wait")
            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)

            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty += open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_filled_notional = filled_notional
                buy_cxl_notional = cxled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_qty_n_amend_up_same_qty_in_non_risky_amend(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    Amend up is non_risky on Sell side so using sell side only
    """
    leg1_symbol = leg1_leg2_symbol_list[0][0]
    leg2_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        leg1_symbol, leg2_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list, leg1_side=Side.SELL, leg2_side=Side.BUY)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(leg1_symbol, leg2_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(95, 110, leg1_symbol, Side.SELL)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, sell_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            print("Checking chore post OE_ACK")
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            residual_qty = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            print("Checking chore post LAPSE")
            chore_status = ChoreStatusType.OE_ACKED
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes
            amend_px = 1
            amend_qty = 10
            pending_amend_up_px = amend_px
            pending_amend_up_qty = amend_qty
            chore_event = ChoreEventType.OE_AMD_UP_UNACK
            chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            print("Checking chore post OE_AMD_UNACK")
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            print("Checking chore post OE_AMD_ACK")
            new_qty = qty + amend_qty
            total_amend_dn_qty = 0
            total_amend_up_qty = 10
            new_px = px + amend_px
            chore_status = ChoreStatusType.OE_ACKED
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = - open_notional
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            print("Checking chore cxled post residual time wait")
            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(new_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty += open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = 0
            filled_exposure = - filled_notional
            cxled_exposure = - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty, is_sell_buy_plan=True)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise Exception(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_qty_n_amend_up_same_qty_in_risky_amend(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    Amend up is risky on Buy side so using buy side only
    """
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        for px, qty, chore_symbol, side in [(100, 90, buy_symbol, Side.BUY)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, sell_inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            print("Checking chore post OE_ACK")
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            residual_qty = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = open_notional
            filled_exposure = filled_notional
            cxled_exposure = cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            print("Checking chore post LAPSE")
            chore_status = ChoreStatusType.OE_ACKED
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = open_notional
            filled_exposure = filled_qty * get_px_in_usd(px)
            cxled_exposure = cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes
            amend_px = 1
            amend_qty = 10
            pending_amend_up_px = amend_px
            pending_amend_up_qty = amend_qty
            chore_event = ChoreEventType.OE_AMD_UP_UNACK
            chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            print("Checking chore post OE_AMD_UNACK")
            new_qty = qty + amend_qty
            new_px = px + amend_px
            total_amend_dn_qty = 0
            total_amend_up_qty = amend_qty
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            open_exposure = open_notional
            filled_exposure = filled_qty * get_px_in_usd(px)
            cxled_exposure = cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            print("Checking chore post OE_AMD_ACK")
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            print("Checking chore cxled post residual time wait")
            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(new_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            residual_qty += open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            other_side_residual_qty = 0
            other_side_fill_notional = 0
            open_exposure = 0
            filled_exposure = filled_notional
            cxled_exposure = cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))
    

@pytest.mark.nightly
def test_lapse_pre_risky_amend_req(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            print("Checking chore post OE_ACK")
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            print("Checking chore post LAPSE")
            chore_status = ChoreStatusType.OE_ACKED
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            print("Checking chore post OE_AMD_UNACK")
            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                cxled_qty += amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            last_original_qty = qty
            last_original_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            print("Checking chore post OE_AMD_ACK")
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            print("Checking chore cxled post residual time wait")
            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty += open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise e
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_pre_risky_amend_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            print("Checking chore post OE_ACK")
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            print("Checking chore post OE_AMD_UNACK")
            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                cxled_qty += amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            print("Checking chore post LAPSE")
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            cxled_qty += lapse_qty
            residual_qty = lapse_qty
            cxled_notional += lapse_qty * get_px_in_usd(new_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            print("Checking chore post OE_AMD_ACK")
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty,total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            print("Checking chore cxled post residual time wait")
            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty += open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise e
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_pre_risky_amend_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            print("Checking chore post OE_ACK")
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            print("Checking chore post OE_AMD_UNACK")
            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                cxled_qty += amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            print("Checking chore post LAPSE")
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            cxled_qty += lapse_qty
            residual_qty = lapse_qty
            cxled_notional += lapse_qty * get_px_in_usd(new_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            print("Checking chore post OE_AMD_ACK")
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty,total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            print("Checking chore cxled post residual time wait")
            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            residual_qty += open_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise e
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))
        

@pytest.mark.nightly
def test_full_lapse_pre_risky_amend_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            print("Checking chore post OE_ACK")
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            print("Checking chore post OE_AMD_UNACK")
            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                cxled_qty += amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # putting lapse qty before amend ack comes
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=None)
            lapse_qty = open_qty

            print("Checking chore post LAPSE")
            open_qty = 0
            open_notional = 0
            open_px = 0
            chore_status = ChoreStatusType.OE_DOD
            cxled_qty += lapse_qty
            residual_qty = lapse_qty
            cxled_notional += lapse_qty * get_px_in_usd(new_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            open_qty = 0
            open_notional = 0
            open_px = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, last_filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise Exception(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_post_non_risky_amend(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_ack_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_ACK,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            if side == Side.BUY:
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                new_qty = qty
                new_px = px - amend_px
                total_amend_dn_qty = 10
                total_amend_up_qty = 0
            else:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = 10

            chore_status = ChoreStatusType.OE_ACKED
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            print("Checking chore post LAPSE")
            chore_status = ChoreStatusType.OE_ACKED
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            cxled_qty += lapse_qty
            residual_qty = lapse_qty
            cxled_notional += lapse_qty * get_px_in_usd(new_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure, lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(open_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_residual_qty = lapse_qty + open_qty
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
            residual_qty += open_qty
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_pre_non_risky_amend_rej_req(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            print("Checking chore post LAPSE")
            chore_status = ChoreStatusType.OE_ACKED
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty += lapse_qty
            residual_qty = lapse_qty
            cxled_notional += lapse_qty * get_px_in_usd(px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure, lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            print("Checking chore post OE_AMD_UNACK")
            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            print("Checking chore post OE_AMD_REJ")
            # Placing Amend REJ chore
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            open_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            print("Checking chore post OE_CXL_ACK")
            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(px)
            cxled_px = px
            residual_qty += open_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0

            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_pre_non_risky_amend_rej_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            # putting lapse before cxl_ack
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            print("Checking chore post OE_AMD_REJ")
            # Placing Amend REJ chore
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            open_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(px)
            new_qty = qty
            residual_qty = cxled_qty
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            filled_notional = filled_qty * get_px_in_usd(px)
            if side == Side.BUY:
                buy_filled_notional = filled_notional
                buy_residual_qty = cxled_qty
                buy_cxl_notional = cxled_notional
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = 0
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise e
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_full_lapse_pre_non_risky_amend_rej_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # buy test
        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_filled_notional = None
        buy_cxl_notional = None
        buy_residual_qty = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # putting lapse qty before amend ack comes
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=None)
            lapse_qty = open_qty

            # putting lapse before cxl_ack
            open_qty = 0
            open_notional = 0
            open_px = 0
            cxled_qty = lapse_qty
            residual_qty = lapse_qty
            cxled_notional = cxled_qty * get_px_in_usd(px)
            cxled_px = px
            lapsed_qty = cxled_qty
            total_lapsed_qty = cxled_qty
            chore_status = ChoreStatusType.OE_DOD
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            print("Checking chore post OE_AMD_REJ")
            # Placing Amend REJ chore
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            time.sleep(5)
            check_str = (f"Received AMD_REJ post chore DOD on chore_id: "
                         f".* - ignoring this amend chore_journal and chore will stay unchanged")
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise e
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_post_non_risky_amend_rej_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)
            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = cxled_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend req chore and checking computes should stay same since it is non-risky amend
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_px = amend_px
                pending_amend_dn_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_px = amend_px
                pending_amend_up_qty = amend_qty
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = 0
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # Placing Amend ACK chore and checking amend should be applied on ack
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            chore_status = ChoreStatusType.OE_ACKED
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            print("Checking chore post LAPSE")
            chore_status = ChoreStatusType.OE_ACKED
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty += lapse_qty
            residual_qty = lapse_qty
            cxled_notional += lapse_qty * get_px_in_usd(px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure, lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            print("Checking chore post OE_CXL_ACK")
            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_DOD
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(px)
            cxled_px = px
            residual_qty += open_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
            filled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0

            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_qty * get_px_in_usd(px)
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))

    
@pytest.mark.nightly
def test_lapse_pre_risky_amend_rej_req(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)

            expected_chore_notional = qty * get_px_in_usd(px)
            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            print("Checking chore post LAPSE")
            chore_status = ChoreStatusType.OE_ACKED
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty += lapse_qty
            residual_qty = lapse_qty
            cxled_notional += lapse_qty * get_px_in_usd(px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure, lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            print("Checking chore post OE_AMD_UNACK")
            # Placing Amend req chore and checking computes
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_qty = amend_qty
                pending_amend_up_px = amend_px
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_qty = amend_qty
                pending_amend_dn_px = amend_px
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED
        
            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)
        
            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                available_qty = qty - lapse_qty
                new_qty = qty
                new_px = px - amend_px
                cxled_qty += amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            last_original_qty = qty
            last_original_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            print("Checking chore post OE_AMD_REJ")
            # Placing Amend REJ
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            if side == Side.SELL:
                cxled_qty -= amend_qty
                cxled_notional -= amend_qty * get_px_in_usd(px)
            open_qty = qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            print("Checking chore post OE_CXL_ACK")
            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            chore_status = ChoreStatusType.OE_DOD
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(px)
            residual_qty += open_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
            cxled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_pre_risky_amend_rej_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            if side == Side.BUY:
                buy_filled_qty = filled_qty

            expected_chore_notional = qty * get_px_in_usd(px)
            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0

            print("Checking chore post OE_AMD_UNACK")
            # Placing Amend req chore and checking computes
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_qty = amend_qty
                pending_amend_up_px = amend_px
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_qty = amend_qty
                pending_amend_dn_px = amend_px
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                new_qty = qty
                new_px = px - amend_px
                cxled_qty += amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)

            print("Checking chore post LAPSE")
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            cxled_qty += lapse_qty
            residual_qty = lapse_qty
            cxled_notional += lapse_qty * get_px_in_usd(new_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure, lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            print("Checking chore post OE_AMD_REJ")
            # Placing Amend REJ
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            cxled_qty = lapse_qty
            if side == Side.BUY:
                cxled_notional = cxled_qty * get_px_in_usd(px + amend_px)
            else:
                cxled_notional = cxled_qty * get_px_in_usd(px - amend_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            open_qty = qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            print("Checking chore post OE_CXL_ACK")
            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_DOD
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(px)
            residual_qty += open_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_full_lapse_pre_risky_amend_rej_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
            config_dict["symbol_configs"][symbol]["continues_chore_count"] = 0
            config_dict["symbol_configs"][symbol]["continues_special_chore_count"] = 1
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type),
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            if side == Side.BUY:
                buy_filled_qty = filled_qty

            expected_chore_notional = qty * get_px_in_usd(px)
            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0

            print("Checking chore post OE_AMD_UNACK")
            # Placing Amend req chore and checking computes
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_qty = amend_qty
                pending_amend_up_px = amend_px
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_qty = amend_qty
                pending_amend_dn_px = amend_px
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                new_qty = qty
                new_px = px - amend_px
                cxled_qty += amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # putting lapse qty before amend ack comes
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=None)
            lapse_qty = open_qty

            print("Checking chore post LAPSE")
            open_qty = 0
            open_notional = 0
            open_px = 0
            chore_status = ChoreStatusType.OE_DOD
            cxled_qty += lapse_qty
            residual_qty = lapse_qty
            cxled_notional += lapse_qty * get_px_in_usd(new_px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
                buy_residual_qty = residual_qty
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure, lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            print("Checking chore post OE_AMD_REJ")
            # Placing Amend REJ
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            time.sleep(5)
            check_str = (f"Received AMD_REJ post chore DOD on chore_id: "
                         f".* - ignoring this amend chore_journal and chore will stay unchanged")
            assert_fail_msg = f"Can't find alert: {check_str!r}"
            check_alert_str_in_plan_alerts_n_contact_alerts(active_pair_plan.id, check_str, assert_fail_msg)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


@pytest.mark.nightly
def test_lapse_post_risky_amend_rej_ack(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
            config_dict["symbol_configs"][symbol]["fill_percent"] = 50
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

        buy_residual_qty = None
        buy_cxl_notional = None
        buy_filled_notional = None
        for px, qty, chore_symbol, side, inst_type in [(100, 90, buy_symbol, Side.BUY, buy_inst_type), 
                                                       (95, 110, sell_symbol, Side.SELL, sell_inst_type)]:
            place_new_chore(chore_symbol, side, px, qty, executor_http_client, inst_type)

            # checking ACK chore before amend
            latest_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, chore_symbol,
                                                                            executor_http_client)

            filled_qty = get_partial_allowed_fill_qty(chore_symbol, config_dict, qty)
            if side == Side.BUY:
                buy_filled_qty = filled_qty

            expected_chore_notional = qty * get_px_in_usd(px)
            chore_snapshot = get_chore_snapshot_from_chore_id(latest_ack_obj.chore.chore_id,
                                                              executor_http_client)

            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            residual_qty = 0
            pending_amend_dn_px = 0
            pending_amend_dn_qty = 0
            pending_amend_up_px = 0
            pending_amend_up_qty = 0

            print("Checking chore post OE_AMD_UNACK")
            # Placing Amend req chore and checking computes
            if side == Side.BUY:
                amend_px = 1
                amend_qty = 10
                pending_amend_up_qty = amend_qty
                pending_amend_up_px = amend_px
                chore_event = ChoreEventType.OE_AMD_UP_UNACK
                chore_status = ChoreStatusType.OE_AMD_UP_UNACKED
            else:
                amend_px = 1
                amend_qty = 10
                pending_amend_dn_qty = amend_qty
                pending_amend_dn_px = amend_px
                chore_event = ChoreEventType.OE_AMD_DN_UNACK
                chore_status = ChoreStatusType.OE_AMD_DN_UNACKED

            executor_http_client.barter_simulator_process_amend_req_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                chore_event=chore_event,
                qty=amend_qty, px=amend_px)

            latest_amend_unack_obj = get_latest_chore_journal_with_event_and_symbol(chore_event,
                                                                                    chore_symbol, executor_http_client)

            if side == Side.BUY:
                new_qty = qty + amend_qty
                new_px = px + amend_px
                cxled_qty = 0
                cxled_px = 0
                cxled_notional = 0
                total_amend_dn_qty = 0
                total_amend_up_qty = amend_qty
            else:
                new_qty = qty
                new_px = px - amend_px
                cxled_qty = amend_qty
                cxled_px = px
                cxled_notional = cxled_qty * get_px_in_usd(cxled_px)
                total_amend_dn_qty = amend_qty
                total_amend_up_qty = 0

            residual_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = new_qty - filled_qty - cxled_qty
            open_notional = open_qty * get_px_in_usd(new_px)
            open_px = new_px
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            # Placing Amend REJ
            executor_http_client.barter_simulator_process_amend_rej_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account)

            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_AMD_REJ,
                                                                                  chore_symbol,
                                                                                  executor_http_client)
            new_qty = qty
            new_px = px
            chore_status = ChoreStatusType.OE_ACKED
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            open_qty = qty - filled_qty
            open_notional = open_qty * get_px_in_usd(px)
            open_px = px
            cxled_qty = 0
            cxled_notional = 0
            cxled_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional

            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

            print("Checking chore post LAPSE")
            # putting lapse qty before amend ack comes
            lapse_qty = 10
            executor_http_client.barter_simulator_process_lapse_query_client(
                latest_ack_obj.chore.chore_id,
                latest_ack_obj.chore.side,
                latest_ack_obj.chore.security.sec_id,
                latest_ack_obj.chore.underlying_account,
                qty=lapse_qty)
            chore_status = ChoreStatusType.OE_ACKED
            open_qty -= lapse_qty
            open_notional = open_qty * get_px_in_usd(px)
            cxled_qty += lapse_qty
            residual_qty = lapse_qty
            cxled_notional += lapse_qty * get_px_in_usd(px)
            cxled_px = get_usd_to_local_px_or_notional(cxled_notional) / cxled_qty
            lapsed_qty = lapse_qty
            total_lapsed_qty = lapse_qty
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = open_notional
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_lapse(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    qty, px, chore_status, open_qty, open_notional, open_px, filled_qty,
                    filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure,
                    cxled_exposure, lapsed_qty, total_lapsed_qty, residual_qty=residual_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise ass_e
            except Exception as e:
                print("Exception", e)
                raise e

            # waiting for chore to get cxled
            time.sleep(residual_wait_sec)

            print("Checking chore post OE_CXL_ACK")
            latest_amend_ack_obj = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_CXL_ACK,
                                                                                  chore_symbol, executor_http_client)
            new_qty = qty
            new_px = px
            # amend_qty = None
            # amend_px = None
            chore_status = ChoreStatusType.OE_DOD
            total_amend_dn_qty = 0
            total_amend_up_qty = 0
            filled_notional = filled_qty * get_px_in_usd(px)
            filled_px = px
            cxled_qty += open_qty
            cxled_notional += open_qty * get_px_in_usd(px)
            residual_qty += open_qty
            if side == Side.BUY:
                buy_residual_qty = residual_qty
                buy_cxl_notional = cxled_notional
                buy_filled_notional = filled_notional
            cxled_px = px
            open_qty = 0
            open_notional = 0
            open_px = 0
            if side == Side.BUY:
                other_side_residual_qty = 0
                other_side_fill_notional = 0
                open_exposure = 0
                filled_exposure = filled_notional
                cxled_exposure = cxled_notional
            else:
                other_side_residual_qty = buy_residual_qty
                buy_symbol_side_snapshot_list = (
                    executor_http_client.get_symbol_side_snapshot_from_symbol_side_query_client(
                        buy_symbol, Side.BUY))
                other_side_fill_notional = buy_symbol_side_snapshot_list[0].total_fill_notional
                open_exposure = - open_notional
                filled_exposure = buy_filled_notional - filled_notional
                cxled_exposure = buy_cxl_notional - cxled_notional
            last_filled_qty = filled_qty
            try:
                check_all_computes_for_amend(
                    active_pair_plan, chore_symbol, side, latest_ack_obj.chore.chore_id, executor_http_client,
                    new_qty, new_px, chore_status, pending_amend_dn_px, pending_amend_dn_qty, pending_amend_up_px,
                    pending_amend_up_qty, total_amend_dn_qty, total_amend_up_qty, open_qty, open_notional, open_px,
                    filled_qty, filled_notional, filled_px, filled_qty, cxled_qty, cxled_notional, cxled_px,
                    other_side_residual_qty, other_side_fill_notional, open_exposure, filled_exposure, cxled_exposure,
                    residual_qty=residual_qty, total_lapsed_qty=total_lapsed_qty)
            except AssertionError as ass_e:
                print("ASSERT", ass_e)
                raise AssertionError(ass_e)
            except Exception as e:
                print("Exception", e)
                raise Exception(e)

    except AssertionError as e:
        raise AssertionError(e)
    except Exception as e:
        err_str_ = (f"Some Error Occurred: exception: {e}, "
                    f"traceback: {''.join(traceback.format_exception(None, e, e.__traceback__))}")
        print(err_str_)
        raise Exception(err_str_)
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))


def looped_update_residuals_query_client_call(buy_symbol, sell_symbol, executor_http_client):
    while 1:
        executor_http_client.update_residuals_query_client(buy_symbol, Side.BUY, 1)
        executor_http_client.update_residuals_query_client(sell_symbol, Side.SELL, 1)
        time.sleep(0.1)


@pytest.mark.nightly
def test_verify_deadlock_in_update_residuals_query(
        static_data_, clean_and_set_limits, pair_securities_with_sides_,
        buy_chore_, sell_chore_, buy_fill_journal_,
        sell_fill_journal_, expected_buy_chore_snapshot_,
        expected_sell_chore_snapshot_, expected_symbol_side_snapshot_,
        pair_plan_, expected_plan_limits_, expected_plan_status_,
        expected_plan_brief_, expected_contact_status_,
        last_barter_fixture_list, symbol_overview_obj_list,
        market_depth_basemodel_list, expected_chore_limits_,
        expected_contact_limits_, max_loop_count_per_side,
        leg1_leg2_symbol_list, refresh_sec_update_fixture):
    """
    triggers buy & sell pair chore (single buy chore followed by single sell chore) for max_loop_count_per_side times
    """
    buy_symbol = leg1_leg2_symbol_list[0][0]
    sell_symbol = leg1_leg2_symbol_list[0][1]
    expected_plan_limits_.residual_restriction.residual_mark_seconds = 2 * refresh_sec_update_fixture
    residual_wait_sec = 4 * refresh_sec_update_fixture

    (active_pair_plan, executor_http_client, buy_inst_type, sell_inst_type,
     config_file_path, config_dict, config_dict_str) = handle_pre_chore_test_requirements(
        buy_symbol, sell_symbol, pair_plan_, expected_plan_limits_,
        expected_plan_status_, symbol_overview_obj_list, last_barter_fixture_list,
        market_depth_basemodel_list)

    try:
        # updating yaml_configs according to this test
        for symbol in config_dict["symbol_configs"]:
            config_dict["symbol_configs"][symbol]["simulate_reverse_path"] = True
        YAMLConfigurationManager.update_yaml_configurations(config_dict, str(config_file_path))

        # updating simulator's configs
        executor_http_client.barter_simulator_reload_config_query_client()

        # calling update_residual query parallel to chore placed
        residuals_query_client_call_thread = (
            threading.Thread(target=looped_update_residuals_query_client_call,
                             args=(buy_symbol, sell_symbol, executor_http_client,), daemon=True))
        residuals_query_client_call_thread.start()

        last_buy_chore_id = None
        last_sell_chore_id = None
        leg1_last_barter: LastBarterBaseModel | None = None
        leg2_last_barter: LastBarterBaseModel | None = None
        for loop_count in range(1, max_loop_count_per_side + 1):
            if leg1_last_barter is not None:
                last_barter_fixture_list[0]["market_barter_volume"][
                    "participation_period_last_barter_qty_sum"] = leg1_last_barter.market_barter_volume.participation_period_last_barter_qty_sum
            if leg2_last_barter is not None:
                last_barter_fixture_list[1]["market_barter_volume"][
                    "participation_period_last_barter_qty_sum"] = leg2_last_barter.market_barter_volume.participation_period_last_barter_qty_sum
            leg1_last_barter, leg2_last_barter = run_last_barter(buy_symbol, sell_symbol, last_barter_fixture_list, active_pair_plan.cpp_port)

            px = 100
            qty = 90
            place_new_chore(buy_symbol, Side.BUY, px, qty, executor_http_client, buy_inst_type)
            ack_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, buy_symbol,
                                                                               executor_http_client,
                                                                               last_chore_id=last_buy_chore_id)
            last_buy_chore_id = ack_chore_journal.chore.chore_id
            latest_fill_journal = get_latest_fill_journal_from_chore_id(ack_chore_journal.chore.chore_id,
                                                                        executor_http_client)
            time.sleep(2)

            px = 95
            qty = 110
            place_new_chore(sell_symbol, Side.SELL, px, qty, executor_http_client, sell_inst_type)
            ack_chore_journal = get_latest_chore_journal_with_event_and_symbol(ChoreEventType.OE_ACK, sell_symbol,
                                                                               executor_http_client,
                                                                               last_chore_id=last_sell_chore_id)
            last_sell_chore_id = ack_chore_journal.chore.chore_id
            latest_fill_journal = get_latest_fill_journal_from_chore_id(ack_chore_journal.chore.chore_id,
                                                                        executor_http_client)

    except AssertionError as e:
        print(e)
        raise e
    finally:
        YAMLConfigurationManager.update_yaml_configurations(config_dict_str, str(config_file_path))

# def test_log_barter_simulator_trigger_kill_switch_and_resume_bartering():
#     log_dir: PurePath = PurePath(
#         __file__).parent.parent.parent.parent.parent / "Flux" / "CodeGenProjects" / "phone_book" / "log "
#     configure_logger("debug", str(log_dir), "test_log_barter_simulator.log")
#
#     LogBarterSimulator.trigger_kill_switch()
#     time.sleep(5)
#
#     contact_status_id = 1
#     contact_status = email_book_service_native_web_client.get_contact_status_client(contact_status_id)
#     assert contact_status.kill_switch
#
#     LogBarterSimulator.revoke_kill_switch_n_resume_bartering()
#     time.sleep(5)
#
#     contact_status = email_book_service_native_web_client.get_contact_status_client(contact_status_id)
#     assert not contact_status.kill_switch

@pytest.mark.nightly
def test_quote_create_from_df(sample_quote_df):
    # Test creating QuoteBaseModel from DataFrame
    quote = QuoteBaseModel.create_from_df(sample_quote_df)

    assert isinstance(quote, QuoteBaseModel)
    assert isinstance(quote.px, float)
    assert isinstance(quote.qty, int)
    assert isinstance(quote.premium, float)


@pytest.mark.nightly
def test_quote_create_from_df_array(sample_quote_df):
    # Test creating array of QuoteBaseModel from DataFrame
    quotes = QuoteBaseModel.create_from_df_array(sample_quote_df)

    assert isinstance(quotes, list)
    assert len(quotes) == sample_quote_df.height
    assert all(isinstance(q, QuoteBaseModel) for q in quotes)

@pytest.mark.nightly
def test_empty_dataframe():
    empty_df = pl.DataFrame({
        'px': [],
        'qty': [],
        'premium': [],
        'last_update_date_time': []
    })

    with pytest.raises(ValueError, match="DataFrame is empty"):
        QuoteBaseModel.create_from_df(empty_df)

    assert QuoteBaseModel.create_from_df_array(empty_df) == []

@pytest.mark.nightly
def test_update_from_df(sample_quote_df):
    # Create initial quote
    quote = QuoteBaseModel(
        px=0.0,
        qty=0,
        premium=0.0,
        last_update_date_time=pendulum.now('UTC')
    )

    # Update from DataFrame
    success = quote.update_from_df(sample_quote_df)

    assert success is True
    assert quote.px == sample_quote_df['px'][0]
    assert quote.qty == sample_quote_df['qty'][0]
    assert quote.premium == sample_quote_df['premium'][0]

@pytest.mark.nightly
def test_top_of_book_create_from_df(sample_top_of_book_df):
    # Test creating TopOfBookBaseModel from DataFrame
    tob = TopOfBookBaseModel.create_from_df(sample_top_of_book_df)

    assert isinstance(tob, TopOfBookBaseModel)
    assert isinstance(tob.id, int)
    assert isinstance(tob.symbol, str)
    assert isinstance(tob.total_bartering_security_size, int)


